# 第一章

## 1.1.1 操作系统的概念、功能和目标

### 概念

![image-20211103115018195](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115018195.png)

![image-20211103115200226](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115200226.png)

### 操作系统的功能和目标

#### 作为系统资源的管理者

![image-20211103115712145](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115712145.png)

#### 作为用户和计算机硬件组件的接口

![image-20211103120016365](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120016365.png)

![image-20211103120053940](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120053940.png)

![image-20211103120233729](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120233729.png)

![image-20211103120358829](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120358829.png)

#### 作为最接近硬件的层次

![image-20211103120518860](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120518860.png)

![image-20211103120633504](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120633504.png)

## 1.1.2 操作系统的四个特征

### 并发

![image-20211103120803313](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120803313.png)

![image-20211103120956401](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120956401.png)

### 共享

![image-20211103121156250](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121156250.png)

![image-20211103121400007](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121400007.png)

### 虚拟

![image-20211103121530453](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121530453.png)

![image-20211103121731226](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121731226.png)

![image-20211103121912951](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121912951.png)

个人理解：虚拟技术其实就是让 cpu、存储器在不同的时间段分配给不同的进程使用，让用户看起来好像一个 cpu 一次性能运行多个程序，其实从微观上看 cpu 在某个时间段只能去运行一个程序

### 异步

![image-20211103122243380](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103122243380.png)

### 总结

![image-20211103122932820](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103122932820.png)

## 1.1.3 操作系统的发展与分类

### 实时操作系统

![image-20211103133616304](操作系统.assets/image-20211103133616304.png)

### 其他几种系统

![image-20211103133648539](操作系统.assets/image-20211103133648539.png)

### 总结

![image-20211103133825474](操作系统.assets/image-20211103133825474.png)

## 1.1.4 操作系统的运行机制和体系结构

### 知识总览

![image-20211103134048827](操作系统.assets/image-20211103134048827.png)

### 什么是指令

![image-20211103134613462](操作系统.assets/image-20211103134613462.png)

### 两种指令

![image-20211103134727671](操作系统.assets/image-20211103134727671.png)

### 两种处理器状态

![image-20211103134824413](操作系统.assets/image-20211103134824413.png)

### 两种程序的区别

![image-20211103134942875](操作系统.assets/image-20211103134942875.png)

### 运行机制

![image-20211103135042738](操作系统.assets/image-20211103135042738.png)

### 操作系统的内核

![image-20211103140406474](操作系统.assets/image-20211103140406474.png)

tips：原子性：一执行就不能被中断

![image-20211103140522431](操作系统.assets/image-20211103140522431.png)

![image-20211103140634695](操作系统.assets/image-20211103140634695.png)

### 操作系统的体系结构

![image-20211103141003115](操作系统.assets/image-20211103141003115.png)

### 总结 

![image-20211103141314500](操作系统.assets/image-20211103141314500.png)

## 1.1.5 中断和异常

### 知识总览

![image-20211105081236526](操作系统.assets/image-20211105081236526.png)

### 中断机制的诞生

我们知道旧的计算机只能串行执行程序

![image-20211105081555977](操作系统.assets/image-20211105081555977.png)

### 中断的概念和作用

![image-20211105081852158](操作系统.assets/image-20211105081852158.png)

### 中断分类

![image-20211105082209218](操作系统.assets/image-20211105082209218.png)

![image-20211105082302079](操作系统.assets/image-20211105082302079.png)

### 外中断的处理过程

![image-20211105082517455](操作系统.assets/image-20211105082517455.png)

### 总结

![image-20211105082800663](操作系统.assets/image-20211105082800663.png)

## 1.1.6 系统调用

### 知识总览

![image-20211105082842438](操作系统.assets/image-20211105082842438.png)

### 什么是系统调用

![image-20211105083242922](操作系统.assets/image-20211105083242922.png)

![image-20211105083410079](操作系统.assets/image-20211105083410079.png)

![image-20211105083957672](操作系统.assets/image-20211105083957672.png)

### 系统调用与库函数的区别

![image-20211105085207181](操作系统.assets/image-20211105085207181.png)

tips：其实我们用的很多的库其实就是帮助我们屏蔽掉许多系统调用复杂的细节，方便我们更加便捷开发（如果说没有这些库函数的辅助，我们直接自己进行系统调用，那编程将变得十分繁琐）

### 系统调用背后的过程

![image-20211105085407128](操作系统.assets/image-20211105085407128.png)

![image-20211105085922853](操作系统.assets/image-20211105085922853.png)

tips：陷入指令（trap）是唯一一个核心态下系统无法调用的指令，它只能在用户态下调用，让用户态转化为核心态

### 总结

![image-20211105090336554](操作系统.assets/image-20211105090336554.png)

# 第 二 章 进程

## 2.1.1 进程的定义、组成、组织方式、特征

### 知识总览

![image-20211105090622450](操作系统.assets/image-20211105090622450.png)

### 进程的定义

![image-20211105090950732](操作系统.assets/image-20211105090950732.png)

tips：这个阶段系统资源总是被一个程序独享

![image-20211105091208940](操作系统.assets/image-20211105091208940.png)

tips：这个阶段系统资源被多个程序使用

![image-20211105092134156](操作系统.assets/image-20211105092134156.png)

个人理解进程：每个进程就像每一条流水线一样，具备将产品加工完成的功能，但是要注意这两条流水线中间的工具不能同时使用，进程多不一定好，因为资源有限，这样当要拿同一个系统资源的时候就有人需要等待，反而会让每个进程需要等待的时间更久，最理想的状态就是你用的时候永远没人用，你不用的时候永远有人用

### 进程的组成

![image-20211105092831407](操作系统.assets/image-20211105092831407.png)

![image-20211105092936512](操作系统.assets/image-20211105092936512.png)

### 进程的组织

![image-20211106125740107](操作系统.assets/image-20211106125740107.png)

![image-20211106130853689](操作系统.assets/image-20211106130853689.png)

![image-20211106130946873](操作系统.assets/image-20211106130946873.png)

### 进程的特征

![image-20211106131212580](操作系统.assets/image-20211106131212580.png)

### 总结

![image-20211106131449607](操作系统.assets/image-20211106131449607.png)

## 2.1.2 进程的状态与转换

### 知识总览

![image-20211106131755798](操作系统.assets/image-20211106131755798.png)

### 进程的状态

#### 三种基本状态

 ![image-20211106132147992](操作系统.assets/image-20211106132147992.png)

#### 另外两种状态

![image-20211106132501030](操作系统.assets/image-20211106132501030.png)

#### 进程状态的转换

![image-20211106132935471](操作系统.assets/image-20211106132935471.png)

#### 总结

![image-20211106133147561](操作系统.assets/image-20211106133147561.png)

## 2.1.3 进程控制

![image-20211106192754242](操作系统.assets/image-20211106192754242.png)

### 什么是进程控制

![image-20211106193034006](操作系统.assets/image-20211106193034006.png)

### 如何实现进程控制

![image-20211106193432004](操作系统.assets/image-20211106193432004.png)

![image-20211106193655530](操作系统.assets/image-20211106193655530.png)

### 进程相关的原语 

![image-20211106194243900](操作系统.assets/image-20211106194243900.png)

![image-20211106194434688](操作系统.assets/image-20211106194434688.png)

![image-20211106194529952](操作系统.assets/image-20211106194529952.png)

![image-20211106194630363](操作系统.assets/image-20211106194630363.png)

## 2.1.4 进程通信

![image-20211106194741490](操作系统.assets/image-20211106194741490.png)

### 什么是进程通信

![image-20211106195043462](操作系统.assets/image-20211106195043462.png)

### 进程通信--共享存储

![image-20211106195706405](操作系统.assets/image-20211106195706405.png)

### 进程通信---管道通信

![image-20211106200117267](操作系统.assets/image-20211106200117267.png)

### 进程通信--消息传递

![image-20211106200542414](操作系统.assets/image-20211106200542414.png)

### 总结

![image-20211106200952779](操作系统.assets/image-20211106200952779.png)

## 2.1.5 线程概念和多线程模型

### 知识总览

![image-20211106201055885](操作系统.assets/image-20211106201055885.png)

### 什么是线程，为什么要引入线程

![image-20211106201226674](操作系统.assets/image-20211106201226674.png)

![image-20211106201447085](操作系统.assets/image-20211106201447085.png)

![image-20211106201852026](操作系统.assets/image-20211106201852026.png)

### 引入线程机制后，有什么变化

![image-20211106202141469](操作系统.assets/image-20211106202141469.png)

### 线程的属性

![image-20211106202621171](操作系统.assets/image-20211106202621171.png)

### 线程的实现方式

 ![image-20211106203044610](操作系统.assets/image-20211106203044610.png)

![image-20211106203422983](操作系统.assets/image-20211106203422983.png)

![image-20211106203649397](操作系统.assets/image-20211106203649397.png)

### 多线程模型

**多对一**

![image-20211106204027363](操作系统.assets/image-20211106204027363.png)

**一对一**

![image-20211106204304811](操作系统.assets/image-20211106204304811.png)

**多对多**

![image-20211106204630934](操作系统.assets/image-20211106204630934.png)

### 总结

![image-20211106211316452](操作系统.assets/image-20211106211316452.png)·

## 2.2.1 处理机调度的概念和层次

### 知识总览

![image-20211107130109838](操作系统.assets/image-20211107130109838.png)

### 调度的基本概念

![image-20211107130330159](操作系统.assets/image-20211107130330159.png)

### 调度的三个层次

#### 高级调度

![image-20211107130733555](操作系统.assets/image-20211107130733555.png)

#### 中级调度

![image-20211107131153461](操作系统.assets/image-20211107131153461.png)

**补充知识**

 ![image-20211107131439465](操作系统.assets/image-20211107131439465.png)

#### 低级调度

![image-20211107131555624](操作系统.assets/image-20211107131555624.png)

#### 对比

![image-20211107131929191](操作系统.assets/image-20211107131929191.png)

### 总结

![image-20211107132045951](操作系统.assets/image-20211107132045951.png)

## 2.2.2 进程调度时机、切换与过程、方式

### 知识总览

![image-20211107132414394](操作系统.assets/image-20211107132414394.png)

### 进程调度的时机

![image-20211107132722600](操作系统.assets/image-20211107132722600.png)

![image-20211107133333709](操作系统.assets/image-20211107133333709.png)

### 进程调度的方式

![image-20211107133623456](操作系统.assets/image-20211107133623456.png)

### 进程的切换与过程

![image-20211107133946368](操作系统.assets/image-20211107133946368.png)

### 知识点回顾与重要考点

![image-20211107134107383](操作系统.assets/image-20211107134107383.png)

## 2.2.3 调度算法的评价指标

### 知识总览

![image-20211107134818310](操作系统.assets/image-20211107134818310.png)

### CPU 利用率

![image-20211107134947311](操作系统.assets/image-20211107134947311.png)

### 系统吞吐量

![image-20211107135036249](操作系统.assets/image-20211107135036249.png)

### 周转时间

![image-20211107135328081](操作系统.assets/image-20211107135328081.png)意思就是虽然都是这个时间完成这个任务但是感受不同，比如你等了10分钟上了1分钟的厕所，和别人等了1分钟上了10分钟的厕所体验感是不一样的。所以这个平均周转时间来衡量还不够完美

![image-20211107135630346](操作系统.assets/image-20211107135630346.png)

### 等待时间

![image-20211107135901651](操作系统.assets/image-20211107135901651.png)

### 响应时间

![image-20211107135937786](操作系统.assets/image-20211107135937786.png)

### 总结

![image-20211107135956660](操作系统.assets/image-20211107135956660.png)

## 2.2.4 调度算法（跳过）

## 2.2.5 调度算法（跳过）

## 2.3.1 进程同步、进程互斥

### 知识总览

![image-20211108163126174](操作系统.assets/image-20211108163126174.png)

### 什么是进程同步

![image-20211108163523439](操作系统.assets/image-20211108163523439.png)

![image-20211108163720654](操作系统.assets/image-20211108163720654.png)

总而言之，进程同步就是让会相互影响的异步的进程之间前后关系的一个协调定义。

### 什么是进程互斥

![image-20211108164038226](操作系统.assets/image-20211108164038226.png)

![image-20211108164758584](操作系统.assets/image-20211108164758584.png)

![image-20211108164924028](操作系统.assets/image-20211108164924028.png)

### 总结

![image-20211108164943030](操作系统.assets/image-20211108164943030.png)

## 2.3.2 进程互斥的软件实现方法（跳过）

### 总结

![image-20211108165555000](操作系统.assets/image-20211108165555000.png)

## 2.3.3 进程互斥的硬件实现方法（跳过）

## 2.3.4 信号量机制

### 总结

![image-20211108165828222](操作系统.assets/image-20211108165828222.png)

### 信号量机制

![image-20211108170148381](操作系统.assets/image-20211108170148381.png)

#### 整型信号量

![image-20211108170709589](操作系统.assets/image-20211108170709589.png)

#### 记录型信号量

![image-20211108171003934](操作系统.assets/image-20211108171003934.png)

![image-20211109151750720](操作系统.assets/image-20211109151750720.png)

![image-20211109151920128](操作系统.assets/image-20211109151920128.png)

### 总结

![image-20211109151943842](操作系统.assets/image-20211109151943842.png)

## 2.3.5 用信号量实现进程互斥、同步、前驱关系

### 信号量机制实现进程互斥

![image-20211109152333821](操作系统.assets/image-20211109152333821.png)

### 信号量机制实现进程同步

![image-20211109154628641](操作系统.assets/image-20211109154628641.png)

![image-20211109154931039](操作系统.assets/image-20211109154931039.png)

记住 前 p 后 v，让 p 去阻塞在后面的进程，v 去启动进程，反正不管是 p1 还是 p2 先执行，都会等到 p1 执行后

### 信号量机制实现前驱关系

![image-20211109155343513](操作系统.assets/image-20211109155343513.png)

S1 肯定是在 S2 执行之前执行，因为只有 v 了之后 p 才能继续执行下去

### 总结

![image-20211109155534170](操作系统.assets/image-20211109155534170.png)

## 2.3.6 生产者-消费问题

### 问题描述

![image-20211109161310860](操作系统.assets/image-20211109161310860.png)

### 问题分析

![image-20211109161804816](操作系统.assets/image-20211109161804816.png)

### 如何实现

![image-20211109162047510](操作系统.assets/image-20211109162047510.png)

### 能否改变相邻 p、v 操作的顺序

![image-20211109162330463](操作系统.assets/image-20211109162330463.png)

### 总结

![image-20211109162523325](操作系统.assets/image-20211109162523325.png)

## 2.3.7 多生产者-多消费者问题（跳过）

## 2.3.8 吸烟者问题（跳过）

## 2.3.9 读者-写者问题（跳过）

## 2.3.10 哲学家进餐问题（跳过）

## 2.3.11 管程

### 知识总览

![image-20211109162722773](操作系统.assets/image-20211109162722773.png)

### 为什么要引入管程

![image-20211109162831509](操作系统.assets/image-20211109162831509.png)

### 管程的定义和基本特征

![image-20211109163155983](操作系统.assets/image-20211109163155983.png)

个人理解：管程就好像是对一系列复杂操作进行了封装的函数，暴露出一些 api 供用户使用

### 用管程解决生产者消费者问题

![image-20211109163947900](操作系统.assets/image-20211109163947900.png)

![image-20211109164355251](操作系统.assets/image-20211109164355251.png)

### java 中类似管程的机制

![image-20211109164630517](操作系统.assets/image-20211109164630517.png)

### 总结

![image-20211109164749830](操作系统.assets/image-20211109164749830.png)

## 2.4.1 死锁的概念

### 知识总览

![image-20211109165003491](操作系统.assets/image-20211109165003491.png)

### 什么是死锁

![image-20211109165122429](操作系统.assets/image-20211109165122429.png)

![image-20211109165300873](操作系统.assets/image-20211109165300873.png)

### 死锁、饥饿、死循环的区别

![image-20211109165641064](操作系统.assets/image-20211109165641064.png)

### 死锁产生的必要条件

![image-20211109170010519](操作系统.assets/image-20211109170010519.png)

### 什么时候会发生死锁![image-20211109201518360](操作系统.assets/image-20211109201518360.png)

### 死锁的处理策略

![image-20211109201645139](操作系统.assets/image-20211109201645139.png)

### 总结

![image-20211109201714546](操作系统.assets/image-20211109201714546.png)

## 2.4.2 死锁的处理策略--预防死锁（跳过）

## 2.4.3 死锁的处理策略--避免死锁（跳过）

## 2.4.4 死锁的处理策略--检测和解决（跳过）

# 第三章 内存

## 3.1.1 内存的基础知识

### 知识总览

![image-20211109202021928](操作系统.assets/image-20211109202021928.png)

### 什么是内存？有何作用？

![image-20211109202323265](操作系统.assets/image-20211109202323265.png)

### 几个常用的数量单位

![image-20211109202442198](操作系统.assets/image-20211109202442198.png)

### 进程的运行原理-指令

![image-20211109202716637](操作系统.assets/image-20211109202716637.png)

### 逻辑地址 vs 物理地址

![image-20211109202912516](操作系统.assets/image-20211109202912516.png)

### 从写程序到程序运行过程分析

![image-20211109203031416](操作系统.assets/image-20211109203031416.png)

### 逻辑地址转换为绝对地址

#### 绝对装入

![image-20211109203329173](操作系统.assets/image-20211109203329173.png)

#### 静态重定位

![image-20211109203439071](操作系统.assets/image-20211109203439071.png)

#### 动态重定位

tips：现在的计算机大多采用这种方法

![image-20211109203635748](操作系统.assets/image-20211109203635748.png)

### 链接的三种方式

![image-20211109203819829](操作系统.assets/image-20211109203819829.png)

### 总结

![image-20211109203942121](操作系统.assets/image-20211109203942121.png)

## 3.1.2 内存管理的概念

### 内存空间的分配与回收

![image-20211110193140230](操作系统.assets/image-20211110193140230.png)

### 内存空间的扩展

![image-20211110193257887](操作系统.assets/image-20211110193257887.png)

### 地址转换

![image-20211110193522965](操作系统.assets/image-20211110193522965.png)

### 内存保护

![image-20211110193842106](操作系统.assets/image-20211110193842106.png)

![image-20211110194147760](操作系统.assets/image-20211110194147760.png)

### 总结

![image-20211110194410842](操作系统.assets/image-20211110194410842.png)

## 3.1.3 覆盖与交换

### 知识总览

![image-20211110194459629](操作系统.assets/image-20211110194459629.png)

### 覆盖技术

![image-20211110194716333](操作系统.assets/image-20211110194716333.png)

![image-20211110195047790](操作系统.assets/image-20211110195047790.png)

### 交换技术

![image-20211110200433906](操作系统.assets/image-20211110200433906.png)

**挂起状态回顾**

![image-20211110200547739](操作系统.assets/image-20211110200547739.png)

![image-20211110201110078](操作系统.assets/image-20211110201110078.png)

### 知识回顾与重要考点

![image-20211110201226122](操作系统.assets/image-20211110201226122.png)

## 3.1.4 连续分配管理方式

### 知识总览

![image-20211110201334224](操作系统.assets/image-20211110201334224.png)

### 单一连续分配

![image-20211110201632155](操作系统.assets/image-20211110201632155.png)

### 固定分区分配

![image-20211110201942153](操作系统.assets/image-20211110201942153.png)

![image-20211110202223966](操作系统.assets/image-20211110202223966.png)

### 动态分区分配

![image-20211110203217747](操作系统.assets/image-20211110203217747.png)

![image-20211110203343386](操作系统.assets/image-20211110203343386.png)

![image-20211110203500976](操作系统.assets/image-20211110203500976.png)

![image-20211110203711107](操作系统.assets/image-20211110203711107.png)

![image-20211110203842077](操作系统.assets/image-20211110203842077.png)

![image-20211110204055672](操作系统.assets/image-20211110204055672.png)

![image-20211110204238448](操作系统.assets/image-20211110204238448.png)

![image-20211110204640015](操作系统.assets/image-20211110204640015.png)

### 总结

![image-20211110204813674](操作系统.assets/image-20211110204813674.png)

## 3.1.5 动态分区分配计算法（跳过）

## 3.1.6 基本分页存储管理的基本概念
