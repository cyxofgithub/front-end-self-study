# 第一章

## 1.1.1 操作系统的概念、功能和目标

### 概念

![image-20211103115018195](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115018195.png)

![image-20211103115200226](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115200226.png)

### 操作系统的功能和目标

#### 作为系统资源的管理者

![image-20211103115712145](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103115712145.png)

#### 作为用户和计算机硬件组件的接口

![image-20211103120016365](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120016365.png)

![image-20211103120053940](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120053940.png)

![image-20211103120233729](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120233729.png)

![image-20211103120358829](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120358829.png)

#### 作为最接近硬件的层次

![image-20211103120518860](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120518860.png)

![image-20211103120633504](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120633504.png)

## 1.1.2 操作系统的四个特征

### 并发

![image-20211103120803313](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120803313.png)

![image-20211103120956401](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103120956401.png)

### 共享

![image-20211103121156250](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121156250.png)

![image-20211103121400007](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121400007.png)

### 虚拟

![image-20211103121530453](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121530453.png)

![image-20211103121731226](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121731226.png)

![image-20211103121912951](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103121912951.png)

个人理解：虚拟技术其实就是让 cpu、存储器在不同的时间段分配给不同的进程使用，让用户看起来好像一个 cpu 一次性能运行多个程序，其实从微观上看 cpu 在某个时间段只能去运行一个程序

### 异步

![image-20211103122243380](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103122243380.png)

### 总结

![image-20211103122932820](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211103122932820.png)

## 1.1.3 操作系统的发展与分类

### 实时操作系统

![image-20211103133616304](操作系统.assets/image-20211103133616304.png)

### 其他几种系统

![image-20211103133648539](操作系统.assets/image-20211103133648539.png)

### 总结

![image-20211103133825474](操作系统.assets/image-20211103133825474.png)

## 1.1.4 操作系统的运行机制和体系结构

### 知识总览

![image-20211103134048827](操作系统.assets/image-20211103134048827.png)

### 什么是指令

![image-20211103134613462](操作系统.assets/image-20211103134613462.png)

### 两种指令

![image-20211103134727671](操作系统.assets/image-20211103134727671.png)

### 两种处理器状态

![image-20211103134824413](操作系统.assets/image-20211103134824413.png)

### 两种程序的区别

![image-20211103134942875](操作系统.assets/image-20211103134942875.png)

### 运行机制

![image-20211103135042738](操作系统.assets/image-20211103135042738.png)

### 操作系统的内核

![image-20211103140406474](操作系统.assets/image-20211103140406474.png)

tips：原子性：一执行就不能被中断

![image-20211103140522431](操作系统.assets/image-20211103140522431.png)

![image-20211103140634695](操作系统.assets/image-20211103140634695.png)

### 操作系统的体系结构

![image-20211103141003115](操作系统.assets/image-20211103141003115.png)

### 总结 

![image-20211103141314500](操作系统.assets/image-20211103141314500.png)

## 1.1.5 中断和异常

### 知识总览

![image-20211105081236526](操作系统.assets/image-20211105081236526.png)

### 中断机制的诞生

我们知道旧的计算机只能串行执行程序

![image-20211105081555977](操作系统.assets/image-20211105081555977.png)

### 中断的概念和作用

![image-20211105081852158](操作系统.assets/image-20211105081852158.png)

### 中断分类

![image-20211105082209218](操作系统.assets/image-20211105082209218.png)

![image-20211105082302079](操作系统.assets/image-20211105082302079.png)

### 外中断的处理过程

![image-20211105082517455](操作系统.assets/image-20211105082517455.png)

### 总结

![image-20211105082800663](操作系统.assets/image-20211105082800663.png)

## 1.1.6 系统调用

### 知识总览

![image-20211105082842438](操作系统.assets/image-20211105082842438.png)

### 什么是系统调用

![image-20211105083242922](操作系统.assets/image-20211105083242922.png)

![image-20211105083410079](操作系统.assets/image-20211105083410079.png)

![image-20211105083957672](操作系统.assets/image-20211105083957672.png)

### 系统调用与库函数的区别

![image-20211105085207181](操作系统.assets/image-20211105085207181.png)

tips：其实我们用的很多的库其实就是帮助我们屏蔽掉许多系统调用复杂的细节，方便我们更加便捷开发（如果说没有这些库函数的辅助，我们直接自己进行系统调用，那编程将变得十分繁琐）

### 系统调用背后的过程

![image-20211105085407128](操作系统.assets/image-20211105085407128.png)

![image-20211105085922853](操作系统.assets/image-20211105085922853.png)

tips：陷入指令（trap）是唯一一个核心态下系统无法调用的指令，它只能在用户态下调用，让用户态转化为核心态

### 总结

![image-20211105090336554](操作系统.assets/image-20211105090336554.png)

## 考点

### 1. 了解操作系统的主要特征。

1）并发特征（Concurrence）

***\*区分并发和并行两个定义：从宏观和微观角度\****

并发是两个或多个事件在同一个时间间隔内发生，在宏观上所有的时间同时发生，微观上事件串行发生的。

并行是在任意时刻两个或多个事件同时发生。

如果为多道程序设计，只有一个CPU只能是并发，如果有多个CPU，可以做到并行。

2）共享特征（Sharing）

3）不确定性（异步性）

异步性给系统带来潜在危险，有可能导致与时间有关的错误。

### 2.理解并能详细描述用户与操作系统之间的接口分类。理解系统调用、函数调用区别与联系。

**用户与操作系统之间的接口分类**

（1）程序接口又称应用编程接口API，程序中使用这个接口可以调用操作系统的服务和功能。

（2）操作接口又称作业（或功能）级接口，**是操作系统为用户操作控制计算机工作和提供服务的手段的集合**。

**系统调用和函数调用的区别**

系统调用是操作系统提供给应用程序使用的接口，应用程序可以发出系统调用请求来获得操作系统的服务，而函数调用其实就是帮助我们屏蔽了系统调用复杂的细节，大部分库调用的底层其实就是系统调用，方便我们更加便捷开发，如果说没有函数调用的辅助，我们每一步都进行系统调用，那编程将变得十分繁琐。

# 第 二 章 进程

## 2.1.1 进程的定义、组成、组织方式、特征

### 知识总览

![image-20211105090622450](操作系统.assets/image-20211105090622450.png)

### 进程的定义

![image-20211105090950732](操作系统.assets/image-20211105090950732.png)

tips：这个阶段系统资源总是被一个程序独享

![image-20211105091208940](操作系统.assets/image-20211105091208940.png)

tips：这个阶段系统资源被多个程序使用

![image-20211105092134156](操作系统.assets/image-20211105092134156.png)

个人理解进程：每个进程就像每一条流水线一样，具备将产品加工完成的功能，但是要注意这两条流水线中间的工具不能同时使用，进程多不一定好，因为资源有限，这样当要拿同一个系统资源的时候就有人需要等待，反而会让每个进程需要等待的时间更久，最理想的状态就是你用的时候永远没人用，你不用的时候永远有人用

### 进程的组成

![image-20211105092831407](操作系统.assets/image-20211105092831407.png)

![image-20211105092936512](操作系统.assets/image-20211105092936512.png)

### 进程的组织

![image-20211106125740107](操作系统.assets/image-20211106125740107.png)

![image-20211106130853689](操作系统.assets/image-20211106130853689.png)

![image-20211106130946873](操作系统.assets/image-20211106130946873.png)

### 进程的特征

![image-20211106131212580](操作系统.assets/image-20211106131212580.png)

### 总结

![image-20211106131449607](操作系统.assets/image-20211106131449607.png)

## 2.1.2 进程的状态与转换

### 知识总览

![image-20211106131755798](操作系统.assets/image-20211106131755798.png)

### 进程的状态

#### 三种基本状态

 ![image-20211106132147992](操作系统.assets/image-20211106132147992.png)

#### 另外两种状态

![image-20211106132501030](操作系统.assets/image-20211106132501030.png)

#### 进程状态的转换

![image-20211106132935471](操作系统.assets/image-20211106132935471.png)

#### 总结

![image-20211106133147561](操作系统.assets/image-20211106133147561.png)

## 2.1.3 进程控制

![image-20211106192754242](操作系统.assets/image-20211106192754242.png)

### 什么是进程控制

![image-20211106193034006](操作系统.assets/image-20211106193034006.png)

### 如何实现进程控制

![image-20211106193432004](操作系统.assets/image-20211106193432004.png)

![image-20211106193655530](操作系统.assets/image-20211106193655530.png)

### 进程相关的原语 

![image-20211106194243900](操作系统.assets/image-20211106194243900.png)

![image-20211106194434688](操作系统.assets/image-20211106194434688.png)

![image-20211106194529952](操作系统.assets/image-20211106194529952.png)

![image-20211106194630363](操作系统.assets/image-20211106194630363.png)

## 2.1.4 进程通信

![image-20211106194741490](操作系统.assets/image-20211106194741490.png)

### 什么是进程通信

![image-20211106195043462](操作系统.assets/image-20211106195043462.png)

### 进程通信--共享存储

![image-20211106195706405](操作系统.assets/image-20211106195706405.png)

### 进程通信---管道通信

![image-20211106200117267](操作系统.assets/image-20211106200117267.png)

### 进程通信--消息传递

![image-20211106200542414](操作系统.assets/image-20211106200542414.png)

### 总结

![image-20211106200952779](操作系统.assets/image-20211106200952779.png)

## 2.1.5 线程概念和多线程模型

### 知识总览

![image-20211106201055885](操作系统.assets/image-20211106201055885.png)

### 什么是线程，为什么要引入线程

![image-20211106201226674](操作系统.assets/image-20211106201226674.png)

![image-20211106201447085](操作系统.assets/image-20211106201447085.png)

![image-20211106201852026](操作系统.assets/image-20211106201852026.png)

### 引入线程机制后，有什么变化

![image-20211106202141469](操作系统.assets/image-20211106202141469.png)

### 线程的属性

![image-20211106202621171](操作系统.assets/image-20211106202621171.png)

### 线程的实现方式

 ![image-20211106203044610](操作系统.assets/image-20211106203044610.png)

![image-20211106203422983](操作系统.assets/image-20211106203422983.png)

![image-20211106203649397](操作系统.assets/image-20211106203649397.png)

### 多线程模型

**多对一**

![image-20211106204027363](操作系统.assets/image-20211106204027363.png)

**一对一**

![image-20211106204304811](操作系统.assets/image-20211106204304811.png)

**多对多**

![image-20211106204630934](操作系统.assets/image-20211106204630934.png)

### 总结

![image-20211106211316452](操作系统.assets/image-20211106211316452.png)·

## 2.2.1 处理机调度的概念和层次

### 知识总览

![image-20211107130109838](操作系统.assets/image-20211107130109838.png)

### 调度的基本概念

![image-20211107130330159](操作系统.assets/image-20211107130330159.png)

### 调度的三个层次

#### 高级调度

![image-20211107130733555](操作系统.assets/image-20211107130733555.png)

#### 中级调度

![image-20211107131153461](操作系统.assets/image-20211107131153461.png)

**补充知识**

 ![image-20211107131439465](操作系统.assets/image-20211107131439465.png)

#### 低级调度

![image-20211107131555624](操作系统.assets/image-20211107131555624.png)

#### 对比

![image-20211107131929191](操作系统.assets/image-20211107131929191.png)

### 总结

![image-20211107132045951](操作系统.assets/image-20211107132045951.png)

## 2.2.2 进程调度时机、切换与过程、方式

### 知识总览

![image-20211107132414394](操作系统.assets/image-20211107132414394.png)

### 进程调度的时机

![image-20211107132722600](操作系统.assets/image-20211107132722600.png)

![image-20211107133333709](操作系统.assets/image-20211107133333709.png)

### 进程调度的方式

![image-20211107133623456](操作系统.assets/image-20211107133623456.png)

### 进程的切换与过程

![image-20211107133946368](操作系统.assets/image-20211107133946368.png)

### 知识点回顾与重要考点

![image-20211107134107383](操作系统.assets/image-20211107134107383.png)

## 2.2.3 调度算法的评价指标

### 知识总览

![image-20211107134818310](操作系统.assets/image-20211107134818310.png)

### CPU 利用率

![image-20211107134947311](操作系统.assets/image-20211107134947311.png)

### 系统吞吐量

![image-20211107135036249](操作系统.assets/image-20211107135036249.png)

### 周转时间

![image-20211107135328081](操作系统.assets/image-20211107135328081.png)意思就是虽然都是这个时间完成这个任务但是感受不同，比如你等了10分钟上了1分钟的厕所，和别人等了1分钟上了10分钟的厕所体验感是不一样的。所以这个平均周转时间来衡量还不够完美

![image-20211107135630346](操作系统.assets/image-20211107135630346.png)

### 等待时间

![image-20211107135901651](操作系统.assets/image-20211107135901651.png)

### 响应时间

![image-20211107135937786](操作系统.assets/image-20211107135937786.png)

### 总结

![image-20211107135956660](操作系统.assets/image-20211107135956660.png)

## 2.2.4 调度算法（跳过）

## 2.2.5 调度算法（跳过）

## 2.3.1 进程同步、进程互斥

### 知识总览

![image-20211108163126174](操作系统.assets/image-20211108163126174.png)

### 什么是进程同步

![image-20211108163523439](操作系统.assets/image-20211108163523439.png)

![image-20211108163720654](操作系统.assets/image-20211108163720654.png)

总而言之，进程同步就是让会相互影响的异步的进程之间前后关系的一个协调定义。

### 什么是进程互斥

![image-20211108164038226](操作系统.assets/image-20211108164038226.png)

![image-20211108164758584](操作系统.assets/image-20211108164758584.png)

![image-20211108164924028](操作系统.assets/image-20211108164924028.png)

### 总结

![image-20211108164943030](操作系统.assets/image-20211108164943030.png)

## 2.3.2 进程互斥的软件实现方法（跳过）

### 总结

![image-20211108165555000](操作系统.assets/image-20211108165555000.png)

## 2.3.3 进程互斥的硬件实现方法（跳过）

## 2.3.4 信号量机制

### 总结

![image-20211108165828222](操作系统.assets/image-20211108165828222.png)

### 信号量机制

![image-20211108170148381](操作系统.assets/image-20211108170148381.png)

#### 整型信号量

![image-20211108170709589](操作系统.assets/image-20211108170709589.png)

#### 记录型信号量

![image-20211108171003934](操作系统.assets/image-20211108171003934.png)

![image-20211109151750720](操作系统.assets/image-20211109151750720.png)

![image-20211109151920128](操作系统.assets/image-20211109151920128.png)

### 总结

![image-20211109151943842](操作系统.assets/image-20211109151943842.png)

## 2.3.5 用信号量实现进程互斥、同步、前驱关系

### 信号量机制实现进程互斥

![image-20211109152333821](操作系统.assets/image-20211109152333821.png)

### 信号量机制实现进程同步

![image-20211109154628641](操作系统.assets/image-20211109154628641.png)

![image-20211109154931039](操作系统.assets/image-20211109154931039.png)

记住 前 p 后 v，让 p 去阻塞在后面的进程，v 去启动进程，反正不管是 p1 还是 p2 先执行，都会等到 p1 执行后

### 信号量机制实现前驱关系

![image-20211109155343513](操作系统.assets/image-20211109155343513.png)

S1 肯定是在 S2 执行之前执行，因为只有 v 了之后 p 才能继续执行下去

### 总结

![image-20211109155534170](操作系统.assets/image-20211109155534170.png)

## 2.3.6 生产者-消费问题

### 问题描述

![image-20211109161310860](操作系统.assets/image-20211109161310860.png)

### 问题分析

![image-20211109161804816](操作系统.assets/image-20211109161804816.png)

### 如何实现

![image-20211109162047510](操作系统.assets/image-20211109162047510.png)

### 能否改变相邻 p、v 操作的顺序

![image-20211109162330463](操作系统.assets/image-20211109162330463.png)

### 总结

![image-20211109162523325](操作系统.assets/image-20211109162523325.png)

## 2.3.7 多生产者-多消费者问题（跳过）

## 2.3.8 吸烟者问题（跳过）

## 2.3.9 读者-写者问题（跳过）

## 2.3.10 哲学家进餐问题（跳过）

## 2.3.11 管程

### 知识总览

![image-20211109162722773](操作系统.assets/image-20211109162722773.png)

### 为什么要引入管程

![image-20211109162831509](操作系统.assets/image-20211109162831509.png)

### 管程的定义和基本特征

![image-20211109163155983](操作系统.assets/image-20211109163155983.png)

个人理解：管程就好像是对一系列复杂操作进行了封装的函数，暴露出一些 api 供用户使用

### 用管程解决生产者消费者问题

![image-20211109163947900](操作系统.assets/image-20211109163947900.png)

![image-20211109164355251](操作系统.assets/image-20211109164355251.png)

### java 中类似管程的机制

![image-20211109164630517](操作系统.assets/image-20211109164630517.png)

### 总结

![image-20211109164749830](操作系统.assets/image-20211109164749830.png)

## 2.4.1 死锁的概念

### 知识总览

![image-20211109165003491](操作系统.assets/image-20211109165003491.png)

### 什么是死锁

![image-20211109165122429](操作系统.assets/image-20211109165122429.png)

![image-20211109165300873](操作系统.assets/image-20211109165300873.png)

### 死锁、饥饿、死循环的区别

![image-20211109165641064](操作系统.assets/image-20211109165641064.png)

### 死锁产生的必要条件

![image-20211109170010519](操作系统.assets/image-20211109170010519.png)

### 什么时候会发生死锁![image-20211109201518360](操作系统.assets/image-20211109201518360.png)

### 死锁的处理策略

![image-20211109201645139](操作系统.assets/image-20211109201645139.png)

### 总结

![image-20211109201714546](操作系统.assets/image-20211109201714546.png)

## 2.4.2 死锁的处理策略--预防死锁（跳过）

## 2.4.3 死锁的处理策略--避免死锁（跳过）

## 2.4.4 死锁的处理策略--检测和解决

![image-20211228121437864](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228121437864.png)

![image-20211228121945952](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228121945952.png)

tips：绿色线表示已占用（如 R1 类资源有两个被 p1 占用），蓝色表示请求资源

![image-20211228122624407](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228122624407.png)

tips：很显然只要让 p1 先执行完 p2 也就可以执行完，这个图是可以完全简化的

**图简化前：**

![image-20211228122541988](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228122541988.png)

**简化后若还存在边说明的死锁进程，接触方法有：**



## 考点1

### 1.理解进程控制块含义。进程控制块内容。理解进程的内存映像、进程上下文基本概念。

- 进程控制块含义

​	进程控制块（Processing Control Block），是[操作系统](https://baike.baidu.com/item/操作系统/192)[核心](https://baike.baidu.com/item/核心/33149)中一种数据结构，主要表示[进程](https://baike.baidu.com/item/进程)状态，是进程存在的唯一标志。

- 进程控制块内容

​	进程标识符：当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的 ID，用于区分不同的进程

​	处理机状态：当进程切换时需要把进程当前的运行情况记录下来保存在 PCB 中，如程序计数器的值表示当前程	序执行到那里

​	进程调度信息：记录当前资源分配清单：程序段指针，数据段指针，键盘，鼠标

​	进程控制信息：记录进程当前状态和进程的优先级

- 进程的内存映像

​	程序段、数据段、PCB 三部分组成了进程映像。一般情况下，我们把进程映像就简称为进程，例如，所谓创建	进程，实质上是创建进程映像中的 PCB，而撤销进程，实质上是撤销进程实体中的 PCB。

- 进程上下文

​	进程上下文一般在进程切换中提到：进程上下文实际上是进程执行活动全过程的静态描述。

### 2.理解进程、线程、程序的概念。他们之间区别与联系。

- 进程：进程是 cpu 资源分配的基本单位
- 线程：是进程的一个实体，是 CPU 调度资源的基本单位
- 程序：程序是文件，它是一系列代码的集合
- 区别与联系：线程可以理解成”轻量级“的进程，进程是资源分配的基本单位，而线程是资源调度的基本单位；进程是程序的一次执行，进程是暂时的，动态创建的，而程序是可保存的。

### 3.理解进程3 状态、5状态、7状态含义及相互转换条件。会画出相互转换关系图。

- 运行态：表示当前进程占有 CPU，并在 CPU 上运行
- 就绪态：已经具备运行条件（拥有处理机之外所有需要的资源），但由于没有空闲 CPU，而暂时不能运行
- 阻塞态：因等待某一事件而暂时不能运行，如等待操作系统分配打印机，等待读磁盘操作的结果。

![image-20211226215847613](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211226215847613.png)

### 4.了解作业调度算法。

- 优先数调度算法
  - 先来先服务调度算法（first come first served，FCFS）调度算法：按照作业进入系统的时间顺序排序
  - 最短作业优先（shortest job first，SJF）调度算法：优先处理计算时间短的作业有利于提高系统的吞吐率和平均周转率（对计算时间长的作业不公平，甚至会出现“饥饿”现象）
  - 最短剩余时间优先（shortest remaining time first，SRTF）调度算法：类似于 SJF 调度算法，其不公平特征比 SJF 调度算法更加突出，其不公平特征比 SJF 调度算法更加突出
  - 最高响应比优先（highest response ratio first，HRRF） 调度算法：响应比是等待时间与计算时间之比（这一算法能够改善 SJF 调度算法和 SRTF调度算法对计算时间长的作业/进程极端不公平的问题）
- 时间片轮询算法：基于先来先服务算法，但是每个进程占有 CPU 运行必须受到时间片的限制，一旦进程运行时间超过了该时间片就得让出 CPU
- 分级调度算法：建立多个按照优先级调度的就绪进程队列。一般来说，高优先级就绪进程分配的时间片短，而每个就绪进程队列的优先数和时间片一般相同
- 彩票调度算法：根据概率进行调度，操作系统为进程发放一定数量的彩票，当调度进程需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源

## 考点2

### 1.理解进程通信概念及常用进程通信方式

概念：进程通信指进程之间的信息交换

常用的进程通信方式有：

- 共享存储：设置一个共享空间，注意进程间要互斥地访问，有基于数据结构（低级，能存储的数据量少）和基于存储区（高级，能存储的数据量多）两种共享方式
- 管道通信：设置一个特殊的共享文件（管道），其实就是一个缓冲区（一个管道只能实现半双工通信，实现双向同时通信要建立两个管道，各进程要互斥访问管道，写满时，不能再写。读空时，不能再读。没写满，不能读，没读空，不能写）
- 消息传递：通过系统提供“发送/接受源语”传递结构化的消息（消息头/消息体），有两种实现方式，第一种是直接通信方式（消息直接挂到接收方的消息队列里）第二种是间接（信箱）通信方式（消息先发到中间体（信箱））

### 2.理解临界区概念及几种临界区管理方法。

概念：并发进程中与互斥变量有关的程序段称为“临界区”。

管理方法：

- 关中断

  - 进程在进入临界区之前关中断，退出临界区时开中断，关中断期间，由于进程上下文切换都是由中断事件引起的，因此进程的执行不会被打断，不会切换线程，保证了临界区的互斥执行。

  - 关中断缺点：限制交叉执行程序的能力，关中断方法不适合多CPU系统，关中断权利赋予给用户十分危险

- 测试并建立指令
  - 用户程序可以利用 TS 指令实现临界区的上锁和开锁操作。在进入临界区之前，首先通过 TS 指令测试 lock，如果没有进程在临界区内则可以进入，否则必须循环测试直接 lock 值为 false；当进程退出临界区时，将 lock 值置为 false（由于 TS 指令是不可分割指令，在测试和形成条件码之间不可能有其他进程测试变量值，从而确保临界区管理的正确性）。
  - ![image-20211228105942547](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228105942547.png)
  - ![image-20211228105951377](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228105951377.png)

### 3.会用信号量，PV操作解决缓冲区、多进程运行同步等问题

![image-20211228112239326](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228112239326.png)

### 4.理解死锁概念、理解银行家算法、安全性检测算法并能解决实际问题。

死锁概念：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。

产生死锁的四个必要条件：

- 互斥条件：进程应互斥使用资源
- 占有和等待条件：等待时，不释放已占有的资源
- 不剥夺条件：不能从另一进程抢夺资源，资源只能被占有进程自己释放
- 循环等待条件：存在一个循环等待链，其中，每一个进程分别等待它前一个进程所占有的资源，造成永久等待

银行家算法：检查资源申请者对各类资源的最大需求量，如果系统现存的各类资源可以满足它的最大需求量时，就满足当前的申请。这样申请者进程就不会因为某类资源得不到满足而处于永远等待状态，即死锁问题。

安全性检测算法：构造资源分配图，对于可完全简化的图说明不存在死锁，若不可完全简化的图说明存在死锁

![image-20211228210513473](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211228210513473.png)

tips:在这个图的基础上加一条 p1 调度 P2 的图就是无法简化的图了

解决方法：

- 结束所有进程的执行，并重新启动操作系统（方法简单，但之前工作会全部作废，损失很大）
- 撤销陷于死锁的所有进程，接触死锁，重新启动执行（代价也相当大）
- 在进程执行过程中定时设置校验点，从校验点开始重执行，让所有进程回退，直到足以解除死锁（这种措施要求系统建立并保存校验点，支持回退及重启机制）
- 中止一个卷入死锁的进程，以后再重新执行





# 第三章 内存

## 3.1.1 内存的基础知识

### 知识总览

![image-20211109202021928](操作系统.assets/image-20211109202021928.png)

### 什么是内存？有何作用？

![image-20211109202323265](操作系统.assets/image-20211109202323265.png)

### 几个常用的数量单位

![image-20211109202442198](操作系统.assets/image-20211109202442198.png)

### 进程的运行原理-指令

![image-20211109202716637](操作系统.assets/image-20211109202716637.png)

### 逻辑地址 vs 物理地址

![image-20211109202912516](操作系统.assets/image-20211109202912516.png)

### 从写程序到程序运行过程分析

![image-20211109203031416](操作系统.assets/image-20211109203031416.png)

### 逻辑地址转换为绝对地址

#### 绝对装入

![image-20211109203329173](操作系统.assets/image-20211109203329173.png)

#### 静态重定位

![image-20211109203439071](操作系统.assets/image-20211109203439071.png)

#### 动态重定位

tips：现在的计算机大多采用这种方法

![image-20211109203635748](操作系统.assets/image-20211109203635748.png)

### 链接的三种方式

![image-20211109203819829](操作系统.assets/image-20211109203819829.png)

### 总结

![image-20211109203942121](操作系统.assets/image-20211109203942121.png)

## 3.1.2 内存管理的概念

### 内存空间的分配与回收

![image-20211110193140230](操作系统.assets/image-20211110193140230.png)

### 内存空间的扩展

![image-20211110193257887](操作系统.assets/image-20211110193257887.png)

### 地址转换

![image-20211110193522965](操作系统.assets/image-20211110193522965.png)

### 内存保护

![image-20211110193842106](操作系统.assets/image-20211110193842106.png)

![image-20211110194147760](操作系统.assets/image-20211110194147760.png)

### 总结

![image-20211110194410842](操作系统.assets/image-20211110194410842.png)

## 3.1.3 覆盖与交换

### 知识总览

![image-20211110194459629](操作系统.assets/image-20211110194459629.png)

### 覆盖技术

![image-20211110194716333](操作系统.assets/image-20211110194716333.png)

![image-20211110195047790](操作系统.assets/image-20211110195047790.png)

### 交换技术

![image-20211110200433906](操作系统.assets/image-20211110200433906.png)

**挂起状态回顾**

![image-20211110200547739](操作系统.assets/image-20211110200547739.png)

![image-20211110201110078](操作系统.assets/image-20211110201110078.png)

### 知识回顾与重要考点

![image-20211110201226122](操作系统.assets/image-20211110201226122.png)

## 3.1.4 连续分配管理方式

### 知识总览

![image-20211110201334224](操作系统.assets/image-20211110201334224.png)

### 单一连续分配

![image-20211110201632155](操作系统.assets/image-20211110201632155.png)

### 固定分区分配

![image-20211110201942153](操作系统.assets/image-20211110201942153.png)

![image-20211110202223966](操作系统.assets/image-20211110202223966.png)

### 动态分区分配

![image-20211110203217747](操作系统.assets/image-20211110203217747.png)

![image-20211110203343386](操作系统.assets/image-20211110203343386.png)

![image-20211110203500976](操作系统.assets/image-20211110203500976.png)

![image-20211110203711107](操作系统.assets/image-20211110203711107.png)

![image-20211110203842077](操作系统.assets/image-20211110203842077.png)

![image-20211110204055672](操作系统.assets/image-20211110204055672.png)

![image-20211110204238448](操作系统.assets/image-20211110204238448.png)

![image-20211110204640015](操作系统.assets/image-20211110204640015.png)

### 总结

![image-20211110204813674](操作系统.assets/image-20211110204813674.png)

## 3.1.5 动态分区分配计算法（跳过）

## 3.1.6 基本分页存储管理的基本概念

### 问题

![image-20211111204221258](操作系统.assets/image-20211111204221258.png)

### 知识总览

![image-20211111204053839](操作系统.assets/image-20211111204053839.png)

### 思路

![image-20211111204448214](操作系统.assets/image-20211111204448214.png)

### 分页存储管理的基本概念

![image-20211111204727404](操作系统.assets/image-20211111204727404.png)

### 思考

![image-20211111204933165](操作系统.assets/image-20211111204933165.png)

### 如何实现地址的转换

![image-20211111205245866](操作系统.assets/image-20211111205245866.png)

![image-20211111205407731](操作系统.assets/image-20211111205407731.png)

![image-20211111205728774](操作系统.assets/image-20211111205728774.png)

![image-20211111205954541](操作系统.assets/image-20211111205954541.png)

### 逻辑地址结构

![image-20211111210140922](操作系统.assets/image-20211111210140922.png)

### 页表

![image-20211111210352047](操作系统.assets/image-20211111210352047.png)

![image-20211111210904252](操作系统.assets/image-20211111210904252.png)

### 知识回顾

![image-20211111211109312](操作系统.assets/image-20211111211109312.png)

## 3.1.7 基本地址变换机构

### 知识总览

![image-20211113104940135](操作系统.assets/image-20211113104940135.png)

### 基本地址变换机构

![image-20211113105220425](操作系统.assets/image-20211113105220425.png)

**图示**

![image-20211113105602380](操作系统.assets/image-20211113105602380.png)

### 例题说明

![image-20211113110029618](操作系统.assets/image-20211113110029618.png)

![image-20211113110043707](操作系统.assets/image-20211113110043707.png)

### 例题

![image-20211113110607709](操作系统.assets/image-20211113110607709.png)

### 对页表项大小的进一步探讨（难重点）

![image-20211113111848377](操作系统.assets/image-20211113111848377.png)

### 知识回顾与考点

![image-20211113112042174](操作系统.assets/image-20211113112042174.png)

## 3.1.8 具有快表的地址变换机构

### 知识总览

![image-20211113113356942](操作系统.assets/image-20211113113356942.png)

### 局部性原理

![image-20211113113737233](操作系统.assets/image-20211113113737233.png)

### 什么是快表

![image-20211113113828495](操作系统.assets/image-20211113113828495.png)

![image-20211113114145247](操作系统.assets/image-20211113114145247.png)

### 引入快表后，地址的变换过程

![image-20211113114536016](操作系统.assets/image-20211113114536016.png)

### 总结

![image-20211113114703805](操作系统.assets/image-20211113114703805.png)

tips：就比如你做一个循环，其实访问的地址基本都是同一个页号内的，所以快表机制可以减少我们从页表查询页号的时间（循环第一次的时候就将页号存到快表中，之后就不用再查询页/慢表了）

## 3.1.9 两级页表

### 知识总览

![image-20211113114903342](操作系统.assets/image-20211113114903342.png)

### 单级页表存在问题

![image-20211113115418944](操作系统.assets/image-20211113115418944.png)

![image-20211113115836068](操作系统.assets/image-20211113115836068.png)

### 如何解决单机页表的问题

![image-20211113120029240](操作系统.assets/image-20211113120029240.png)

### 两级页表的原理、地址结构

![image-20211113120209595](操作系统.assets/image-20211113120209595.png)

![image-20211113120518017](操作系统.assets/image-20211113120518017.png)

### 如何实现地址变换

![image-20211113120656296](操作系统.assets/image-20211113120656296.png)

### 如何解决单级页表的问题

![image-20211113120825662](操作系统.assets/image-20211113120825662.png)

### 需要注意的几个细节

![image-20211113121212685](操作系统.assets/image-20211113121212685.png)

### 知识回顾与重点考点

![image-20211113121337758](操作系统.assets/image-20211113121337758.png)

## 3.1.10 基本分段存储管理方式

### 知识总览

![image-20211113205329329](操作系统.assets/image-20211113205329329.png)

### 分段

![image-20211113205727140](操作系统.assets/image-20211113205727140.png)

![image-20211113205943389](操作系统.assets/image-20211113205943389.png)

### 段表

![image-20211113210447749](操作系统.assets/image-20211113210447749.png)

### 地址变换

![image-20211113210621183](操作系统.assets/image-20211113210621183.png)

![image-20211113211044649](操作系统.assets/image-20211113211044649.png)

**由于段内地址 1024 = 1k 小于 3K 说明段内地址并没有超过**

### 分段、分页管理的对比

![image-20211113211540260](操作系统.assets/image-20211113211540260.png)

![image-20211113211802506](操作系统.assets/image-20211113211802506.png)

![image-20211113212038252](操作系统.assets/image-20211113212038252.png)

![image-20211113212158559](操作系统.assets/image-20211113212158559.png)

### 知识回顾与重要考点

![image-20211113212341474](操作系统.assets/image-20211113212341474.png)

## 3.1.11 段页式管理方式

### 知识总览

![image-20211113212525821](操作系统.assets/image-20211113212525821.png)

### 分页、分段的优缺点分析

![image-20211113212751218](操作系统.assets/image-20211113212751218.png)

### 段页式管理

![image-20211113212845256](操作系统.assets/image-20211113212845256.png)

### 段页式管理的逻辑地址结构

![image-20211113213222473](操作系统.assets/image-20211113213222473.png)

### 段表、页表

![image-20211113213450612](操作系统.assets/image-20211113213450612.png)

### 寻址过程

![image-20211113214004651](操作系统.assets/image-20211113214004651.png)

![image-20211113214225603](操作系统.assets/image-20211113214225603.png)

## 3.2.1 虚拟内存的基本概念

### 知识总览

![image-20211113214458360](操作系统.assets/image-20211113214458360.png)

![image-20211113214625198](操作系统.assets/image-20211113214625198.png)

### 传统管理方式的特征

![image-20211113214917969](操作系统.assets/image-20211113214917969.png)

### 局部性原理

![image-20211113220550979](操作系统.assets/image-20211113220550979.png)

### 虚拟内存的定义和特征

![image-20211113220805166](操作系统.assets/image-20211113220805166.png)

![image-20211113221154513](操作系统.assets/image-20211113221154513.png)

### 如何实现虚拟内存技术

![image-20211113221432240](操作系统.assets/image-20211113221432240.png)

### 总结

![image-20211113221606183](操作系统.assets/image-20211113221606183.png)

## 3.2.2 请求分页管理方式

### 知识总览

![image-20211113221913201](操作系统.assets/image-20211113221913201.png)

### 页表机制

![image-20211113222212102](操作系统.assets/image-20211113222212102.png)

### 缺页中断机构

![image-20211113222554582](操作系统.assets/image-20211113222554582.png)

![image-20211113222729480](操作系统.assets/image-20211113222729480.png)

### 地址变换机构

![image-20211113222921315](操作系统.assets/image-20211113222921315.png)

![image-20211113223049535](操作系统.assets/image-20211113223049535.png)

![image-20211113223100773](操作系统.assets/image-20211113223100773.png)

![image-20211113223346163](操作系统.assets/image-20211113223346163.png)

![image-20211113223429466](操作系统.assets/image-20211113223429466.png)

### 总结

![image-20211113223646597](操作系统.assets/image-20211113223646597.png)

## 3.2.3 页面置换算法（跳过）

## 3.2.4 页面分配策略（跳过）

## 考点

### 1.理解存储管理基本功能。

(1)内存分配和去配；

(2)地址映射：将逻辑地址变换成物理地址，抽象成一维数组或二维地址空间；

(3) 存储共享和存储保护，其中存储保护为各道作业、任务或进程在自己所属区域中运行，不破坏别的作业或不被“别人”破坏，更不要破坏整个系统工作; 存储共享是为了进程间通信和提高主存利用率，两个或多个进程共用内存中相同的分区，即他们的物理内存有相交部分; 

(4)存储扩充：虚拟内存，允许进程虚拟地址空间大于主存空间。

### 2.理解并会使用可变存储分区管理常用算法。

可变分区管理的基本原理：系统在作业装入主存执行之前并不建立分区，当要装入一个作业时，再根据作业需要的主存量查看主存中是否有足够的空间。若有，则按需要量分割一个分区分配给该作业；若无，则令该作业等待主存空间。

五种可变分区**分配算法**实现原理。

（1）最先适应分配算法：空闲区表中的空闲区可按首地址从小到大顺序排列，在进行内存分配时，从头开始顺序查找，直到找到一块分区的大小可以满足需求

（2）下次适应分配算法：分配内存时不是从头进行查找可以分配内存的空闲分区，而是从上一次分配内存的空闲分区的下一个分区开始查找，直到找到可以为该进程分配内存的空闲分区；

（3) 最优适应分配算法：空闲区表中的空闲区可按空闲块从小到大顺序排列，在进行内存分配时，从头开始顺序查找，直到找到一块分区的大小可以满足需求

（4）最坏适应分配算法：空闲区表中的空闲区可按空闲块从大到小顺序排列，在进行内存分配时，从头开始顺序查找，直到找到一块分区的大小可以满足需求

（5) 快速适应分配算法 ：为经常用到的长度的空闲区设置单独的链表，在内存分配时，优先查找该链表



### 3.请求页式虚拟存储管理的常用的页面调度算法。

- 先进先调度算法

​	**先进先出调度算法根据页面进入内存的时间先后选择淘汰页面，先进入内存的页面先淘汰，后进入内存的后淘	汰。**本算法实现时需要将页面按进入内存的时间先后组成一个队列，每次调度队首页面予以淘汰。

- 最近最少调度算法

​	先进先出调度算法没有考虑页面的使用情况，大多数情况下性能不佳。根据程序执行的局部性特点，程序一旦	访问了某些代码和数据，则在一段时间内会经常访问他们，因此**最近最少用调度在选择淘汰页面时会考虑页面	最近的使用，总是选择在最近一段时间以来最少使用的页面予以淘汰。**算法实现时需要为每个页面设置数据结	构记录页面自上次访问以来所经历的时间。

- 最近最不常用调度算法

​	由于程序设计中经常使用循环结构，根据程序执行的局部性特点，可以设想在一段时间内经常被访问的代码和	数据在将来也会经常被访问，显然这样的页面不应该被淘汰。**最近最不常用调度算法总是根据一段时间内页面	的访问次数来选择淘汰页面，每次淘汰访问次数最少的页面。**算法实现时需要为每个页面设置计数器，记录访	问次数。计数器由硬件或操作系统自动定时清零。

# 第四章 文件管理

## 4.1.1 初始文件管理

![image-20211114152857709](操作系统.assets/image-20211114152857709.png)

### 文件的属性

![image-20211114153352107](操作系统.assets/image-20211114153352107.png)

### 文件内部数据的组织形式

![image-20211114153511132](操作系统.assets/image-20211114153511132.png)

![image-20211114153536985](操作系统.assets/image-20211114153536985.png)

![image-20211114153731124](操作系统.assets/image-20211114153731124.png)

### 操作系统应该提供的功能

![image-20211114154005957](操作系统.assets/image-20211114154005957.png)

![image-20211114154122662](操作系统.assets/image-20211114154122662.png)

### 文件如何存放在外存

![image-20211114154436757](操作系统.assets/image-20211114154436757.png)

![image-20211114154543250](操作系统.assets/image-20211114154543250.png)

### 其他需要操作系统实现的文件管理功能

![image-20211114154627088](操作系统.assets/image-20211114154627088.png)

### 总结

![image-20211114154808958](操作系统.assets/image-20211114154808958.png)

## 4.1.2 文件的逻辑结构

### 知识总览

![image-20211114155108496](操作系统.assets/image-20211114155108496.png)

### 有结构文件

![image-20211114155435206](操作系统.assets/image-20211114155435206.png)

### 有结构文件的逻辑结构

![image-20211114155536804](操作系统.assets/image-20211114155536804.png)

### 顺序文件

![image-20211114155807470](操作系统.assets/image-20211114155807470.png)

![image-20211114160602744](操作系统.assets/image-20211114160602744.png)

### 索引文件

![image-20211114160857347](操作系统.assets/image-20211114160857347.png)

### 索引顺序文件

![image-20211114161157035](操作系统.assets/image-20211114161157035.png)

#### 检索效率分析

![image-20211114161429416](操作系统.assets/image-20211114161429416.png)

#### 多级索引顺序文件

![image-20211114161632754](操作系统.assets/image-20211114161632754.png)

### 总结

![image-20211114162022858](操作系统.assets/image-20211114162022858.png)

## 4.1.3 文件的目录

### 知识总览

![image-20211114162313370](操作系统.assets/image-20211114162313370.png)

### 文件控制块

![image-20211114163900042](操作系统.assets/image-20211114163900042.png)

![image-20211114164101624](操作系统.assets/image-20211114164101624.png)

### 目录结构

#### 单级目录结构

![image-20211114164237039](操作系统.assets/image-20211114164237039.png)

#### 两级目录结构

![image-20211114164441287](操作系统.assets/image-20211114164441287.png)

#### 多级目录结构

![image-20211114164739150](操作系统.assets/image-20211114164739150.png)

![image-20211114164851663](操作系统.assets/image-20211114164851663.png)

![image-20211114164949045](操作系统.assets/image-20211114164949045.png)

#### 无环图目录结构

![image-20211114165309291](操作系统.assets/image-20211114165309291.png)

#### 索引结点（FCB的改进）

![image-20211114165826544](操作系统.assets/image-20211114165826544.png)

![image-20211114165925081](操作系统.assets/image-20211114165925081.png)

### 知识总结

![image-20211114170047833](操作系统.assets/image-20211114170047833.png)

## 4.1.4 文件的物理结构（上）

### 知识总览

![image-20211114170212266](操作系统.assets/image-20211114170212266.png)

![image-20211114170252169](操作系统.assets/image-20211114170252169.png)

### 文件块、磁盘块

![image-20211114170435159](操作系统.assets/image-20211114170435159.png)

![image-20211114170618452](操作系统.assets/image-20211114170618452.png)

### 文件分配方式

#### 连续分配

**优点**

![image-20211114171029060](操作系统.assets/image-20211114171029060.png)

![image-20211114171230771](操作系统.assets/image-20211114171230771.png)

**缺点**

![image-20211114171332529](操作系统.assets/image-20211114171332529.png)

![image-20211114171456641](操作系统.assets/image-20211114171456641.png)

**总结**

![image-20211114171526426](操作系统.assets/image-20211114171526426.png)

#### 链接分配

![image-20211114171557553](操作系统.assets/image-20211114171557553.png)

##### 隐式链接

![image-20211114171800379](操作系统.assets/image-20211114171800379.png)

![image-20211114171913375](操作系统.assets/image-20211114171913375.png)

![image-20211114171947581](操作系统.assets/image-20211114171947581.png)

##### 显示链接

![image-20211114172300615](操作系统.assets/image-20211114172300615.png)

![



](操作系统.assets/image-20211114172450487.png)

##### 链接分配总结

![image-20211114172616354](操作系统.assets/image-20211114172616354.png)

## 4.1.4 文件的物理结构（下）

![image-20211114172730547](操作系统.assets/image-20211114172730547.png)

### 索引分配

![image-20211227211718072](C:\Users\Mobvista\Desktop\the-way-to-study\01_课内笔记\操作系统.assets\image-20211227211718072.png)

## 4.1.5 文件存储空间管理

### 知识总览

![image-20211114173344267](操作系统.assets/image-20211114173344267.png)

### 存储空间的划分与初始化

![image-20211114173551774](操作系统.assets/image-20211114173551774.png)

### 存储空间管理方法

#### 空闲表法

![image-20211114174038606](操作系统.assets/image-20211114174038606.png)

#### 空闲链表法

![image-20211114174219562](操作系统.assets/image-20211114174219562.png)

![image-20211114174350161](操作系统.assets/image-20211114174350161.png)

![image-20211114174620712](操作系统.assets/image-20211114174620712.png)

#### 位示图法

![image-20211114174925922](操作系统.assets/image-20211114174925922.png)

![image-20211114175056203](操作系统.assets/image-20211114175056203.png)

#### 成组链接法

![image-20211114175149500](操作系统.assets/image-20211114175149500.png)

![image-20211114175347912](操作系统.assets/image-20211114175347912.png)

#### 总结

![image-20211114175506238](操作系统.assets/image-20211114175506238.png)

## 4.1.6 文件的基本操作

### 知识总览

![image-20211116154218648](操作系统.assets/image-20211116154218648.png)

### 创建文件

![image-20211116154452541](操作系统.assets/image-20211116154452541.png)

### 删除文件

![image-20211116154617070](操作系统.assets/image-20211116154617070.png)

### 打开文件

![image-20211116154820005](操作系统.assets/image-20211116154820005.png)

### 关闭文件

![image-20211116155153322](操作系统.assets/image-20211116155153322.png)

### 读文件

![image-20211116155317903](操作系统.assets/image-20211116155317903.png)

### 写文件

![image-20211116155429939](操作系统.assets/image-20211116155429939.png)

### 知识总结

![image-20211116160319613](操作系统.assets/image-20211116160319613.png)

## 4.1.7 文件共享

### 知识总览

![image-20211116161905650](操作系统.assets/image-20211116161905650.png)

### 基于索引结点的共享方式（硬链接）

![image-20211116162133287](操作系统.assets/image-20211116162133287.png)

### 基于符号链的共享方式（软链接）

![image-20211116162330672](操作系统.assets/image-20211116162330672.png)

![image-20211116162434634](操作系统.assets/image-20211116162434634.png)

![image-20211116162602479](操作系统.assets/image-20211116162602479.png)

### 知识总结

![image-20211116162716524](操作系统.assets/image-20211116162716524.png)

## 4.1.8 文件保护

### 口令保护

![image-20211116162928789](操作系统.assets/image-20211116162928789.png)

### 加密保护

![image-20211116163336563](操作系统.assets/image-20211116163336563.png)

### 访问控制

![image-20211116163513158](操作系统.assets/image-20211116163513158.png)

![image-20211116163626550](操作系统.assets/image-20211116163626550.png)

### Window 的访问控制

![image-20211116163722020](操作系统.assets/image-20211116163722020.png)

![image-20211116163824429](操作系统.assets/image-20211116163824429.png)

![image-20211116163837560](操作系统.assets/image-20211116163837560.png)

![image-20211116163855392](操作系统.assets/image-20211116163855392.png)

![image-20211116163921183](操作系统.assets/image-20211116163921183.png)

### 知识总结

![image-20211116164055691](操作系统.assets/image-20211116164055691.png)

## 4.1.9 文件系统的层次结构

### 文件的层次结构

![image-20211116165114511](操作系统.assets/image-20211116165114511.png)

### 知识点回顾与重要考点

![image-20211116165327088](操作系统.assets/image-20211116165327088.png)

## 4.2.1 磁盘的结构

### 知识总览

![image-20211116165437406](操作系统.assets/image-20211116165437406.png)

### 磁盘、磁道、扇区

![image-20211116165614525](操作系统.assets/image-20211116165614525.png)

### 如何在磁盘中读/写数据

![image-20211116165735391](操作系统.assets/image-20211116165735391.png)

### 盘面、柱面

![image-20211116170026221](操作系统.assets/image-20211116170026221.png)

### 磁盘的物理地址

![image-20211116165949087](操作系统.assets/image-20211116165949087.png)

### 磁盘的分类

![image-20211116170128177](操作系统.assets/image-20211116170128177.png)

![image-20211116170158062](操作系统.assets/image-20211116170158062.png)

### 知识点回顾与重要考点 

![image-20211116170300600](操作系统.assets/image-20211116170300600.png)

## 4.2.2 磁盘调度算法

### 知识总览

![image-20211116170806411](操作系统.assets/image-20211116170806411.png)

### 一次磁盘读/写需要的时间

![image-20211116171655625](操作系统.assets/image-20211116171655625.png)

### 先来先服务算法（FCFS）

![image-20211116171847095](操作系统.assets/image-20211116171847095.png)

### 最短寻找时间优先（SSTF）

![image-20211116172126402](操作系统.assets/image-20211116172126402.png)

### 扫描算法（SCAN）

![image-20211116172428475](操作系统.assets/image-20211116172428475.png)

### LOOK 调度算法

![image-20211116172542252](操作系统.assets/image-20211116172542252.png)

### 循环扫描算法（C-SCAN）

![image-20211116172821407](操作系统.assets/image-20211116172821407.png)

### C-LOOK 调度算法

![image-20211116172919480](操作系统.assets/image-20211116172919480.png)

### 知识总结

![image-20211116173028166](操作系统.assets/image-20211116173028166.png)

## 4.2.3 减少磁盘延迟时间的方法

![image-20211117190816805](操作系统.assets/image-20211117190816805.png)

### 交替编号

![image-20211117191017527](操作系统.assets/image-20211117191017527.png)

### 磁盘地址结构的设计

![image-20211117191233855](操作系统.assets/image-20211117191233855.png)

![image-20211117191411574](操作系统.assets/image-20211117191411574.png)

![image-20211117191430992](操作系统.assets/image-20211117191430992.png)

### 错位命名

![image-20211117191802863](操作系统.assets/image-20211117191802863.png)

### 总结

![image-20211117191849393](操作系统.assets/image-20211117191849393.png)

## 4.2.4 磁盘管理

### 知识总览

![image-20211117191916859](操作系统.assets/image-20211117191916859.png)

### 磁盘初始化

![image-20211117192122413](操作系统.assets/image-20211117192122413.png)

### 引导块

![image-20211117192259127](操作系统.assets/image-20211117192259127.png)

![image-20211117192430346](操作系统.assets/image-20211117192430346.png)

### 坏块的管理

![image-20211117192640543](操作系统.assets/image-20211117192640543.png)

### 总结

![image-20211117192716996](操作系统.assets/image-20211117192716996.png)

## 考点

### 1.理解文件的物理结构

### 2.理解文件的逻辑结构

逻辑文件：从用户观点看逻辑文件是用户所观察到的文件组织形式，是用户可以直接处理的数据及结构，它独立于物理设备，逻辑文件又称为文件组织。

物理文件是与存储介质性能有关的，在外存上存储的组织形式。

 （1）文件的逻辑结构分类：流式文件、记录式文件。

 （2）文件的物理结构分类：顺序文件、连接文件、索引文件。



# 第五章 设备管理

## 5.1.1 I-O 设备的概念和分类

### 知识总览

![image-20211117192818573](操作系统.assets/image-20211117192818573.png)

### 什么是 I/O 设备

![image-20211117192953481](操作系统.assets/image-20211117192953481.png)

![image-20211117193114068](操作系统.assets/image-20211117193114068.png)

### I/O 设备的分类

#### 按使用特性

![image-20211117193203418](操作系统.assets/image-20211117193203418.png)

#### 按传输速率分类

![image-20211117193245650](操作系统.assets/image-20211117193245650.png)

#### 按信息交换的单位分类

![image-20211117193334070](操作系统.assets/image-20211117193334070.png)

### 总结

![image-20211117193426992](操作系统.assets/image-20211117193426992.png)

## 5.1.2 I/O 控制器

### 知识总览

![image-20211117194812897](操作系统.assets/image-20211117194812897.png)

### I/O 设备的机械部件

![image-20211117194855811](操作系统.assets/image-20211117194855811.png)

### I/O 设备的电子部件（I/O控制器）

![image-20211117195237243](操作系统.assets/image-20211117195237243.png)

### I/O 控制器的组成 

![image-20211117195607206](操作系统.assets/image-20211117195607206.png)

![image-20211117195706271](操作系统.assets/image-20211117195706271.png)

### 内存映像 I/O v.s. 寄存器独立编址

![image-20211117195929265](操作系统.assets/image-20211117195929265.png)

### 总结

![image-20211117200047574](操作系统.assets/image-20211117200047574.png)

## 5.1.3 I/O 控制方式

### 知识总览

![image-20211117200145507](操作系统.assets/image-20211117200145507.png)

### 程序直接控制方式

![image-20211117200432645](操作系统.assets/image-20211117200432645.png)

![image-20211117200733023](操作系统.assets/image-20211117200733023.png)

![image-20211117200908300](操作系统.assets/image-20211117200908300.png)

### 中断驱动方式

![image-20211117201100146](操作系统.assets/image-20211117201100146.png)

![image-20211117201251367](操作系统.assets/image-20211117201251367.png)

### DMA 方式

![image-20211117201437929](操作系统.assets/image-20211117201437929.png)

**DMA 控制器**

![image-20211117201722186](操作系统.assets/image-20211117201722186.png)

![image-20211117201921124](操作系统.assets/image-20211117201921124.png)

### 通道控制方式

![image-20211117202118781](操作系统.assets/image-20211117202118781.png)

![image-20211117202243083](操作系统.assets/image-20211117202243083.png)

### 总结

![image-20211117202513207](操作系统.assets/image-20211117202513207.png)

## 5.1.4 I/O 软件层次结构

### 知识总览

![image-20211117205801633](操作系统.assets/image-20211117205801633.png)

### 用户层软件

![image-20211117205955268](操作系统.assets/image-20211117205955268.png)

### 设备独立性软件

![image-20211117210317456](操作系统.assets/image-20211117210317456.png)

![image-20211117210536394](操作系统.assets/image-20211117210536394.png)

### 设备驱动程序

![image-20211117210719635](操作系统.assets/image-20211117210719635.png)

![image-20211117210816040](操作系统.assets/image-20211117210816040.png)

### 中断处理程序

![image-20211117210928794](操作系统.assets/image-20211117210928794.png)

### 总结

![image-20211117211016082](操作系统.assets/image-20211117211016082.png)

## 5.1.5 I-O 设备子系统

### 知识总览

![image-20211118192054298](操作系统.assets/image-20211118192054298.png)

![image-20211118192221858](操作系统.assets/image-20211118192221858.png)

### I/O 调度

![image-20211118192335520](操作系统.assets/image-20211118192335520.png)

### 设备保护

![image-20211118200734095](操作系统.assets/image-20211118200734095.png)

## 5.1.6 假脱机技术

### 知识总览

![image-20211118200922705](操作系统.assets/image-20211118200922705.png)

### 什么是脱机技术

![image-20211118201033768](操作系统.assets/image-20211118201033768.png)

![image-20211118201313332](操作系统.assets/image-20211118201313332.png)

### 输入井输出井

![image-20211118201443645](操作系统.assets/image-20211118201443645.png)

![image-20211118201552480](操作系统.assets/image-20211118201552480.png)

![image-20211118201649973](操作系统.assets/image-20211118201649973.png)

![image-20211118201853533](操作系统.assets/image-20211118201853533.png)

### 共享打印机原理分析

![image-20211118202059452](操作系统.assets/image-20211118202059452.png)

![image-20211118202423173](操作系统.assets/image-20211118202423173.png)

![image-20211118202513395](操作系统.assets/image-20211118202513395.png)

### 总结

![image-20211118202658030](操作系统.assets/image-20211118202658030.png)

## 5.1.7 设备的分配与回收

### 知识总览

![image-20211118202826251](操作系统.assets/image-20211118202826251.png)

### 设备分配时应考虑的因素

![image-20211118203142648](操作系统.assets/image-20211118203142648.png)

![image-20211118203422363](操作系统.assets/image-20211118203422363.png)

### 静态分配和动态分配

![image-20211118203527730](操作系统.assets/image-20211118203527730.png)

### 设备分配管理中的数据结构

![image-20211118203700119](操作系统.assets/image-20211118203700119.png)

![image-20211118203935960](操作系统.assets/image-20211118203935960.png)

![image-20211118204033866](操作系统.assets/image-20211118204033866.png)

![image-20211118204124346](操作系统.assets/image-20211118204124346.png)

![image-20211118204242095](操作系统.assets/image-20211118204242095.png)

### 设备分配步骤

![image-20211118204452931](操作系统.assets/image-20211118204452931.png)

![image-20211118204656077](操作系统.assets/image-20211118204656077.png)

![image-20211118204854866](操作系统.assets/image-20211118204854866.png)

### 总结

![image-20211118205050984](操作系统.assets/image-20211118205050984.png)

## 5.1.8 缓冲区管理

### 缓冲区的作用

![image-20211118205244953](操作系统.assets/image-20211118205244953.png)

![image-20211118205442136](操作系统.assets/image-20211118205442136.png)

### 单缓冲

![image-20211118205806964](操作系统.assets/image-20211118205806964.png)

![image-20211118210203097](操作系统.assets/image-20211118210203097.png)

### 双缓冲

![image-20211118210418869](操作系统.assets/image-20211118210418869.png)

![image-20211118210632525](操作系统.assets/image-20211118210632525.png)

### 使用单/双缓冲在通信时的区别

![image-20211118210750493](操作系统.assets/image-20211118210750493.png)

![image-20211118210923581](操作系统.assets/image-20211118210923581.png)

### 循环缓冲区

![image-20211118211058997](操作系统.assets/image-20211118211058997.png)

### 缓冲池

![image-20211118211304942](操作系统.assets/image-20211118211304942.png)

### 知识总览

![image-20211118211401204](操作系统.assets/image-20211118211401204.png)

## 考点

### 1.理解计算机 I/O 系统构成及其各部分功能（还没整理完）。

由输入输出控制系统和外围设备两部分组成，是计算机系统的重要组成部分。在计算机系统中，通常把处理器和主存储器之外的部分称为输入输出系统。

### 2.理解计算机 I/O 软件构成及其各组成部分功能。

I/O 软件层次结构从上到下分别为：

- 用户层软件：**实现了与用户交互的接口，用户可直接使用该层提供的、与 I/O 操作相关的库函数对设备进行操作**
- 设备独立性软件：**建立逻辑设备名到物理设备名的映射关系**，根据设备类型选择调用相应的驱动程序
- 设备驱动程序：主要负责对硬件设备的具体控制，**将上层发出的一系列命令（如 read/write）转化成特定设备“能听得懂”的一系列操作**。包括设置设备寄存器，检查设备状态等。
- 中断处理程序：当 I/O 任务完成时，**I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行**。

### 3.理解并会计算磁盘调度先来先服务、最短查找时间、双向扫描算法、电梯调度算法

- 先来先服务（FCFS）：根据进程请求访问磁盘的先后顺序进行调度
- 最短查找时间（SSTF）：算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短
- 电梯调度算法：SSTF 算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，这就是扫描算法的思想。
- 循环扫描算法：只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，返回途中不响应任何请求
