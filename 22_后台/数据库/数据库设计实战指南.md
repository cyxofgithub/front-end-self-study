# 数据库设计实战指南

> 通过实战案例学习数据库设计，每个案例都详细讲解设计思路、遇到的问题和解决方案。

## 📚 目录

1. [案例 1：电商系统 - 订单快照设计](#案例-1电商系统---订单快照设计)
2. [案例 2：博客系统 - 评论树形结构设计](#案例-2博客系统---评论树形结构设计)
3. [案例 3：社交系统 - 关注关系设计](#案例-3社交系统---关注关系设计)
4. [案例 4：在线教育系统 - 学习进度设计](#案例-4在线教育系统---学习进度设计)
5. [案例 5：任务管理系统 - 状态流转设计](#案例-5任务管理系统---状态流转设计)
6. [案例 6：CMS 系统 - 多租户设计](#案例-6cms-系统---多租户设计)
7. [案例 7：日志系统 - 高并发写入设计](#案例-7日志系统---高并发写入设计)
8. [案例 8：商品系统 - 分类树设计](#案例-8商品系统---分类树设计)

---

## 案例 1：电商系统 - 订单快照设计

### 需求场景

用户下单后，商品信息可能会变更（价格调整、名称修改、下架等），但历史订单必须保持下单时的商品信息不变。

### 第一次设计（错误）

```sql
-- 订单明细表
CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,  -- 只存商品ID
    quantity INT NOT NULL,
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

**问题**：当商品价格从 100 元改为 80 元后，查询历史订单时，显示的价格是 80 元，而不是下单时的 100 元。

### 设计思路

**核心问题**：订单数据需要"快照"功能，记录下单时的商品信息。

**解决方案**：在订单明细表中冗余存储商品信息快照。

### 最终设计

```sql
-- 订单明细表（存储快照）
CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,  -- 保留商品ID，便于关联查询
    product_name VARCHAR(200) NOT NULL COMMENT '快照：下单时的商品名称',
    product_price DECIMAL(10,2) NOT NULL COMMENT '快照：下单时的商品价格',
    product_image VARCHAR(255) COMMENT '快照：下单时的商品图片',
    quantity INT NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL COMMENT '小计 = product_price * quantity',
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id)
);
```

### 设计要点

1. **冗余存储快照**：虽然违反了范式化原则，但这是业务需求，必须冗余
2. **保留商品 ID**：方便后续关联查询商品详情、库存等
3. **小计字段**：预计算 `quantity * product_price`，避免每次查询都计算

### 实际应用

```sql
-- 创建订单时，需要同时插入快照数据
INSERT INTO order_items (order_id, product_id, product_name, product_price, quantity, subtotal)
SELECT
    ? as order_id,
    product_id,
    product_name,  -- 从商品表获取
    price,         -- 从商品表获取
    ? as quantity,
    price * ? as subtotal
FROM products
WHERE product_id = ?;
```

### 掌握能力

学习完这个案例，你将掌握：

1. **识别快照需求**：能够识别哪些业务场景需要数据快照（订单、合同、账单等）
2. **合理冗余设计**：理解何时应该违反范式化原则，为了业务需求进行合理的冗余存储
3. **快照实现技巧**：掌握在创建订单时如何从源表获取数据并存储快照
4. **预计算字段**：学会使用预计算字段（如 `subtotal`）避免每次查询都进行计算
5. **业务优先思维**：理解数据库设计应该服务于业务需求，而不是教条地遵循理论

**应用场景**：订单系统、合同系统、账单系统、任何需要记录历史状态的业务场景

---

## 案例 2：博客系统 - 评论树形结构设计

### 需求场景

用户可以对文章评论，也可以回复评论，形成多级评论树。需要支持：

-   显示所有评论（按时间排序）
-   显示某个评论的所有回复
-   统计评论总数

### 第一次设计（错误）

```sql
CREATE TABLE comments (
    comment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    article_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    parent_comment_id BIGINT,  -- 父评论ID，NULL表示顶级评论
    FOREIGN KEY (parent_comment_id) REFERENCES comments(comment_id) -- 自引用外键，指向同一张表的主键，用于实现父子关系
);
```

**问题 1**：查询某个评论的所有子评论需要递归查询，性能差
**问题 2**：统计评论总数需要遍历整棵树

### 设计思路

**方案对比**：

1. **邻接表（Adjacency List）**：只存 `parent_id`

    - 优点：结构简单
    - 缺点：查询子树需要递归，性能差

2. **路径枚举（Path Enumeration）**：存完整路径 `1/2/3`

    - 优点：查询子树快
    - 缺点：路径长度有限，移动节点困难

3. **闭包表（Closure Table）**：单独存所有祖先-后代关系
    - 优点：查询快，支持任意深度
    - 缺点：存储空间大，写入复杂

**选择**：对于评论系统，层级不会太深（通常 2-3 层），使用**邻接表 + 冗余字段**优化。

### 最终设计

```sql
CREATE TABLE comments (
    comment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    article_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    parent_id BIGINT DEFAULT 0 COMMENT '0表示顶级评论，否则为父评论ID',
    content TEXT NOT NULL,
    level TINYINT DEFAULT 1 COMMENT '层级：1=顶级，2=一级回复，3=二级回复',
    path VARCHAR(500) COMMENT '路径：如 1/2/3，便于查询子树',
    like_count INT DEFAULT 0,
    reply_count INT DEFAULT 0 COMMENT '回复数，避免递归统计',
    status TINYINT DEFAULT 1 COMMENT '1:正常 2:已删除',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (article_id) REFERENCES articles(article_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_article_id (article_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_path (path(255)) COMMENT '前缀索引，支持LIKE查询'
);
```

### 真实数据

| comment_id | parent_id | level | path    | content    | reply_count | 说明                               |
| ---------- | --------- | ----- | ------- | ---------- | ----------- | ---------------------------------- |
| 1          | 0         | 1     | `1`     | 顶级评论 1 | 2           | 顶级评论，path 就是自己的 ID       |
| 2          | 1         | 2     | `1/2`   | 回复评论 1 | 1           | 一级回复，path 是父 path + 自己 ID |
| 3          | 2         | 3     | `1/2/3` | 回复评论 2 | 0           | 二级回复，形成三级嵌套             |
| 4          | 1         | 2     | `1/4`   | 回复评论 1 | 0           | 评论 1 的另一个一级回复            |
| 5          | 0         | 1     | `5`     | 顶级评论 2 | 1           | 另一个顶级评论                     |
| 6          | 5         | 2     | `5/6`   | 回复评论 5 | 0           | 评论 5 的一级回复                  |
| 7          | 0         | 1     | `7`     | 顶级评论 3 | 0           | 第三个顶级评论                     |

**树形结构可视化**：

```
文章1 (article_id = 1)
├── 评论1 (comment_id=1, path=1) - "这篇文章写得真好，学到了很多！"
│   ├── 回复2 (comment_id=2, path=1/2) - "同感！特别是关于数据库设计的部分"
│   │   └── 回复3 (comment_id=3, path=1/2/3) - "是的，快照设计很实用"
│   └── 回复4 (comment_id=4, path=1/4) - "希望能有更多实战案例"
├── 评论5 (comment_id=5, path=5) - "有个问题想请教：如何处理深层嵌套的评论？"
│   └── 回复6 (comment_id=6, path=5/6) - "可以使用路径枚举，path字段很方便"
└── 评论7 (comment_id=7, path=7) - "感谢分享，收藏了！"
```

**查询示例**：

```sql
-- 查询评论1的所有子评论（包括回复2、3、4）
SELECT * FROM comments
WHERE path LIKE '1/%' OR comment_id = 1
ORDER BY path;

-- 结果：comment_id = 1, 2, 3, 4

-- 查询评论1的直接回复（不包括二级回复）
SELECT * FROM comments
WHERE parent_id = 1;

-- 结果：comment_id = 2, 4

-- 查询所有顶级评论
SELECT * FROM comments
WHERE article_id = 1 AND parent_id = 0
ORDER BY created_at DESC;

-- 结果：comment_id = 7, 5, 1（按时间倒序）
```

### 设计要点

1. **parent_id 使用 0 而非 NULL**：避免 NULL 值带来的查询复杂性
2. **冗余 level 字段**：快速判断评论层级，便于前端展示
3. **冗余 path 字段**：快速查询某个评论的所有子评论
4. **冗余 reply_count**：避免递归统计回复数

### 实际应用

```sql
-- 查询文章的所有顶级评论
SELECT * FROM comments
WHERE article_id = ? AND parent_id = 0
ORDER BY created_at DESC;

-- 查询某个评论的所有回复（利用path）
SELECT * FROM comments
WHERE path LIKE CONCAT((SELECT path FROM comments WHERE comment_id = ?), '/%')
ORDER BY created_at ASC;

-- 添加回复时，更新path和level
INSERT INTO comments (article_id, user_id, parent_id, content, level, path)
SELECT
    ? as article_id,
    ? as user_id,
    ? as parent_id,
    ? as content,
    level + 1,
    CONCAT(path, '/', LAST_INSERT_ID())
FROM comments
WHERE comment_id = ?;
```

### 掌握能力

学习完这个案例，你将掌握：

1. **树形结构设计**：理解邻接表、路径枚举、闭包表三种树形结构设计方案的优缺点
2. **方案选择能力**：能够根据业务场景（层级深度、查询频率）选择最合适的树形结构设计方案
3. **性能优化技巧**：学会使用冗余字段（`level`、`path`、`reply_count`）优化查询性能
4. **路径查询优化**：掌握使用 `path LIKE` 查询子树，避免递归查询
5. **NULL vs 0 的选择**：理解为什么在某些场景下使用 0 而非 NULL 更合适

**应用场景**：评论系统、组织架构、分类树、菜单树、权限树、任何树形结构数据

---

## 案例 3：社交系统 - 关注关系设计

### 需求场景

用户 A 关注用户 B，需要支持：

-   查询 A 关注了谁（关注列表）
-   查询谁关注了 A（粉丝列表）
-   判断 A 是否关注了 B
-   查询 A 和 B 是否互相关注

### 第一次设计（错误）

```sql
CREATE TABLE follows (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    follow_user_id BIGINT NOT NULL COMMENT '关注的用户ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY (user_id, follow_user_id)
);
```

**问题**：字段命名不清晰，`user_id` 和 `follow_user_id` 容易混淆，查询时需要思考哪个是关注者。

### 设计思路

**核心问题**：如何清晰地表示"谁关注了谁"？

**解决方案**：使用语义明确的字段名，区分关注者和被关注者。

### 最终设计

```sql
CREATE TABLE follows (
    follow_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    follower_id BIGINT NOT NULL COMMENT '关注者ID（粉丝）',
    following_id BIGINT NOT NULL COMMENT '被关注者ID（博主）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (follower_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (following_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY uk_follower_following (follower_id, following_id),
    INDEX idx_follower_id (follower_id) COMMENT '查询关注列表',
    INDEX idx_following_id (following_id) COMMENT '查询粉丝列表'
);
```

### 设计要点

1. **语义明确的字段名**：`follower_id`（粉丝）关注 `following_id`（博主）
2. **唯一约束**：防止重复关注
3. **双向索引**：`idx_follower_id` 用于查询关注列表，`idx_following_id` 用于查询粉丝列表

### 实际应用

```sql
-- 查询用户A的关注列表（A关注了谁）
SELECT u.* FROM users u
JOIN follows f ON u.user_id = f.following_id
WHERE f.follower_id = ?;

-- 查询用户A的粉丝列表（谁关注了A）
SELECT u.* FROM users u
JOIN follows f ON u.user_id = f.follower_id
WHERE f.following_id = ?;

-- 判断A是否关注了B
SELECT COUNT(*) FROM follows
WHERE follower_id = ? AND following_id = ?;

-- 查询互相关注（需要JOIN两次）
SELECT f1.follower_id, f1.following_id
FROM follows f1
JOIN follows f2 ON f1.follower_id = f2.following_id
    AND f1.following_id = f2.follower_id;
```

### 掌握能力

学习完这个案例，你将掌握：

1. **关系表设计**：掌握如何设计清晰的关系表，使用语义明确的字段名
2. **双向查询优化**：理解如何为双向查询（关注列表/粉丝列表）设计合适的索引
3. **唯一约束设计**：学会使用复合唯一约束防止重复关系
4. **复杂关系查询**：掌握如何查询互相关注等复杂关系
5. **字段命名规范**：理解好的字段命名（`follower_id`/`following_id`）如何提高代码可读性

**应用场景**：社交系统、关注/粉丝关系、好友关系、点赞关系、收藏关系、任何双向关系场景

---

## 案例 4：在线教育系统 - 学习进度设计

### 需求场景

学生购买课程后，需要记录：

-   每个章节的学习进度（已学习/未学习）
-   每个视频的观看时长
-   课程的整体学习进度百分比
-   最后学习位置（断点续播）

### 第一次设计（错误）

```sql
-- 只记录课程学习状态
CREATE TABLE course_progress (
    progress_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    course_id BIGINT NOT NULL,
    progress_percent INT DEFAULT 0 COMMENT '学习进度百分比',
    last_study_time TIMESTAMP,
    UNIQUE KEY (user_id, course_id)
);
```

**问题**：

1. 无法知道具体哪个章节已学习
2. 无法记录视频观看时长
3. 进度百分比计算不准确

### 设计思路

**核心问题**：需要同时记录整体进度和明细进度。

**解决方案**：采用"汇总表 + 明细表"的设计模式。

### 最终设计

```sql
-- 1. 课程学习进度汇总表
CREATE TABLE course_progress (
    progress_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    course_id BIGINT NOT NULL,
    total_chapters INT DEFAULT 0 COMMENT '总章节数',
    completed_chapters INT DEFAULT 0 COMMENT '已完成章节数',
    progress_percent DECIMAL(5,2) DEFAULT 0 COMMENT '学习进度百分比',
    last_chapter_id BIGINT COMMENT '最后学习的章节ID',
    last_study_time TIMESTAMP COMMENT '最后学习时间',
    completed_at TIMESTAMP NULL COMMENT '完成时间',
    UNIQUE KEY uk_user_course (user_id, course_id),
    INDEX idx_user_id (user_id),
    INDEX idx_course_id (course_id)
);

-- 2. 章节学习进度明细表
CREATE TABLE chapter_progress (
    progress_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    course_id BIGINT NOT NULL,
    chapter_id BIGINT NOT NULL,
    status TINYINT DEFAULT 0 COMMENT '0:未学习 1:学习中 2:已完成',
    study_duration INT DEFAULT 0 COMMENT '学习时长（秒）',
    last_position INT DEFAULT 0 COMMENT '最后观看位置（秒）',
    completed_at TIMESTAMP NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (course_id) REFERENCES courses(course_id),
    FOREIGN KEY (chapter_id) REFERENCES chapters(chapter_id),
    UNIQUE KEY uk_user_chapter (user_id, course_id, chapter_id),
    INDEX idx_user_course (user_id, course_id),
    INDEX idx_chapter_id (chapter_id)
);
```

### 设计要点

1. **汇总表 + 明细表**：汇总表快速查询整体进度，明细表记录详细信息
2. **冗余字段**：`course_id` 在明细表中冗余，避免 JOIN 查询
3. **进度计算**：`progress_percent = (completed_chapters / total_chapters) * 100`
4. **断点续播**：`last_position` 记录视频观看位置

### 实际应用

```sql
-- 更新章节学习进度
UPDATE chapter_progress
SET status = 2, completed_at = NOW(), study_duration = study_duration + ?
WHERE user_id = ? AND chapter_id = ?;

-- 同步更新课程整体进度
UPDATE course_progress cp
SET
    completed_chapters = (
        SELECT COUNT(*) FROM chapter_progress
        WHERE user_id = cp.user_id
        AND course_id = cp.course_id
        AND status = 2
    ),
    progress_percent = ROUND(
        (completed_chapters / total_chapters) * 100,
        2
    ),
    last_chapter_id = ?,
    last_study_time = NOW()
WHERE user_id = ? AND course_id = ?;
```

### 掌握能力

学习完这个案例，你将掌握：

1. **汇总表+明细表模式**：理解何时需要同时设计汇总表和明细表，兼顾查询性能和详细信息
2. **进度计算设计**：掌握如何设计学习进度、完成度等百分比计算字段
3. **冗余字段使用**：学会在明细表中冗余存储 `course_id` 等字段，避免频繁 JOIN
4. **断点续播设计**：理解如何设计 `last_position` 等字段支持断点续播功能
5. **数据同步策略**：掌握如何同步更新汇总表和明细表的数据

**应用场景**：在线教育、学习进度、任务完成度、项目进度、任何需要记录明细和汇总的场景

---

// todo-学习到这里

## 案例 5：任务管理系统 - 状态流转设计

### 需求场景

任务有多种状态：待处理、进行中、已完成、已取消。需要：

-   记录状态变更历史
-   支持状态流转规则（如：已完成不能变回待处理）
-   查询任务当前状态和历史状态

### 第一次设计（错误）

```sql
CREATE TABLE tasks (
    task_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' COMMENT 'pending/in_progress/completed/cancelled',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**问题**：

1. 无法查询状态变更历史
2. 无法知道状态变更时间和操作人
3. 状态值使用字符串，容易拼写错误

### 设计思路

**核心问题**：需要同时记录当前状态和历史状态。

**解决方案**：

1. 任务表记录当前状态
2. 状态变更历史表记录所有变更记录
3. 使用状态码而非字符串

### 最终设计

```sql
-- 1. 任务表（记录当前状态）
CREATE TABLE tasks (
    task_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    assignee_id BIGINT COMMENT '负责人ID',
    status TINYINT DEFAULT 1 COMMENT '1:待处理 2:进行中 3:已完成 4:已取消',
    priority TINYINT DEFAULT 2 COMMENT '1:低 2:中 3:高',
    due_date DATE COMMENT '截止日期',
    created_by BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_assignee_id (assignee_id),
    INDEX idx_status (status),
    INDEX idx_due_date (due_date)
);

-- 2. 任务状态变更历史表
CREATE TABLE task_status_history (
    history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_id BIGINT NOT NULL,
    from_status TINYINT COMMENT '原状态，NULL表示创建',
    to_status TINYINT NOT NULL COMMENT '新状态',
    operator_id BIGINT NOT NULL COMMENT '操作人ID',
    remark VARCHAR(500) COMMENT '备注',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(task_id) ON DELETE CASCADE,
    INDEX idx_task_id (task_id),
    INDEX idx_created_at (created_at)
);
```

### 设计要点

1. **状态码设计**：使用 `TINYINT` 而非 `VARCHAR`，节省空间且避免拼写错误
2. **历史表设计**：记录 `from_status` 和 `to_status`，形成完整的状态流转链
3. **操作人记录**：记录每次状态变更的操作人，便于追溯

### 实际应用

```sql
-- 更新任务状态（需要同时更新任务表和历史表）
BEGIN;

-- 更新任务状态
UPDATE tasks
SET status = ?, updated_at = NOW()
WHERE task_id = ?;

-- 记录状态变更历史
INSERT INTO task_status_history (task_id, from_status, to_status, operator_id, remark)
SELECT status, ?, ?, ?
FROM tasks
WHERE task_id = ?;

COMMIT;

-- 查询任务的状态流转历史
SELECT
    tsh.*,
    u1.username as operator_name,
    s1.status_name as from_status_name,
    s2.status_name as to_status_name
FROM task_status_history tsh
LEFT JOIN users u1 ON tsh.operator_id = u1.user_id
LEFT JOIN status_dict s1 ON tsh.from_status = s1.status_code
LEFT JOIN status_dict s2 ON tsh.to_status = s2.status_code
WHERE tsh.task_id = ?
ORDER BY tsh.created_at ASC;
```

### 掌握能力

学习完这个案例，你将掌握：

1. **状态流转设计**：理解如何设计状态字段，使用状态码而非字符串
2. **历史记录设计**：掌握如何设计历史表记录完整的状态变更链
3. **审计追溯能力**：学会记录操作人、操作时间等信息，便于问题追溯
4. **事务处理**：理解更新状态时需要同时更新主表和历史表，使用事务保证一致性
5. **状态码设计**：掌握使用 `TINYINT` 存储状态码，节省空间且避免拼写错误

**应用场景**：任务管理、工单系统、审批流程、订单状态、任何有状态流转的业务场景

---

## 案例 6：CMS 系统 - 多租户设计

### 需求场景

SaaS 内容管理系统，多个客户（租户）使用同一套系统，但数据需要完全隔离。需要：

-   每个租户只能看到自己的数据
-   查询时自动过滤租户数据
-   支持租户级别的权限控制

### 第一次设计（错误）

```sql
-- 没有租户隔离
CREATE TABLE articles (
    article_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**问题**：所有租户的数据混在一起，无法隔离。

### 设计思路

**方案对比**：

1. **共享数据库，共享表**：每个表添加 `tenant_id`

    - 优点：实现简单，成本低
    - 缺点：数据量大时性能差，难以扩展

2. **共享数据库，独立表**：每个租户独立的表 `articles_tenant_1`

    - 优点：数据隔离好
    - 缺点：表数量多，难以管理

3. **独立数据库**：每个租户独立数据库
    - 优点：完全隔离，性能好
    - 缺点：成本高，难以维护

**选择**：对于中小型 SaaS，使用**方案 1**，每个表添加 `tenant_id`。

### 最终设计

```sql
-- 1. 租户表
CREATE TABLE tenants (
    tenant_id INT PRIMARY KEY AUTO_INCREMENT,
    tenant_name VARCHAR(100) NOT NULL,
    domain VARCHAR(100) UNIQUE COMMENT '租户域名',
    status TINYINT DEFAULT 1 COMMENT '1:正常 2:禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 文章表（添加tenant_id）
CREATE TABLE articles (
    article_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id INT NOT NULL COMMENT '租户ID',
    title VARCHAR(200) NOT NULL,
    content TEXT,
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_tenant_status (tenant_id, status)
) COMMENT '所有租户共享，通过tenant_id隔离';

-- 3. 用户表（添加tenant_id）
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id INT NOT NULL,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id),
    UNIQUE KEY uk_tenant_username (tenant_id, username),
    UNIQUE KEY uk_tenant_email (tenant_id, email),
    INDEX idx_tenant_id (tenant_id)
);
```

### 设计要点

1. **所有表添加 tenant_id**：确保数据隔离
2. **唯一约束包含 tenant_id**：`UNIQUE KEY uk_tenant_username (tenant_id, username)`，不同租户可以有相同的用户名
3. **索引设计**：所有查询条件都包含 `tenant_id`，所以索引以 `tenant_id` 开头

### 实际应用

```sql
-- 查询租户的文章（必须带上tenant_id）
SELECT * FROM articles
WHERE tenant_id = ? AND status = 1
ORDER BY created_at DESC;

-- 创建文章（自动注入tenant_id）
INSERT INTO articles (tenant_id, title, content)
VALUES (?, ?, ?);

-- 在应用层封装：所有查询自动添加tenant_id过滤
-- 例如：Article::where('tenant_id', $currentTenantId)->get();
```

### 掌握能力

学习完这个案例，你将掌握：

1. **多租户数据隔离**：理解如何通过 `tenant_id` 实现多租户数据隔离
2. **唯一约束设计**：掌握如何在多租户场景下设计唯一约束（包含 `tenant_id`）
3. **索引设计策略**：理解多租户场景下的索引设计，所有索引都以 `tenant_id` 开头
4. **查询安全**：学会在应用层确保所有查询都包含 `tenant_id` 过滤，防止数据泄露
5. **方案选择能力**：理解共享表、独立表、独立数据库三种方案的优缺点和适用场景

**应用场景**：SaaS 系统、多租户系统、企业级应用、任何需要数据隔离的场景

---

## 案例 7：日志系统 - 高并发写入设计

### 需求场景

系统需要记录用户操作日志，特点：

-   写入频率高（每秒数千条）
-   查询频率低（主要是统计分析）
-   数据量大（每天百万级）
-   需要按时间范围查询

### 第一次设计（错误）

```sql
CREATE TABLE operation_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    operation_type VARCHAR(50),
    content TEXT,
    ip_address VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
);
```

**问题**：

1. 高并发写入时，主键自增锁竞争激烈
2. 单表数据量过大，查询慢
3. 索引过多影响写入性能

### 设计思路

**核心问题**：如何优化高并发写入性能？

**解决方案**：

1. **分表**：按时间分表（按月或按天）
2. **减少索引**：只保留必要的索引
3. **异步写入**：使用消息队列缓冲写入

### 最终设计

```sql
-- 按月分表：operation_logs_202401, operation_logs_202402
CREATE TABLE operation_logs_202401 (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    operation_type VARCHAR(50),
    table_name VARCHAR(50) COMMENT '操作的表名',
    record_id BIGINT COMMENT '操作的记录ID',
    old_value JSON COMMENT '旧值',
    new_value JSON COMMENT '新值',
    ip_address VARCHAR(50),
    user_agent VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_created (user_id, created_at),
    INDEX idx_table_record (table_name, record_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
PARTITION BY RANGE (UNIX_TIMESTAMP(created_at)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01'))
);
```

### 设计要点

1. **分表策略**：按月分表，查询时路由到对应月份的表
2. **分区表**：MySQL 5.7+ 支持分区，可以进一步优化
3. **减少索引**：只保留查询必需的索引
4. **JSON 字段**：使用 JSON 存储新旧值，灵活但查询性能略差（适合日志场景）

### 实际应用

```sql
-- 写入日志（路由到对应月份的表）
-- 应用层根据当前时间决定写入哪张表
INSERT INTO operation_logs_202401
(user_id, operation_type, table_name, record_id, old_value, new_value, ip_address)
VALUES (?, ?, ?, ?, ?, ?, ?);

-- 查询日志（需要查询多张表）
SELECT * FROM operation_logs_202401
WHERE user_id = ? AND created_at >= '2024-01-01' AND created_at < '2024-02-01'
UNION ALL
SELECT * FROM operation_logs_202402
WHERE user_id = ? AND created_at >= '2024-02-01' AND created_at < '2024-03-01';

-- 或者使用消息队列异步写入
-- 1. 日志写入消息队列（Redis/RabbitMQ）
// producer.send('log_queue', logData);

-- 2. 消费者批量写入数据库
INSERT INTO operation_logs_202401 (...) VALUES (...), (...), (...);
```

### 掌握能力

学习完这个案例，你将掌握：

1. **高并发写入优化**：理解如何通过分表、减少索引、异步写入优化高并发写入性能
2. **分表策略**：掌握按时间分表的策略，以及如何路由查询到正确的表
3. **分区表使用**：了解 MySQL 分区表的使用场景和语法
4. **索引权衡**：理解在写入频繁的场景下，如何权衡索引数量和查询性能
5. **异步处理**：掌握使用消息队列缓冲写入，批量处理提高性能

**应用场景**：日志系统、操作审计、行为追踪、任何高并发写入的场景

---

## 案例 8：商品系统 - 分类树设计

### 需求场景

商品分类是多级树形结构，如：电子产品 > 手机 > 智能手机。需要：

-   支持无限层级
-   快速查询某个分类的所有子分类
-   快速查询某个分类的所有商品
-   统计每个分类下的商品数量

### 第一次设计（错误）

```sql
CREATE TABLE categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(100),
    parent_id INT DEFAULT 0,
    FOREIGN KEY (parent_id) REFERENCES categories(category_id)
);
```

**问题**：

1. 查询某个分类的所有子分类需要递归查询，性能差
2. 查询某个分类的所有商品（包括子分类）需要递归查询所有子分类 ID

### 设计思路

**方案对比**：

1. **邻接表**：只存 `parent_id`

    - 查询子树需要递归，性能差

2. **路径枚举**：存 `path = '1/2/3'`

    - 查询子树快：`WHERE path LIKE '1/2/3/%'`
    - 但路径长度有限（VARCHAR 长度限制）

3. **闭包表**：单独存所有祖先-后代关系
    - 查询最快，但存储空间大

**选择**：对于商品分类，层级通常不超过 4 层，使用**路径枚举 + 冗余字段**。

### 最终设计

```sql
CREATE TABLE categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(100) NOT NULL,
    parent_id INT DEFAULT 0 COMMENT '父分类ID，0表示顶级分类',
    level TINYINT DEFAULT 1 COMMENT '层级：1=一级，2=二级，3=三级',
    path VARCHAR(255) COMMENT '路径：如 1/2/3，便于查询子树',
    sort_order INT DEFAULT 0 COMMENT '排序',
    product_count INT DEFAULT 0 COMMENT '商品数量（冗余，避免统计查询）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_parent_id (parent_id),
    INDEX idx_path (path(100)) COMMENT '前缀索引，支持LIKE查询',
    INDEX idx_level (level)
);
```

### 设计要点

1. **path 字段**：存储完整路径，如 `1/2/3`，快速查询子树
2. **level 字段**：冗余层级，快速判断分类层级
3. **product_count 冗余**：避免每次查询都统计商品数量
4. **前缀索引**：`path(100)` 只索引前 100 个字符，节省空间

### 实际应用

```sql
-- 查询某个分类的所有子分类（利用path）
SELECT * FROM categories
WHERE path LIKE CONCAT((SELECT path FROM categories WHERE category_id = ?), '/%')
ORDER BY level, sort_order;

-- 查询某个分类及其所有子分类的商品
SELECT p.* FROM products p
WHERE p.category_id IN (
    SELECT category_id FROM categories
    WHERE path LIKE CONCAT((SELECT path FROM categories WHERE category_id = ?), '/%')
    OR category_id = ?
);

-- 添加分类时，更新path
INSERT INTO categories (category_name, parent_id, level, path)
SELECT
    ? as category_name,
    ? as parent_id,
    level + 1,
    CONCAT(path, '/', LAST_INSERT_ID())
FROM categories
WHERE category_id = ?;

-- 更新商品数量（定时任务或触发器）
UPDATE categories c
SET product_count = (
    SELECT COUNT(*) FROM products
    WHERE category_id IN (
        SELECT category_id FROM categories
        WHERE path LIKE CONCAT(c.path, '/%') OR category_id = c.category_id
    )
);
```

### 掌握能力

学习完这个案例，你将掌握：

1. **分类树设计**：掌握使用路径枚举（Path Enumeration）设计分类树
2. **子树查询优化**：理解如何使用 `path LIKE` 快速查询所有子分类，避免递归
3. **冗余字段使用**：学会使用 `level`、`product_count` 等冗余字段优化查询
4. **前缀索引**：掌握使用前缀索引 `path(100)` 节省存储空间
5. **路径维护**：理解添加分类时如何自动维护 `path` 字段

**应用场景**：商品分类、文章分类、组织架构、菜单树、权限树、任何需要快速查询子树的场景

---

## 总结

### 设计思路总结

通过以上 8 个实战案例，我们学到了：

1. **订单快照**：业务需求优先，必要时可以违反范式化
2. **树形结构**：根据查询场景选择合适的设计方案（邻接表/路径枚举/闭包表）
3. **关系设计**：使用语义明确的字段名，避免混淆
4. **进度设计**：汇总表 + 明细表，兼顾查询性能和详细信息
5. **状态流转**：当前状态 + 历史表，记录完整变更链
6. **多租户**：所有表添加 `tenant_id`，确保数据隔离
7. **高并发写入**：分表 + 减少索引 + 异步写入
8. **分类树**：路径枚举 + 冗余字段，平衡查询性能和存储空间

### 核心原则

-   ✅ **业务优先**：设计服务于业务需求，不是教条地遵循理论
-   ✅ **性能平衡**：在查询性能和存储空间之间找到平衡
-   ✅ **冗余合理**：合理使用冗余字段，避免频繁 JOIN 和统计查询
-   ✅ **索引适度**：索引不是越多越好，要根据查询场景设计
-   ✅ **扩展考虑**：设计时考虑未来扩展，但不过度设计

**记住**：数据库设计没有标准答案，只有最适合当前业务场景的方案。多实践、多思考、多总结！
