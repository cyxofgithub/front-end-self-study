## Foreign Key 外键

### 定义

外键（Foreign Key）是用于建立两个表之间关联关系的字段，它引用另一个表的主键。

### 作用

1. **数据完整性**：确保引用的数据必须存在，防止插入无效数据
2. **关联关系**：明确表与表之间的关联关系
3. **级联操作**：可以设置级联删除或更新

### 语法

```sql
-- 创建表时添加外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 或者使用命名外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL
);

-- 订单表（包含外键）
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**说明**：

-   `orders.user_id` 是外键，引用 `users.user_id`（主键）
-   插入订单时，`user_id` 必须在 `users` 表中存在，否则会报错
-   删除用户时，如果该用户有订单，默认会阻止删除（除非设置级联删除）

### 级联操作

```sql
-- 级联删除：删除用户时，自动删除该用户的所有订单
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE

-- 级联更新：更新用户ID时，自动更新订单中的user_id
FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE

-- 设置为NULL：删除用户时，订单的user_id设为NULL（需要字段允许NULL）
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL
```

---

## Index 索引

### 定义

索引（Index）是数据库中用于快速查找数据的数据结构，类似于书籍的目录。

### 作用

1. **提高查询速度**：快速定位数据，避免全表扫描
2. **加速排序**：ORDER BY 操作更快
3. **加速连接**：JOIN 操作更快

### 索引类型

1. **普通索引（INDEX）**：最基本的索引，允许重复值
2. **唯一索引（UNIQUE INDEX）**：不允许重复值
3. **主键索引（PRIMARY KEY）**：特殊的唯一索引，不允许 NULL
4. **全文索引（FULLTEXT）**：用于全文搜索
5. **复合索引**：多个字段组成的索引

### 语法

```sql
-- 创建表时添加索引
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_username_email (username, email)  -- 复合索引
);

-- 创建表后添加索引
CREATE INDEX idx_username ON users(username);

-- 删除索引
DROP INDEX idx_username ON users;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 主键自动创建索引
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    created_at TIMESTAMP,
    INDEX idx_username (username),              -- 普通索引
    INDEX idx_email (email),                    -- 普通索引
    INDEX idx_created_at (created_at),          -- 时间索引
    INDEX idx_username_email (username, email)  -- 复合索引
);
```

**查询优化示例**：

```sql
-- 使用索引：WHERE username = '张三'（username有索引）
SELECT * FROM users WHERE username = '张三';  -- 快速查询

-- 不使用索引：WHERE phone = '13800138000'（phone没有索引）
SELECT * FROM users WHERE phone = '13800138000';  -- 全表扫描，慢

-- 复合索引：WHERE username = '张三' AND email = 'zhangsan@example.com'
SELECT * FROM users WHERE username = '张三' AND email = 'zhangsan@example.com';
-- 可以使用 idx_username_email 复合索引
```

### 索引设计原则

1. **经常查询的字段**：WHERE、JOIN、ORDER BY 的字段
2. **选择性高的字段**：字段值重复度低（如用户名、邮箱）
3. **不要过度索引**：索引会占用存储空间，影响写入性能
4. **外键字段**：必须创建索引

---

## Unique Key 唯一键

### 定义

唯一键（Unique Key）确保字段或字段组合的值在表中唯一，不允许重复。

### 作用

1. **数据唯一性**：确保某个字段的值不重复
2. **业务约束**：如用户名、邮箱、手机号等必须唯一
3. **自动创建索引**：唯一键会自动创建唯一索引

### 与主键的区别

| 特性     | 主键（Primary Key） | 唯一键（Unique Key）              |
| -------- | ------------------- | --------------------------------- |
| 唯一性   | ✅ 必须唯一         | ✅ 必须唯一                       |
| NULL 值  | ❌ 不允许 NULL      | ✅ 允许 NULL（但只能有一个 NULL） |
| 数量限制 | 1 个                | 可以有多个                        |
| 用途     | 标识记录            | 业务唯一性约束                    |

### 语法

```sql
-- 创建表时添加唯一键
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,              -- 方式1：字段级
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),              -- 方式2：表级命名
    UNIQUE KEY uk_phone (phone),
    UNIQUE KEY uk_email_phone (email, phone)  -- 复合唯一键
);

-- 创建表后添加唯一键
ALTER TABLE users ADD UNIQUE KEY uk_email (email);

-- 删除唯一键
ALTER TABLE users DROP INDEX uk_email;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 用户名唯一
    email VARCHAR(100) UNIQUE NOT NULL,        -- 邮箱唯一
    phone VARCHAR(20) UNIQUE,                  -- 手机号唯一（允许NULL）
    id_card VARCHAR(18) UNIQUE                 -- 身份证号唯一
);
```

**插入数据示例**：

```sql
-- ✅ 成功：所有字段都唯一
INSERT INTO users (username, email, phone) VALUES ('张三', 'zhangsan@example.com', '13800138000');

-- ❌ 失败：用户名重复
INSERT INTO users (username, email, phone) VALUES ('张三', 'lisi@example.com', '13800138001');
-- 错误：Duplicate entry '张三' for key 'username'

-- ✅ 成功：phone 可以为 NULL，且多个 NULL 不冲突
INSERT INTO users (username, email, phone) VALUES ('李四', 'lisi@example.com', NULL);
INSERT INTO users (username, email, phone) VALUES ('王五', 'wangwu@example.com', NULL);
```

### 复合唯一键

```sql
-- 订单明细表：同一订单同一商品只能有一条记录
CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    UNIQUE KEY uk_order_product (order_id, product_id)  -- 订单+商品组合唯一
);
```

**说明**：

-   `order_id` 和 `product_id` 的组合必须唯一
-   同一个订单可以有不同的商品
-   同一个订单不能有重复的商品

## join on 的作用

```sql
SELECT u.* FROM users u
JOIN follows f ON u.user_id = f.following_id
WHERE f.follower_id = ?;
```

### JOIN ON 解释

`JOIN ON` 用于将两个表连接在一起，`ON` 后面指定连接条件。

**这段 SQL 的执行过程：**

1. `JOIN follows f` - 将 `users` 表和 `follows` 表连接
2. `ON u.user_id = f.following_id` - 连接条件：users 表的 user_id 等于 follows 表的 following_id
3. `WHERE f.follower_id = ?` - 过滤条件：只取指定用户关注的记录

#### 真实数据示例

**users 表数据：**

| user_id | username |
| ------- | -------- |
| 1       | 张三     |
| 2       | 李四     |
| 3       | 王五     |
| 4       | 赵六     |

**follows 表数据：**

| follow_id | follower_id | following_id |
| --------- | ----------- | ------------ |
| 1         | 1           | 2            |
| 2         | 1           | 3            |
| 3         | 2           | 1            |
| 4         | 3           | 1            |
| 5         | 3           | 2            |

**JOIN 后的连接结果（ON u.user_id = f.following_id）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |
| 1       | 张三     | 3         | 2           | 1            |
| 1       | 张三     | 4         | 3           | 1            |
| 2       | 李四     | 5         | 3           | 2            |

**加上 WHERE f.follower_id = 1 后的结果（查询张三关注了谁）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |
