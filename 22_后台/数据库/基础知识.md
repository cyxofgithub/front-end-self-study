## Foreign Key 外键

### 定义

外键（Foreign Key）是用于建立两个表之间关联关系的字段，它引用另一个表的主键。

### 作用

1. **数据完整性**：确保引用的数据必须存在，防止插入无效数据
2. **关联关系**：明确表与表之间的关联关系
3. **级联操作**：可以设置级联删除或更新

### 语法

```sql
-- 创建表时添加外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 或者使用命名外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL
);

-- 订单表（包含外键）
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**说明**：

-   `orders.user_id` 是外键，引用 `users.user_id`（主键）
-   插入订单时，`user_id` 必须在 `users` 表中存在，否则会报错
-   删除用户时，如果该用户有订单，默认会阻止删除（除非设置级联删除）

### 级联操作

```sql
-- 级联删除：删除用户时，自动删除该用户的所有订单
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE

-- 级联更新：更新用户ID时，自动更新订单中的user_id
FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE

-- 设置为NULL：删除用户时，订单的user_id设为NULL（需要字段允许NULL）
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL
```

---

## Index 索引

### 定义

索引（Index）是数据库中用于快速查找数据的数据结构，类似于书籍的目录。

### 作用

1. **提高查询速度**：快速定位数据，避免全表扫描
2. **加速排序**：ORDER BY 操作更快
3. **加速连接**：JOIN 操作更快

### 索引类型

1. **普通索引（INDEX）**：最基本的索引，允许重复值
2. **唯一索引（UNIQUE INDEX）**：不允许重复值
3. **主键索引（PRIMARY KEY）**：特殊的唯一索引，不允许 NULL
4. **全文索引（FULLTEXT）**：用于全文搜索
5. **复合索引**：多个字段组成的索引

### 语法

```sql
-- 创建表时添加索引
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_username_email (username, email)  -- 复合索引
);

-- 创建表后添加索引
CREATE INDEX idx_username ON users(username);

-- 删除索引
DROP INDEX idx_username ON users;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 主键自动创建索引
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    created_at TIMESTAMP,
    INDEX idx_username (username),              -- 普通索引
    INDEX idx_email (email),                    -- 普通索引
    INDEX idx_created_at (created_at),          -- 时间索引
    INDEX idx_username_email (username, email)  -- 复合索引
);
```

**查询优化示例**：

```sql
-- 使用索引：WHERE username = '张三'（username有索引）
SELECT * FROM users WHERE username = '张三';  -- 快速查询

-- 不使用索引：WHERE phone = '13800138000'（phone没有索引）
SELECT * FROM users WHERE phone = '13800138000';  -- 全表扫描，慢

-- 复合索引：WHERE username = '张三' AND email = 'zhangsan@example.com'
SELECT * FROM users WHERE username = '张三' AND email = 'zhangsan@example.com';
-- 可以使用 idx_username_email 复合索引
```

### 索引设计原则

1. **经常查询的字段**：WHERE、JOIN、ORDER BY 的字段
2. **选择性高的字段**：字段值重复度低（如用户名、邮箱）
3. **不要过度索引**：索引会占用存储空间，影响写入性能
4. **外键字段**：必须创建索引

---

## Unique Key 唯一键

### 定义

唯一键（Unique Key）确保字段或字段组合的值在表中唯一，不允许重复。

### 作用

1. **数据唯一性**：确保某个字段的值不重复
2. **业务约束**：如用户名、邮箱、手机号等必须唯一
3. **自动创建索引**：唯一键会自动创建唯一索引

### 与主键的区别

| 特性     | 主键（Primary Key） | 唯一键（Unique Key）              |
| -------- | ------------------- | --------------------------------- |
| 唯一性   | ✅ 必须唯一         | ✅ 必须唯一                       |
| NULL 值  | ❌ 不允许 NULL      | ✅ 允许 NULL（但只能有一个 NULL） |
| 数量限制 | 1 个                | 可以有多个                        |
| 用途     | 标识记录            | 业务唯一性约束                    |

### 语法

```sql
-- 创建表时添加唯一键
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,              -- 方式1：字段级
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),              -- 方式2：表级命名
    UNIQUE KEY uk_phone (phone),
    UNIQUE KEY uk_email_phone (email, phone)  -- 复合唯一键
);

-- 创建表后添加唯一键
ALTER TABLE users ADD UNIQUE KEY uk_email (email);

-- 删除唯一键
ALTER TABLE users DROP INDEX uk_email;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 用户名唯一
    email VARCHAR(100) UNIQUE NOT NULL,        -- 邮箱唯一
    phone VARCHAR(20) UNIQUE,                  -- 手机号唯一（允许NULL）
    id_card VARCHAR(18) UNIQUE                 -- 身份证号唯一
);
```

**插入数据示例**：

```sql
-- ✅ 成功：所有字段都唯一
INSERT INTO users (username, email, phone) VALUES ('张三', 'zhangsan@example.com', '13800138000');

-- ❌ 失败：用户名重复
INSERT INTO users (username, email, phone) VALUES ('张三', 'lisi@example.com', '13800138001');
-- 错误：Duplicate entry '张三' for key 'username'

-- ✅ 成功：phone 可以为 NULL，且多个 NULL 不冲突
INSERT INTO users (username, email, phone) VALUES ('李四', 'lisi@example.com', NULL);
INSERT INTO users (username, email, phone) VALUES ('王五', 'wangwu@example.com', NULL);
```

### 复合唯一键

```sql
-- 订单明细表：同一订单同一商品只能有一条记录
CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    UNIQUE KEY uk_order_product (order_id, product_id)  -- 订单+商品组合唯一
);
```

**说明**：

-   `order_id` 和 `product_id` 的组合必须唯一
-   同一个订单可以有不同的商品
-   同一个订单不能有重复的商品

## join on 的作用

```sql
SELECT u.* FROM users u
JOIN follows f ON u.user_id = f.following_id
WHERE f.follower_id = ?;
```

### JOIN ON 解释

`JOIN ON` 用于将两个表连接在一起，`ON` 后面指定连接条件。

**这段 SQL 的执行过程：**

1. `JOIN follows f` - 将 `users` 表和 `follows` 表连接
2. `ON u.user_id = f.following_id` - 连接条件：users 表的 user_id 等于 follows 表的 following_id
3. `WHERE f.follower_id = ?` - 过滤条件：只取指定用户关注的记录

#### 真实数据示例

**users 表数据：**

| user_id | username |
| ------- | -------- |
| 1       | 张三     |
| 2       | 李四     |
| 3       | 王五     |
| 4       | 赵六     |

**follows 表数据：**

| follow_id | follower_id | following_id |
| --------- | ----------- | ------------ |
| 1         | 1           | 2            |
| 2         | 1           | 3            |
| 3         | 2           | 1            |
| 4         | 3           | 1            |
| 5         | 3           | 2            |

**JOIN 后的连接结果（ON u.user_id = f.following_id）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |
| 1       | 张三     | 3         | 2           | 1            |
| 1       | 张三     | 4         | 3           | 1            |
| 2       | 李四     | 5         | 3           | 2            |

**加上 WHERE f.follower_id = 1 后的结果（查询张三关注了谁）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |

## 事务语句

### 作用

-   **BEGIN / START TRANSACTION**：开始一个事务，将后续的 SQL 操作组合成一个整体
-   **COMMIT**：提交事务，使所有更改永久生效
-   **ROLLBACK**：回滚事务，撤销所有未提交的更改

**核心作用**：确保一组 SQL 操作要么全部成功，要么全部失败，保证数据一致性。

### 语法

```sql
START TRANSACTION;  -- 或 BEGIN
-- SQL 语句1
-- SQL 语句2
COMMIT;  -- 提交事务
-- 或
ROLLBACK;  -- 回滚事务
```

### 示例：转账操作

```sql
-- ❌ 不使用事务（危险）
UPDATE accounts SET balance = balance - 200 WHERE username = '张三';
UPDATE accounts SET balance = balance + 200 WHERE username = '李四';
-- 如果第二步失败，张三的钱扣了，但李四没收到

-- ✅ 使用事务（安全）
START TRANSACTION;
UPDATE accounts SET balance = balance - 200 WHERE username = '张三';
UPDATE accounts SET balance = balance + 200 WHERE username = '李四';
COMMIT;  -- 成功时提交
-- ROLLBACK;  -- 失败时回滚
```

### 示例：回滚操作

```sql
-- 转账操作，如果出错则回滚
START TRANSACTION;

UPDATE accounts SET balance = balance - 500 WHERE username = '张三';
UPDATE accounts SET balance = balance + 500 WHERE username = '李四';

-- 如果任何操作失败（如余额不足、用户不存在等），执行回滚
-- 在应用程序中通常这样处理：
-- try {
--    执行 SQL 操作
--    COMMIT;  -- 成功时提交
-- } catch (error) {
--    ROLLBACK;  -- 失败时回滚
-- }

-- 手动回滚示例
ROLLBACK;  -- 撤销上面的所有更改，数据库恢复到事务开始前的状态
```

**回滚效果**：

-   执行 `ROLLBACK` 后，事务中的所有更改都会被撤销
-   数据库恢复到 `START TRANSACTION` 之前的状态
-   例如：如果转账过程中出错，张三的余额不会被扣除，李四也不会收到钱

### 使用场景

-   转账操作
-   多表关联操作（如订单和订单明细）
-   批量更新操作
-   需要保证数据一致性的操作

### 注意事项

-   事务要尽量短，不要在事务中执行耗时操作
-   出错时立即 `ROLLBACK`，成功时再 `COMMIT`
-   数据库默认开启自动提交（autocommit），`START TRANSACTION` 会临时关闭自动提交
