## Foreign Key 外键

### 定义

外键（Foreign Key）是用于建立两个表之间关联关系的字段，它引用另一个表的主键。

### 作用

1. **数据完整性**：确保引用的数据必须存在，防止插入无效数据
2. **关联关系**：明确表与表之间的关联关系
3. **级联操作**：可以设置级联删除或更新

### 语法

```sql
-- 创建表时添加外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 或者使用命名外键
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL
);

-- 订单表（包含外键）
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**说明**：

-   `orders.user_id` 是外键，引用 `users.user_id`（主键）
-   插入订单时，`user_id` 必须在 `users` 表中存在，否则会报错
-   删除用户时，如果该用户有订单，默认会阻止删除（除非设置级联删除）

### 级联操作

```sql
-- 级联删除：删除用户时，自动删除该用户的所有订单
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE

-- 级联更新：更新用户ID时，自动更新订单中的user_id
FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE

-- 设置为NULL：删除用户时，订单的user_id设为NULL（需要字段允许NULL）
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL
```

---

## Index 索引

### 定义

索引（Index）是数据库中用于快速查找数据的数据结构，类似于书籍的目录。

### 作用

1. **提高查询速度**：快速定位数据，避免全表扫描
2. **加速排序**：ORDER BY 操作更快
3. **加速连接**：JOIN 操作更快

### 索引类型

1. **普通索引（INDEX）**：最基本的索引，允许重复值
2. **唯一索引（UNIQUE INDEX）**：不允许重复值
3. **主键索引（PRIMARY KEY）**：特殊的唯一索引，不允许 NULL
4. **全文索引（FULLTEXT）**：用于全文搜索
5. **复合索引**：多个字段组成的索引

### 语法

```sql
-- 创建表时添加索引
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_username_email (username, email)  -- 复合索引
);

-- 创建表后添加索引
CREATE INDEX idx_username ON users(username);

-- 删除索引
DROP INDEX idx_username ON users;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 主键自动创建索引
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    created_at TIMESTAMP,
    INDEX idx_username (username),              -- 普通索引
    INDEX idx_email (email),                    -- 普通索引
    INDEX idx_created_at (created_at),          -- 时间索引
    INDEX idx_username_email (username, email)  -- 复合索引
);
```

**查询优化示例**：

```sql
-- 使用索引：WHERE username = '张三'（username有索引）
SELECT * FROM users WHERE username = '张三';  -- 快速查询

-- 不使用索引：WHERE phone = '13800138000'（phone没有索引）
SELECT * FROM users WHERE phone = '13800138000';  -- 全表扫描，慢

-- 复合索引：WHERE username = '张三' AND email = 'zhangsan@example.com'
SELECT * FROM users WHERE username = '张三' AND email = 'zhangsan@example.com';
-- 可以使用 idx_username_email 复合索引
```

### 索引设计原则

1. **经常查询的字段**：WHERE、JOIN、ORDER BY 的字段
2. **选择性高的字段**：字段值重复度低（如用户名、邮箱）
3. **不要过度索引**：索引会占用存储空间，影响写入性能
4. **外键字段**：必须创建索引

---

## Unique Key 唯一键

### 定义

唯一键（Unique Key）确保字段或字段组合的值在表中唯一，不允许重复。

### 作用

1. **数据唯一性**：确保某个字段的值不重复
2. **业务约束**：如用户名、邮箱、手机号等必须唯一
3. **自动创建索引**：唯一键会自动创建唯一索引

### 与主键的区别

| 特性     | 主键（Primary Key） | 唯一键（Unique Key）              |
| -------- | ------------------- | --------------------------------- |
| 唯一性   | ✅ 必须唯一         | ✅ 必须唯一                       |
| NULL 值  | ❌ 不允许 NULL      | ✅ 允许 NULL（但只能有一个 NULL） |
| 数量限制 | 1 个                | 可以有多个                        |
| 用途     | 标识记录            | 业务唯一性约束                    |

### 语法

```sql
-- 创建表时添加唯一键
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,              -- 方式1：字段级
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),              -- 方式2：表级命名
    UNIQUE KEY uk_phone (phone),
    UNIQUE KEY uk_email_phone (email, phone)  -- 复合唯一键
);

-- 创建表后添加唯一键
ALTER TABLE users ADD UNIQUE KEY uk_email (email);

-- 删除唯一键
ALTER TABLE users DROP INDEX uk_email;
```

### 示例

```sql
-- 用户表
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 用户名唯一
    email VARCHAR(100) UNIQUE NOT NULL,        -- 邮箱唯一
    phone VARCHAR(20) UNIQUE,                  -- 手机号唯一（允许NULL）
    id_card VARCHAR(18) UNIQUE                 -- 身份证号唯一
);
```

**插入数据示例**：

```sql
-- ✅ 成功：所有字段都唯一
INSERT INTO users (username, email, phone) VALUES ('张三', 'zhangsan@example.com', '13800138000');

-- ❌ 失败：用户名重复
INSERT INTO users (username, email, phone) VALUES ('张三', 'lisi@example.com', '13800138001');
-- 错误：Duplicate entry '张三' for key 'username'

-- ✅ 成功：phone 可以为 NULL，且多个 NULL 不冲突
INSERT INTO users (username, email, phone) VALUES ('李四', 'lisi@example.com', NULL);
INSERT INTO users (username, email, phone) VALUES ('王五', 'wangwu@example.com', NULL);
```

### 复合唯一键

```sql
-- 订单明细表：同一订单同一商品只能有一条记录
CREATE TABLE order_items (
    item_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    UNIQUE KEY uk_order_product (order_id, product_id)  -- 订单+商品组合唯一
);
```

**说明**：

-   `order_id` 和 `product_id` 的组合必须唯一
-   同一个订单可以有不同的商品
-   同一个订单不能有重复的商品

## join on 的作用

```sql
SELECT u.* FROM users u
JOIN follows f ON u.user_id = f.following_id
WHERE f.follower_id = ?;
```

### JOIN ON 解释

`JOIN ON` 用于将两个表连接在一起，`ON` 后面指定连接条件。

**这段 SQL 的执行过程：**

1. `JOIN follows f` - 将 `users` 表和 `follows` 表连接
2. `ON u.user_id = f.following_id` - 连接条件：users 表的 user_id 等于 follows 表的 following_id
3. `WHERE f.follower_id = ?` - 过滤条件：只取指定用户关注的记录

#### 真实数据示例

**users 表数据：**

| user_id | username |
| ------- | -------- |
| 1       | 张三     |
| 2       | 李四     |
| 3       | 王五     |
| 4       | 赵六     |

**follows 表数据：**

| follow_id | follower_id | following_id |
| --------- | ----------- | ------------ |
| 1         | 1           | 2            |
| 2         | 1           | 3            |
| 3         | 2           | 1            |
| 4         | 3           | 1            |
| 5         | 3           | 2            |

**JOIN 后的连接结果（ON u.user_id = f.following_id）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |
| 1       | 张三     | 3         | 2           | 1            |
| 1       | 张三     | 4         | 3           | 1            |
| 2       | 李四     | 5         | 3           | 2            |

**加上 WHERE f.follower_id = 1 后的结果（查询张三关注了谁）：**

| user_id | username | follow_id | follower_id | following_id |
| ------- | -------- | --------- | ----------- | ------------ |
| 2       | 李四     | 1         | 1           | 2            |
| 3       | 王五     | 2         | 1           | 3            |

## 事务语句

### 作用

-   **BEGIN / START TRANSACTION**：开始一个事务，将后续的 SQL 操作组合成一个整体
-   **COMMIT**：提交事务，使所有更改永久生效
-   **ROLLBACK**：回滚事务，撤销所有未提交的更改

**核心作用**：确保一组 SQL 操作要么全部成功，要么全部失败，保证数据一致性。

### 语法

```sql
START TRANSACTION;  -- 或 BEGIN
-- SQL 语句1
-- SQL 语句2
COMMIT;  -- 提交事务
-- 或
ROLLBACK;  -- 回滚事务
```

### 示例：转账操作

```sql
-- ❌ 不使用事务（危险）
UPDATE accounts SET balance = balance - 200 WHERE username = '张三';
UPDATE accounts SET balance = balance + 200 WHERE username = '李四';
-- 如果第二步失败，张三的钱扣了，但李四没收到

-- ✅ 使用事务（安全）
START TRANSACTION;
UPDATE accounts SET balance = balance - 200 WHERE username = '张三';
UPDATE accounts SET balance = balance + 200 WHERE username = '李四';
COMMIT;  -- 成功时提交
-- ROLLBACK;  -- 失败时回滚
```

### 示例：回滚操作

```sql
-- 转账操作，如果出错则回滚
START TRANSACTION;

UPDATE accounts SET balance = balance - 500 WHERE username = '张三';
UPDATE accounts SET balance = balance + 500 WHERE username = '李四';

-- 如果任何操作失败（如余额不足、用户不存在等），执行回滚
-- 在应用程序中通常这样处理：
-- try {
--    执行 SQL 操作
--    COMMIT;  -- 成功时提交
-- } catch (error) {
--    ROLLBACK;  -- 失败时回滚
-- }

-- 手动回滚示例
ROLLBACK;  -- 撤销上面的所有更改，数据库恢复到事务开始前的状态
```

**回滚效果**：

-   执行 `ROLLBACK` 后，事务中的所有更改都会被撤销
-   数据库恢复到 `START TRANSACTION` 之前的状态
-   例如：如果转账过程中出错，张三的余额不会被扣除，李四也不会收到钱

### 使用场景

-   转账操作
-   多表关联操作（如订单和订单明细）
-   批量更新操作
-   需要保证数据一致性的操作

### 注意事项

-   事务要尽量短，不要在事务中执行耗时操作
-   出错时立即 `ROLLBACK`，成功时再 `COMMIT`
-   数据库默认开启自动提交（autocommit），`START TRANSACTION` 会临时关闭自动提交

## 数据库字典

### 定义

数据库字典（Data Dictionary）是数据库系统中存储元数据（Metadata）的地方，包含表结构、字段信息、索引信息、约束信息等系统级信息。

### 作用

1. **元数据管理**：存储数据库对象的定义和结构信息
2. **系统查询**：提供系统表供用户查询数据库结构
3. **权限管理**：存储用户权限和角色信息
4. **性能优化**：MySQL 8.0 将数据字典存储在 InnoDB 表中，提高查询性能

### MySQL 8.0 数据字典改进

**MySQL 8.0 之前**：

-   数据字典存储在 `.frm` 文件中（文件系统）
-   元数据查询需要读取文件，性能较差
-   不支持事务性 DDL

**MySQL 8.0 之后**：

-   数据字典存储在 InnoDB 表中（`mysql` 数据库）
-   支持事务性 DDL（原子性操作）
-   元数据查询性能大幅提升
-   统一的数据字典存储

### 常用系统表

#### information_schema 数据库

```sql
-- 查看所有表
SELECT * FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'your_database';

-- 查看表结构
SELECT * FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'your_database' AND TABLE_NAME = 'users';

-- 查看索引信息
SELECT * FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_database' AND TABLE_NAME = 'users';

-- 查看外键信息
SELECT * FROM information_schema.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'your_database' AND TABLE_NAME = 'orders';
```

#### mysql 数据库（系统表）

```sql
-- 查看用户信息
SELECT * FROM mysql.user;

-- 查看数据库信息
SELECT * FROM mysql.db;

-- 查看表权限
SELECT * FROM mysql.tables_priv;
```

### 实际应用示例

```sql
-- 1. 查询数据库中的所有表
SELECT TABLE_NAME, TABLE_ROWS, DATA_LENGTH, INDEX_LENGTH
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'my_database'
ORDER BY TABLE_ROWS DESC;

-- 2. 查询表的字段信息
SELECT
    COLUMN_NAME,
    DATA_TYPE,
    IS_NULLABLE,
    COLUMN_DEFAULT,
    COLUMN_COMMENT
FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'my_database'
  AND TABLE_NAME = 'users'
ORDER BY ORDINAL_POSITION;

-- 3. 查询表的索引信息
SELECT
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,
    NON_UNIQUE
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'my_database'
  AND TABLE_NAME = 'users'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;

-- 4. 查询外键约束
SELECT
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM information_schema.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'my_database'
  AND REFERENCED_TABLE_NAME IS NOT NULL;
```

### 使用场景

1. **数据库文档生成**：自动生成数据库结构文档
2. **数据迁移**：导出表结构和约束信息
3. **性能分析**：查询表大小、索引使用情况
4. **权限管理**：查看用户权限配置
5. **开发工具**：IDE 和数据库管理工具通过数据字典显示表结构

---

## 虚拟列索引

### 定义

虚拟列索引（Generated Column Index）是在虚拟列（Generated Column，也称为计算列）上创建的索引。虚拟列的值是通过表达式计算得出的，不存储在表中（VIRTUAL）或存储在表中（STORED）。

### 虚拟列类型

1. **VIRTUAL（虚拟列）**：

    - 值不存储在磁盘上，每次查询时计算
    - 不占用存储空间
    - 读取时需要计算，写入时不需要存储

2. **STORED（存储列）**：
    - 值存储在磁盘上
    - 占用存储空间
    - 读取速度快，写入时需要计算和存储

### 作用

1. **函数索引**：在函数表达式上创建索引（MySQL 5.7+）
2. **JSON 字段索引**：为 JSON 字段的特定路径创建索引
3. **表达式查询优化**：优化包含表达式的 WHERE 条件查询
4. **数据规范化**：从复杂字段中提取常用查询字段

### 语法

```sql
-- 创建虚拟列
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10,2),
    discount DECIMAL(5,2),
    -- VIRTUAL 虚拟列：不存储，每次查询时计算
    final_price DECIMAL(10,2) AS (price * (1 - discount / 100)) VIRTUAL,
    -- STORED 存储列：存储值，占用空间
    price_category VARCHAR(20) AS (
        CASE
            WHEN price < 100 THEN 'low'
            WHEN price < 500 THEN 'medium'
            ELSE 'high'
        END
    ) STORED,
    -- 在虚拟列上创建索引
    INDEX idx_final_price (final_price),
    INDEX idx_price_category (price_category)
);
```

### 示例

#### 示例 1：函数索引（优化表达式查询）

```sql
-- 问题：无法直接在函数表达式上创建索引
-- SELECT * FROM users WHERE UPPER(username) = 'ZHANGSAN';
-- 这个查询无法使用 username 上的索引

-- 解决方案：使用虚拟列
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    -- 创建大写的虚拟列
    username_upper VARCHAR(50) AS (UPPER(username)) VIRTUAL,
    -- 在虚拟列上创建索引
    INDEX idx_username_upper (username_upper)
);

-- 现在可以使用索引
SELECT * FROM users WHERE username_upper = 'ZHANGSAN';
```

#### 示例 2：JSON 字段索引

```sql
-- 商品表，包含 JSON 格式的属性
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    attributes JSON,
    -- 从 JSON 中提取品牌字段作为虚拟列
    brand VARCHAR(50) AS (JSON_UNQUOTE(JSON_EXTRACT(attributes, '$.brand'))) VIRTUAL,
    -- 在虚拟列上创建索引
    INDEX idx_brand (brand)
);

-- 插入数据
INSERT INTO products (name, attributes) VALUES
('手机', '{"brand": "Apple", "color": "black", "storage": "128GB"}'),
('手机', '{"brand": "Samsung", "color": "white", "storage": "256GB"}');

-- 查询时可以使用索引
SELECT * FROM products WHERE brand = 'Apple';
```

#### 示例 3：日期函数索引

```sql
-- 订单表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    created_at TIMESTAMP,
    -- 提取年份作为虚拟列
    order_year INT AS (YEAR(created_at)) VIRTUAL,
    -- 提取月份作为虚拟列
    order_month INT AS (MONTH(created_at)) VIRTUAL,
    -- 在虚拟列上创建索引
    INDEX idx_order_year (order_year),
    INDEX idx_order_year_month (order_year, order_month)
);

-- 查询时可以使用索引
SELECT * FROM orders WHERE order_year = 2024;
SELECT * FROM orders WHERE order_year = 2024 AND order_month = 1;
```

#### 示例 4：字符串拼接索引

```sql
-- 用户表
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    -- 全名虚拟列
    full_name VARCHAR(101) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    -- 在虚拟列上创建索引
    INDEX idx_full_name (full_name)
);

-- 查询时可以使用索引
SELECT * FROM users WHERE full_name = '张三 李四';
```

### 虚拟列索引的优势

1. **支持函数索引**：MySQL 5.7 之前不支持函数索引，虚拟列解决了这个问题
2. **JSON 查询优化**：为 JSON 字段的特定路径创建索引，提高查询性能
3. **表达式查询优化**：优化包含表达式的 WHERE 条件
4. **向后兼容**：不影响现有查询，可以逐步迁移

### 虚拟列索引的限制

1. **VIRTUAL 列的限制**：

    - 不能作为外键
    - 不能作为分区键
    - 某些存储引擎不支持

2. **STORED 列的限制**：

    - 占用存储空间
    - 写入时需要计算和存储，影响写入性能

3. **表达式限制**：
    - 必须是确定性的（相同输入产生相同输出）
    - 不能使用子查询
    - 不能使用变量或函数参数

### 使用场景

1. **JSON 字段查询**：为 JSON 字段的常用路径创建索引
2. **函数表达式查询**：优化包含函数的 WHERE 条件
3. **日期范围查询**：提取年月日等字段创建索引
4. **字符串处理**：为大写、小写、拼接等操作创建索引
5. **计算字段查询**：为计算得出的字段创建索引

### 注意事项

1. **性能权衡**：

    - VIRTUAL 列：节省存储空间，但读取时需要计算
    - STORED 列：读取快，但占用存储空间，写入慢

2. **索引维护**：

    - 虚拟列索引需要维护，会影响写入性能
    - 只在经常查询的虚拟列上创建索引

3. **表达式复杂度**：
    - 避免使用过于复杂的表达式
    - 确保表达式是确定性的

## 分区表

### 定义

分区表（Partition Table）是将一个大表按照某种规则分割成多个物理存储的小表，但在逻辑上仍然是一个表。每个分区可以独立存储和管理，提高查询性能和管理效率。

### 作用与优势

1. **提升查询性能**：

    - 查询时只需要扫描相关分区，减少数据扫描量
    - 分区剪枝（Partition Pruning）自动过滤不相关的分区
    - 并行查询可以在不同分区上同时执行

2. **便于数据管理**：

    - 可以单独对某个分区进行维护、备份、恢复
    - 删除旧数据时可以直接删除整个分区，速度快
    - 可以针对不同分区设置不同的存储策略

3. **提高可用性**：

    - 某个分区损坏不影响其他分区
    - 可以独立恢复某个分区

4. **优化存储**：
    - 可以将不同分区存储在不同的磁盘上
    - 冷热数据分离，优化存储成本

### 分区类型

#### 1. 范围分区（RANGE Partitioning）

按照某个字段的值范围进行分区，常用于日期、数值等有序字段。

```sql
-- 按年份范围分区
CREATE TABLE sales (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

#### 2. 列表分区（LIST Partitioning）

按照某个字段的离散值列表进行分区，常用于地区、状态等枚举值。

```sql
-- 按地区列表分区
CREATE TABLE users (
    id INT,
    username VARCHAR(50),
    region VARCHAR(20)
) PARTITION BY LIST (region) (
    PARTITION p_north VALUES IN ('北京', '天津', '河北'),
    PARTITION p_south VALUES IN ('广东', '广西', '海南'),
    PARTITION p_east VALUES IN ('上海', '江苏', '浙江'),
    PARTITION p_west VALUES IN ('四川', '重庆', '云南')
);
```

#### 3. 哈希分区（HASH Partitioning）

根据哈希函数将数据均匀分布到各个分区，确保数据分布均匀。

```sql
-- 按用户ID哈希分区
CREATE TABLE orders (
    order_id INT,
    user_id INT,
    amount DECIMAL(10,2)
) PARTITION BY HASH(user_id) PARTITIONS 4;
```

#### 4. 键分区（KEY Partitioning）

类似于哈希分区，但使用 MySQL 内置的哈希函数，只能用于整数类型或 NULL。

```sql
-- 按键分区
CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    content TEXT,
    created_at DATETIME
) PARTITION BY KEY(id) PARTITIONS 8;
```

#### 5. 复合分区

结合多种分区方式，先进行一级分区，再进行二级分区。

```sql
-- 先按范围分区，再按哈希分区
CREATE TABLE sales_detail (
    id INT,
    sale_date DATE,
    product_id INT,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(sale_date))
SUBPARTITION BY HASH(product_id) SUBPARTITIONS 4 (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN MAXVALUE
);
```

### 分区管理操作

#### 添加分区

```sql
-- 范围分区：添加新分区
ALTER TABLE sales ADD PARTITION (
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 列表分区：添加新分区
ALTER TABLE users ADD PARTITION (
    PARTITION p_central VALUES IN ('湖北', '湖南', '河南')
);
```

#### 删除分区

```sql
-- 删除分区（会删除分区中的所有数据）
ALTER TABLE sales DROP PARTITION p2020;

-- 删除分区但保留数据（需要先合并数据）
ALTER TABLE sales TRUNCATE PARTITION p2020;
```

#### 合并分区

```sql
-- 合并两个相邻的分区
ALTER TABLE sales REORGANIZE PARTITION p2020, p2021 INTO (
    PARTITION p2020_2021 VALUES LESS THAN (2022)
);
```

#### 拆分分区

```sql
-- 拆分一个分区
ALTER TABLE sales REORGANIZE PARTITION pmax INTO (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

### 使用场景

1. **时间序列数据**：

    - 日志表、订单表、交易记录表
    - 按年、月、日分区，便于历史数据归档

2. **大数据量表**：

    - 单表数据量超过千万级别
    - 需要提高查询性能和管理效率

3. **数据归档**：

    - 定期删除或归档历史数据
    - 可以直接删除整个分区，速度快

4. **地理分布数据**：

    - 按地区、国家等维度分区
    - 便于按地区查询和管理

5. **负载均衡**：
    - 将数据分散到多个分区
    - 提高并发处理能力

### 注意事项

1. **分区键选择**：

    - 分区键必须是主键或唯一键的一部分
    - 选择查询条件中经常使用的字段
    - 避免选择频繁更新的字段

2. **分区数量**：

    - 分区数量不宜过多（建议不超过 100 个）
    - 过多分区会增加元数据管理开销
    - 每个分区至少要有一定数据量

3. **查询优化**：

    - WHERE 条件中尽量包含分区键
    - 避免跨分区的全表扫描
    - 使用 EXPLAIN 查看分区剪枝是否生效

4. **索引策略**：

    - 每个分区都有独立的索引
    - 全局索引和本地索引的选择
    - 分区键上的索引通常不需要

5. **事务和外键**：

    - 分区表不支持外键约束
    - 跨分区的事务性能可能受影响

6. **存储引擎限制**：
    - 分区表通常使用 InnoDB 存储引擎
    - 某些存储引擎可能不支持分区

### 示例：日志表分区实践

```sql
-- 创建按月分区的日志表
CREATE TABLE app_logs (
    id BIGINT AUTO_INCREMENT,
    log_time DATETIME NOT NULL,
    level VARCHAR(10),
    message TEXT,
    PRIMARY KEY (id, log_time)
) PARTITION BY RANGE (TO_DAYS(log_time)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    PARTITION p202403 VALUES LESS THAN (TO_DAYS('2024-04-01')),
    PARTITION p202404 VALUES LESS THAN (TO_DAYS('2024-05-01')),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);

-- 查询特定月份的数据（只扫描对应分区）
SELECT * FROM app_logs
WHERE log_time >= '2024-02-01' AND log_time < '2024-03-01';

-- 删除旧数据（直接删除分区）
ALTER TABLE app_logs DROP PARTITION p202401;
```

### 分区剪枝（Partition Pruning）

分区剪枝是 MySQL 自动优化技术，查询时自动排除不相关的分区，只扫描需要的分区。

```sql
-- 查询时自动只扫描 p202402 分区
EXPLAIN PARTITIONS
SELECT * FROM app_logs
WHERE log_time >= '2024-02-15' AND log_time < '2024-02-20';

-- 查看分区使用情况
SELECT
    PARTITION_NAME,
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'app_logs';
```
