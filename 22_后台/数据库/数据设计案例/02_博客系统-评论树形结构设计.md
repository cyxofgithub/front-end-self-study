# 案例 2：博客系统 - 评论树形结构设计

## 需求场景

用户可以对文章评论，也可以回复评论，形成多级评论树。需要支持：

-   显示所有评论（按时间排序）
-   显示某个评论的所有回复
-   统计评论总数

## 第一次设计（错误）

```sql
CREATE TABLE comments (
    comment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    article_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    parent_comment_id BIGINT,  -- 父评论ID，NULL表示顶级评论
    FOREIGN KEY (parent_comment_id) REFERENCES comments(comment_id) -- 自引用外键，指向同一张表的主键，用于实现父子关系
);
```

**问题 1**：查询某个评论的所有子评论需要递归查询，性能差
**问题 2**：统计评论总数需要遍历整棵树

## 设计思路

**方案对比**：

1. **邻接表（Adjacency List）**：只存 `parent_id`

    - 优点：结构简单
    - 缺点：查询子树需要递归，性能差

2. **路径枚举（Path Enumeration）**：存完整路径 `1/2/3`

    - 优点：查询子树快
    - 缺点：路径长度有限，移动节点困难

3. **闭包表（Closure Table）**：单独存所有祖先-后代关系
    - 优点：查询快，支持任意深度
    - 缺点：存储空间大，写入复杂

**选择**：对于评论系统，层级不会太深（通常 2-3 层），使用**邻接表 + 冗余字段**优化。

## 最终设计

```sql
CREATE TABLE comments (
    comment_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    article_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    parent_id BIGINT DEFAULT 0 COMMENT '0表示顶级评论，否则为父评论ID',
    content TEXT NOT NULL,
    level TINYINT DEFAULT 1 COMMENT '层级：1=顶级，2=一级回复，3=二级回复',
    path VARCHAR(500) COMMENT '路径：如 1/2/3，便于查询子树',
    like_count INT DEFAULT 0,
    reply_count INT DEFAULT 0 COMMENT '回复数，避免递归统计',
    status TINYINT DEFAULT 1 COMMENT '1:正常 2:已删除',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (article_id) REFERENCES articles(article_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_article_id (article_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_path (path(255)) COMMENT '前缀索引，支持LIKE查询'
);
```

## 真实数据

| comment_id | parent_id | level | path    | content    | reply_count | 说明                               |
| ---------- | --------- | ----- | ------- | ---------- | ----------- | ---------------------------------- |
| 1          | 0         | 1     | `1`     | 顶级评论 1 | 2           | 顶级评论，path 就是自己的 ID       |
| 2          | 1         | 2     | `1/2`   | 回复评论 1 | 1           | 一级回复，path 是父 path + 自己 ID |
| 3          | 2         | 3     | `1/2/3` | 回复评论 2 | 0           | 二级回复，形成三级嵌套             |
| 4          | 1         | 2     | `1/4`   | 回复评论 1 | 0           | 评论 1 的另一个一级回复            |
| 5          | 0         | 1     | `5`     | 顶级评论 2 | 1           | 另一个顶级评论                     |
| 6          | 5         | 2     | `5/6`   | 回复评论 5 | 0           | 评论 5 的一级回复                  |
| 7          | 0         | 1     | `7`     | 顶级评论 3 | 0           | 第三个顶级评论                     |

**树形结构可视化**：

```
文章1 (article_id = 1)
├── 评论1 (comment_id=1, path=1) - "这篇文章写得真好，学到了很多！"
│   ├── 回复2 (comment_id=2, path=1/2) - "同感！特别是关于数据库设计的部分"
│   │   └── 回复3 (comment_id=3, path=1/2/3) - "是的，快照设计很实用"
│   └── 回复4 (comment_id=4, path=1/4) - "希望能有更多实战案例"
├── 评论5 (comment_id=5, path=5) - "有个问题想请教：如何处理深层嵌套的评论？"
│   └── 回复6 (comment_id=6, path=5/6) - "可以使用路径枚举，path字段很方便"
└── 评论7 (comment_id=7, path=7) - "感谢分享，收藏了！"
```

**查询示例**：

```sql
-- 查询评论1的所有子评论（包括回复2、3、4）
SELECT * FROM comments
WHERE path LIKE '1/%' OR comment_id = 1
ORDER BY path;

-- 结果：comment_id = 1, 2, 3, 4

-- 查询评论1的直接回复（不包括二级回复）
SELECT * FROM comments
WHERE parent_id = 1;

-- 结果：comment_id = 2, 4

-- 查询所有顶级评论
SELECT * FROM comments
WHERE article_id = 1 AND parent_id = 0
ORDER BY created_at DESC;

-- 结果：comment_id = 7, 5, 1（按时间倒序）
```

## 设计要点

1. **parent_id 使用 0 而非 NULL**：避免 NULL 值带来的查询复杂性
2. **冗余 level 字段**：快速判断评论层级，便于前端展示
3. **冗余 path 字段**：快速查询某个评论的所有子评论
4. **冗余 reply_count**：避免递归统计回复数

## 实际应用

```sql
-- 查询文章的所有顶级评论
SELECT * FROM comments
WHERE article_id = ? AND parent_id = 0
ORDER BY created_at DESC;

-- 查询某个评论的所有回复（利用path）
SELECT * FROM comments
WHERE path LIKE CONCAT((SELECT path FROM comments WHERE comment_id = ?), '/%')
ORDER BY created_at ASC;

-- 添加回复时，更新path和level
INSERT INTO comments (article_id, user_id, parent_id, content, level, path)
SELECT
    ? as article_id,
    ? as user_id,
    ? as parent_id,
    ? as content,
    level + 1,
    CONCAT(path, '/', LAST_INSERT_ID())
FROM comments
WHERE comment_id = ?;
```

## 掌握能力

学习完这个案例，你将掌握：

1. **树形结构设计**：理解邻接表、路径枚举、闭包表三种树形结构设计方案的优缺点
2. **方案选择能力**：能够根据业务场景（层级深度、查询频率）选择最合适的树形结构设计方案
3. **性能优化技巧**：学会使用冗余字段（`level`、`path`、`reply_count`）优化查询性能
4. **路径查询优化**：掌握使用 `path LIKE` 查询子树，避免递归查询
5. **NULL vs 0 的选择**：理解为什么在某些场景下使用 0 而非 NULL 更合适

**应用场景**：评论系统、组织架构、分类树、菜单树、权限树、任何树形结构数据

