# 案例 5：任务管理系统 - 状态流转设计

## 需求场景

任务有多种状态：待处理、进行中、已完成、已取消。需要：

-   记录状态变更历史
-   支持状态流转规则（如：已完成不能变回待处理）
-   查询任务当前状态和历史状态

## 第一次设计（错误）

```sql
CREATE TABLE tasks (
    task_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' COMMENT 'pending/in_progress/completed/cancelled',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**问题**：

1. 无法查询状态变更历史
2. 无法知道状态变更时间和操作人
3. 状态值使用字符串，容易拼写错误

## 设计思路

**核心问题**：需要同时记录当前状态和历史状态。

**解决方案**：

1. 任务表记录当前状态
2. 状态变更历史表记录所有变更记录
3. 使用状态码而非字符串

## 最终设计

```sql
-- 1. 任务表（记录当前状态）
CREATE TABLE tasks (
    task_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    assignee_id BIGINT COMMENT '负责人ID',
    status TINYINT DEFAULT 1 COMMENT '1:待处理 2:进行中 3:已完成 4:已取消',
    priority TINYINT DEFAULT 2 COMMENT '1:低 2:中 3:高',
    due_date DATE COMMENT '截止日期',
    created_by BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_assignee_id (assignee_id),
    INDEX idx_status (status),
    INDEX idx_due_date (due_date)
);

-- 2. 任务状态变更历史表
CREATE TABLE task_status_history (
    history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_id BIGINT NOT NULL,
    from_status TINYINT COMMENT '原状态，NULL表示创建',
    to_status TINYINT NOT NULL COMMENT '新状态',
    operator_id BIGINT NOT NULL COMMENT '操作人ID',
    remark VARCHAR(500) COMMENT '备注',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(task_id) ON DELETE CASCADE,
    INDEX idx_task_id (task_id),
    INDEX idx_created_at (created_at)
);
```

## 设计要点

1. **状态码设计**：使用 `TINYINT` 而非 `VARCHAR`，节省空间且避免拼写错误
2. **历史表设计**：记录 `from_status` 和 `to_status`，形成完整的状态流转链
3. **操作人记录**：记录每次状态变更的操作人，便于追溯

## 实际应用

```sql
-- 更新任务状态（需要同时更新任务表和历史表）
BEGIN;

-- 更新任务状态
UPDATE tasks
SET status = ?, updated_at = NOW()
WHERE task_id = ?;

-- 记录状态变更历史
INSERT INTO task_status_history (task_id, from_status, to_status, operator_id, remark)
SELECT status, ?, ?, ?
FROM tasks
WHERE task_id = ?;

COMMIT;

-- 查询任务的状态流转历史
-- 使用多表 JOIN 查询状态变更历史，并关联出操作人姓名和状态名称
-- LEFT JOIN 确保即使关联数据不存在也能返回历史记录
SELECT
    tsh.*,                                    -- 历史表所有字段
    u1.username as operator_name,             -- 操作人姓名（从 users 表获取）
    s1.status_name as from_status_name,       -- 原状态名称（从状态字典获取）
    s2.status_name as to_status_name          -- 新状态名称（从状态字典获取）
FROM task_status_history tsh
LEFT JOIN users u1 ON tsh.operator_id = u1.user_id         -- 关联用户表，获取操作人信息
LEFT JOIN status_dict s1 ON tsh.from_status = s1.status_code  -- 关联状态字典，获取原状态名称
LEFT JOIN status_dict s2 ON tsh.to_status = s2.status_code    -- 关联状态字典，获取新状态名称
WHERE tsh.task_id = ?                         -- 过滤指定任务的历史记录
ORDER BY tsh.created_at ASC;                  -- 按时间升序，展示完整的状态流转过程
```

## 掌握能力

学习完这个案例，你将掌握：

1. **状态流转设计**：理解如何设计状态字段，使用状态码而非字符串
2. **历史记录设计**：掌握如何设计历史表记录完整的状态变更链
3. **审计追溯能力**：学会记录操作人、操作时间等信息，便于问题追溯
4. **事务处理**：理解更新状态时需要同时更新主表和历史表，使用事务保证一致性
5. **状态码设计**：掌握使用 `TINYINT` 存储状态码，节省空间且避免拼写错误

**应用场景**：任务管理、工单系统、审批流程、订单状态、任何有状态流转的业务场景

