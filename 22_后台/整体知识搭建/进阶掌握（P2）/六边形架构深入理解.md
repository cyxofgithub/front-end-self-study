## 六边形架构深入理解

### 1. 六边形架构基本概念

**六边形架构（Hexagonal Architecture）**：也称为端口适配器模式（Ports and Adapters Pattern），由 Alistair Cockburn 在 2005 年提出。

**核心思想：**

-   将业务逻辑与外部依赖隔离
-   通过端口（Port）定义接口，适配器（Adapter）实现具体技术细节
-   业务逻辑位于架构中心，不依赖任何外部框架或技术

**架构优势：**

-   **可测试性**：业务逻辑可以独立测试，无需启动数据库、Web 服务器等
-   **可替换性**：可以轻松替换数据库、Web 框架、消息队列等外部依赖
-   **业务聚焦**：业务逻辑清晰，不受技术细节干扰
-   **解耦合**：业务层与技术层完全解耦

### 2. 架构层次结构

```
┌─────────────────────────────────────────┐
│         适配器层 (Adapters)              │
│  ┌──────────┐      ┌──────────┐        │
│  │ Web适配器 │      │ DB适配器  │        │
│  └────┬─────┘      └────┬─────┘        │
│       │                 │              │
│       └────────┬────────┘              │
│                │                       │
│          ┌─────▼─────┐                 │
│          │  端口层    │                 │
│          │  (Ports)  │                 │
│          └─────┬─────┘                 │
│                │                       │
│          ┌─────▼─────┐                 │
│          │  应用层    │                 │
│          │ (Application)               │
│          └─────┬─────┘                 │
│                │                       │
│          ┌─────▼─────┐                 │
│          │  领域层    │                 │
│          │  (Domain)  │                 │
│          └───────────┘                 │
└─────────────────────────────────────────┘
```

**核心层次：**

1. **领域层（Domain Layer）**：业务逻辑核心，包含实体、值对象、领域服务
2. **应用层（Application Layer）**：用例编排，协调领域对象完成业务场景
3. **端口层（Ports）**：定义接口契约，分为驱动端口和驱动端口
4. **适配器层（Adapters）**：实现端口接口，处理具体技术细节

### 3. 端口（Ports）类型

#### 3.1 驱动端口（Driving Ports / Inbound Ports）

**定义**：应用对外提供的接口，定义应用能做什么。

**常见类型：**

-   REST API 接口
-   GraphQL 接口
-   消息队列消费者接口
-   命令行接口

**示例：**

```java
// 驱动端口：定义用户服务接口
public interface UserServicePort {
    User createUser(CreateUserCommand command);
    User getUserById(Long id);
    void updateUser(UpdateUserCommand command);
    void deleteUser(Long id);
}
```

#### 3.2 被驱动端口（Driven Ports / Outbound Ports）

**定义**：应用依赖的外部服务接口，定义应用需要什么。

**常见类型：**

-   数据库仓储接口
-   外部 API 客户端接口
-   消息队列发布接口
-   文件存储接口

**示例：**

```java
// 被驱动端口：定义用户仓储接口
public interface UserRepositoryPort {
    User save(User user);
    Optional<User> findById(Long id);
    List<User> findAll();
    void deleteById(Long id);
}
```

### 4. 适配器（Adapters）实现

#### 4.1 驱动适配器（Driving Adapters / Inbound Adapters）

**作用**：将外部请求转换为应用层调用。

**示例：REST 控制器适配器**

```java
// 驱动适配器：Spring MVC 控制器
@RestController
@RequestMapping("/api/users")
public class UserControllerAdapter {

    private final UserServicePort userService;

    public UserControllerAdapter(UserServicePort userService) {
        this.userService = userService;
    }

    @PostMapping
    public ResponseEntity<UserDTO> createUser(@RequestBody CreateUserRequest request) {
        // 将 HTTP 请求转换为应用命令
        CreateUserCommand command = new CreateUserCommand(
            request.getUsername(),
            request.getEmail()
        );

        // 调用应用服务
        User user = userService.createUser(command);

        // 将领域对象转换为 DTO
        UserDTO dto = UserDTO.from(user);

        return ResponseEntity.ok(dto);
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return ResponseEntity.ok(UserDTO.from(user));
    }
}
```

#### 4.2 被驱动适配器（Driven Adapters / Outbound Adapters）

**作用**：实现被驱动端口，处理具体技术实现。

**示例：JPA 仓储适配器**

```java
// 被驱动适配器：JPA 实现
@Repository
public class UserJpaRepositoryAdapter implements UserRepositoryPort {

    private final UserJpaRepository jpaRepository;

    public UserJpaRepositoryAdapter(UserJpaRepository jpaRepository) {
        this.jpaRepository = jpaRepository;
    }

    @Override
    public User save(User user) {
        UserEntity entity = UserEntity.from(user);
        UserEntity saved = jpaRepository.save(entity);
        return saved.toDomain();
    }

    @Override
    public Optional<User> findById(Long id) {
        return jpaRepository.findById(id)
            .map(UserEntity::toDomain);
    }

    @Override
    public List<User> findAll() {
        return jpaRepository.findAll().stream()
            .map(UserEntity::toDomain)
            .collect(Collectors.toList());
    }

    @Override
    public void deleteById(Long id) {
        jpaRepository.deleteById(id);
    }
}
```

### 5. 完整示例：用户管理模块

#### 5.1 领域层（Domain）

```java
// 领域实体
public class User {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime createdAt;

    // 业务逻辑方法
    public void changeEmail(String newEmail) {
        if (newEmail == null || !isValidEmail(newEmail)) {
            throw new IllegalArgumentException("Invalid email");
        }
        this.email = newEmail;
    }

    private boolean isValidEmail(String email) {
        return email.contains("@");
    }

    // Getters
    public Long getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }
}
```

#### 5.2 应用层（Application）

```java
// 应用服务
@Service
public class UserApplicationService implements UserServicePort {

    private final UserRepositoryPort userRepository;
    private final EmailServicePort emailService;

    public UserApplicationService(
            UserRepositoryPort userRepository,
            EmailServicePort emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }

    @Override
    public User createUser(CreateUserCommand command) {
        // 业务规则验证
        if (userRepository.existsByUsername(command.getUsername())) {
            throw new UserAlreadyExistsException("Username already exists");
        }

        // 创建领域对象
        User user = new User();
        user.setUsername(command.getUsername());
        user.setEmail(command.getEmail());
        user.setCreatedAt(LocalDateTime.now());

        // 持久化
        User saved = userRepository.save(user);

        // 发送欢迎邮件（异步）
        emailService.sendWelcomeEmail(saved.getEmail());

        return saved;
    }

    @Override
    public User getUserById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("User not found: " + id));
    }

    @Override
    public void updateUser(UpdateUserCommand command) {
        User user = getUserById(command.getId());
        user.changeEmail(command.getEmail());
        userRepository.save(user);
    }

    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

#### 5.3 端口定义

```java
// 驱动端口
public interface UserServicePort {
    User createUser(CreateUserCommand command);
    User getUserById(Long id);
    void updateUser(UpdateUserCommand command);
    void deleteUser(Long id);
}

// 被驱动端口
public interface UserRepositoryPort {
    User save(User user);
    Optional<User> findById(Long id);
    List<User> findAll();
    void deleteById(Long id);
    boolean existsByUsername(String username);
}

public interface EmailServicePort {
    void sendWelcomeEmail(String email);
}
```

#### 5.4 适配器实现

```java
// 驱动适配器：REST API
@RestController
@RequestMapping("/api/users")
public class UserRestControllerAdapter {
    private final UserServicePort userService;
    // ... 实现见上文
}

// 被驱动适配器：JPA 仓储
@Repository
public class UserJpaRepositoryAdapter implements UserRepositoryPort {
    // ... 实现见上文
}

// 被驱动适配器：邮件服务
@Component
public class SmtpEmailServiceAdapter implements EmailServicePort {
    @Override
    public void sendWelcomeEmail(String email) {
        // 使用 SMTP 发送邮件
        // 可以轻松替换为其他邮件服务提供商
    }
}
```

// todo-学习到这里

### 6. 与 DDD 的结合

**六边形架构与 DDD 的完美结合：**

```
┌─────────────────────────────────────┐
│  适配器层 (Adapters)                 │
│  - REST Controllers                 │
│  - JPA Repositories                 │
│  - Message Queue Adapters           │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│  应用层 (Application Layer)          │
│  - Application Services             │
│  - Use Cases                        │
│  - DTOs                             │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│  领域层 (Domain Layer)               │
│  - Entities                         │
│  - Value Objects                    │
│  - Domain Services                  │
│  - Domain Events                    │
└─────────────────────────────────────┘
```

**对应关系：**

-   **领域层** = DDD 的 Domain 层（业务逻辑核心）
-   **应用层** = DDD 的 Application 层（用例编排）
-   **适配器层** = DDD 的 Infrastructure 层（技术实现）

### 7. 依赖方向规则

**核心原则：依赖倒置（Dependency Inversion）**

```
❌ 错误：领域层依赖基础设施
Domain → Infrastructure

✅ 正确：基础设施依赖领域层
Infrastructure → Domain
```

**依赖规则：**

1. **领域层**：不依赖任何其他层，只包含纯业务逻辑
2. **应用层**：依赖领域层，定义端口接口
3. **适配器层**：依赖应用层和领域层，实现端口接口

**示例：**

```java
// ✅ 正确：适配器实现端口接口
@Repository
public class UserJpaRepositoryAdapter implements UserRepositoryPort {
    // 依赖端口接口，不依赖具体实现
}

// ❌ 错误：领域层直接使用 JPA
public class User {
    @Entity  // 不应该在领域层使用 JPA 注解
    private Long id;
}
```

### 8. 测试策略

#### 8.1 领域层测试（单元测试）

```java
@Test
public void testUserChangeEmail() {
    // 纯业务逻辑测试，无需任何框架
    User user = new User();
    user.setEmail("old@example.com");

    user.changeEmail("new@example.com");

    assertEquals("new@example.com", user.getEmail());
}
```

#### 8.2 应用层测试（集成测试）

```java
@Test
public void testCreateUser() {
    // 使用 Mock 适配器
    UserRepositoryPort mockRepository = mock(UserRepositoryPort.class);
    EmailServicePort mockEmailService = mock(EmailServicePort.class);

    UserApplicationService service = new UserApplicationService(
        mockRepository,
        mockEmailService
    );

    CreateUserCommand command = new CreateUserCommand("test", "test@example.com");
    User user = service.createUser(command);

    verify(mockRepository).save(any(User.class));
    verify(mockEmailService).sendWelcomeEmail("test@example.com");
}
```

#### 8.3 适配器测试（集成测试）

```java
@SpringBootTest
@Testcontainers
class UserJpaRepositoryAdapterTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13");

    @Autowired
    private UserJpaRepositoryAdapter adapter;

    @Test
    void testSaveAndFind() {
        User user = new User();
        user.setUsername("test");
        user.setEmail("test@example.com");

        User saved = adapter.save(user);
        Optional<User> found = adapter.findById(saved.getId());

        assertTrue(found.isPresent());
        assertEquals("test", found.get().getUsername());
    }
}
```

### 9. 实际项目结构

**典型的六边形架构项目结构：**

```
src/main/java/com/example/
├── domain/                    # 领域层
│   ├── model/                 # 领域模型
│   │   ├── User.java
│   │   └── Order.java
│   ├── service/               # 领域服务
│   │   └── UserDomainService.java
│   └── event/                 # 领域事件
│       └── UserCreatedEvent.java
│
├── application/               # 应用层
│   ├── service/               # 应用服务
│   │   └── UserApplicationService.java
│   ├── command/               # 命令对象
│   │   └── CreateUserCommand.java
│   └── dto/                   # 数据传输对象
│       └── UserDTO.java
│
├── port/                      # 端口层
│   ├── inbound/               # 驱动端口
│   │   └── UserServicePort.java
│   └── outbound/              # 被驱动端口
│       ├── UserRepositoryPort.java
│       └── EmailServicePort.java
│
└── adapter/                   # 适配器层
    ├── inbound/               # 驱动适配器
    │   ├── rest/              # REST API
    │   │   └── UserRestController.java
    │   └── messaging/          # 消息队列消费者
    │       └── UserMessageListener.java
    └── outbound/              # 被驱动适配器
        ├── persistence/       # 持久化
        │   ├── jpa/
        │   │   └── UserJpaRepositoryAdapter.java
        │   └── entity/
        │       └── UserEntity.java
        ├── messaging/         # 消息队列发布
        │   └── UserEventPublisher.java
        └── external/          # 外部服务
            └── EmailServiceAdapter.java
```

### 10. 优势与适用场景

#### 10.1 核心优势

1. **技术无关性**：业务逻辑不依赖任何框架
2. **易于测试**：可以轻松 Mock 外部依赖
3. **灵活替换**：可以替换数据库、Web 框架等
4. **清晰分层**：职责明确，易于维护
5. **团队协作**：前后端可以并行开发

#### 10.2 适用场景

-   **复杂业务系统**：业务逻辑复杂，需要长期维护
-   **多技术栈**：需要支持多种数据库、消息队列等
-   **高测试要求**：需要高测试覆盖率
-   **微服务架构**：服务间需要清晰边界
-   **DDD 项目**：与领域驱动设计完美结合

#### 10.3 不适用场景

-   **简单 CRUD 应用**：过度设计，增加复杂度
-   **快速原型**：需要快速迭代，架构成本高
-   **小型项目**：团队小，业务简单

### 11. 常见问题与解决方案

#### 11.1 如何处理事务？

**方案：在应用层使用事务**

```java
@Service
@Transactional
public class UserApplicationService implements UserServicePort {

    @Transactional
    public User createUser(CreateUserCommand command) {
        // 事务边界在应用层
        User user = new User();
        userRepository.save(user);
        // 如果后续操作失败，整个事务回滚
        return user;
    }
}
```

#### 11.2 如何处理跨聚合操作？

**方案：使用领域事件**

```java
// 领域事件
public class OrderCreatedEvent {
    private Long orderId;
    private Long userId;
    // ...
}

// 发布事件
public class Order {
    public void create() {
        // 创建订单逻辑
        DomainEventPublisher.publish(new OrderCreatedEvent(this.id, this.userId));
    }
}

// 事件处理器（在应用层或适配器层）
@Component
public class OrderCreatedEventHandler {
    public void handle(OrderCreatedEvent event) {
        // 更新用户积分等跨聚合操作
    }
}
```

#### 11.3 如何避免贫血模型？

**方案：将业务逻辑放在领域对象中**

```java
// ❌ 贫血模型：只有 getter/setter
public class User {
    private String email;
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

// ✅ 充血模型：包含业务逻辑
public class User {
    private String email;

    public void changeEmail(String newEmail) {
        validateEmail(newEmail);
        this.email = newEmail;
        // 可以触发领域事件
    }

    private void validateEmail(String email) {
        // 验证逻辑
    }
}
```

### 12. 总结

**六边形架构核心要点：**

1. **业务逻辑在中心**：领域层和应用层是核心
2. **技术细节在外围**：适配器层处理技术实现
3. **依赖方向向内**：外层依赖内层，内层不依赖外层
4. **通过端口通信**：使用接口定义契约
5. **适配器实现细节**：具体技术实现隔离在适配器中

**最佳实践：**

-   保持领域层纯净，不引入任何框架依赖
-   使用端口定义清晰的接口契约
-   适配器负责技术转换（DTO ↔ 领域对象）
-   应用层编排用例，不包含业务逻辑
-   充分利用依赖注入，实现解耦

**与 DDD 结合：**

六边形架构为 DDD 提供了完美的技术实现框架，使得领域模型可以独立于技术实现，真正做到业务驱动开发。
