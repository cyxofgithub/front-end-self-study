## 编辑器多人协作冲突的核心解决方案

### OT 算法

OT（Operational Transformation，操作转换）算法是实时多人协作编辑系统的核心技术之一，其核心目标是**解决多用户并发编辑时的操作冲突**，让分布式的编辑操作最终收敛到一致的文档状态，同时保证编辑的实时性和正确性。

#### OT 算法的核心概念

1. 原子操作（Atomic Operation）
   OT 将复杂的编辑行为（如粘贴、替换、撤销）拆解为不可再分的原子操作，常见的原子操作类型包括：

    - 插入操作：insert(pos, text) → 在位置 pos 插入文本 text（长度为 len(text)）
    - 删除操作：delete(pos, length) → 从位置 pos 开始删除 length 个字符
    - 保留操作：retain(pos, length) → 跳过位置 pos 开始的 length 个字符（用于操作的序列化和对齐，是 OT 的重要辅助操作）

```
示例：用户在文档 “abcde” 的位置 2 插入 “12”，原子操作是insert(2, "12")；用户删除位置 3 开始的 2 个字符，原子操作是delete(3, 2)。
```

2. 操作的特性：可逆、可组合、可转换
   OT 算法依赖操作的三个关键特性：

-   可组合（Compose）：两个连续的操作可以合并为一个等价的操作。比如先执行 insert(2, "a")，再执行 insert(3, "b")，可组合为 insert(2, "ab")（简化示例，实际组合需考虑位置关联）。
-   可转换（Transform）：核心特性，对于两个并发的操作 op1 和 op2，存在转换函数 transform(op1, op2)，输出 op1'，使得先执行 op1 再执行 op2'，与先执行 op2 再执行 op1'的结果一致（收敛性保证）。
-   可逆（Inverse）：每个操作都有对应的逆操作，用于撤销功能。比如 insert(pos, text)的逆操作是 delete(pos, len(text))。

#### OT 算法的核心流程

典型的多人协作编辑系统采用客户端 - 服务端（CS）架构，OT 算法的执行流程如下：

1. **本地操作执行：**用户在客户端执行编辑操作（如插入文本），客户端先将操作应用到本地文档（实时反馈），然后将操作发送到服务端。
2. **服务端接收与广播：**服务端接收来自客户端的操作，先将操作应用到服务端的主文档，然后将该操作广播给其他所有客户端。
3. **远程操作的转换与应用：**其他客户端接收服务端广播的远程操作时，需要先通过转换函数将远程操作与本地已执行的未同步操作进行转换，再将转换后的远程操作应用到本地文档，保证状态一致。

**示例：两个用户并发插入的冲突解决**

假设初始文档是空字符串""，用户 A 和用户 B 同时执行以下操作：

-   用户 A：执行 opA = insert(0, "a")（在位置 0 插入 “a”）
-   用户 B：执行 opB = insert(0, "b")（在位置 0 插入 “b”）

**场景 1：服务端先接收 opA，再接收 opB**

1. 服务端应用 opA，文档变为"a"。
2. 服务端接收 opB，需要将 opB 转换为适应 opA 的操作：opB' = transform(opB, opA)。 由于 opA 是在位置 0 插入 “a”，opB 原本是在位置 0 插入 “b”，转换后 opB' 变为 insert(1, "b")（因为 opA 的插入让位置后移了 1 位）。
3. 服务端应用 opB'，文档变为"ab"，并将 opA 和 opB' 广播给所有客户端。
4. 用户 B 的客户端接收 opA 时，需要将 opA 转换为适应本地已执行的 opB 的操作：opA' = transform(opA, opB) → insert(1, "a")，应用后本地文档变为"ba"？不，这里需要注意**转换的双向性**，实际 OT 会保证最终状态一致，比如调整顺序后最终文档是"ab"或"ba"，但所有客户端都一致。

```
OT 的双向性要求满足：
apply(apply(S, opA), transform(opB, opA)) = apply(apply(S, opB), transform(opA, opB)) = S_final
```

**场景 2：服务端先接收 opB，再接收 opA**
类似地，opA 会被转换为 insert(1, "a")，最终文档变为"ba"，所有客户端状态一致。

#### 转换函数（Transform Function）的详细设计

转换函数是 OT 算法的核心，其作用是**根据已执行的操作调整待执行操作的参数，保证操作意图不变且结果收敛**。转换函数的签名通常是：

**1. 常见操作类型的转换规则**

OT 需要处理插入 - 插入、插入 - 删除、删除 - 插入、删除 - 删除四种核心操作组合的转换，以下是关键规则：
**（1）插入 - 插入（Insert-Insert）**
当两个插入操作 op1 = insert(p1, t1)和 op2 = insert(p2, t2)并发时：

-   规则：比较两个插入位置 p1 和 p2：
    -   如果 p1 < p2：op1 的位置不受 op2 影响，op1' = op1；op2 的位置需要加上 len(t1)（如果 op2 在 op1 之后处理）。
    -   如果 p1 > p2：op1 的位置需要加上 len(t2)，op1' = insert(p1 + len(t2), t1)。
    -   如果 p1 == p2：通常约定 “先到先得” 或 “按用户 ID 排序”（比如用户 ID 小的插入位置不变，大的位置加 len (t)），保证转换的一致性。

**（2）插入 - 删除（Insert-Delete）**
当 op1 = insert(p1, t1)（插入）和 op2 = delete(p2, l2)（删除）并发时：

-   规则：
    -   如果 p1 < p2：op1 的插入位置在删除范围之前，op1' = op1（删除操作不影响插入位置）。
    -   如果 p1 >= p2：op1 的插入位置在删除范围之内或之后，若 p1 < p2 + l2（插入位置在删除范围内），则 op1' 的位置变为 p2（删除后插入位置前移）；若 p1 >= p2 + l2，则 op1' 的位置减去 l2（删除操作让后面的位置前移）。

**（3）删除 - 插入（Delete-Insert）**
当 op1 = delete(p1, l1)（删除）和 op2 = insert(p2, t2)（插入）并发时：

-   规则：
    -   如果 p1 + l1 <= p2：删除范围在插入位置之前，op1' = op1（插入不影响删除位置）。
    -   如果 p1 >= p2 + len(t2)：删除范围在插入位置之后，op1' 的位置加上 len(t2)（插入让删除位置后移）。
    -   如果 p2 < p1 + l1：插入位置在删除范围之内，op1' 的长度加上 len(t2)（插入让删除范围扩大，保证删除意图不变）。

**（4）删除 - 删除（Delete-Delete）**

当两个删除操作 op1 = delete(p1, l1)和 op2 = delete(p2, l2)并发时：

-   规则：避免重复删除，调整删除的位置和长度：
    -   如果 p1 + l1 <= p2：op1' = op1（删除范围不重叠）。
    -   如果 p2 + l2 <= p1：op1' 的位置减去 l2（op2 的删除让 op1 的位置前移）。
    -   如果范围重叠：调整 op1 的位置和长度，保证删除的字符是原本意图的字符（比如合并删除范围）。

**2. 保留操作（Retain）的作用**

retain 操作的转换规则是：根据其他操作调整保留的长度和位置，保证操作的对齐性。

**场景 1：Retain 与 Insert 相遇（最常见）**
规则：当 op1 的段是 insert(c)（插入字符 c），op2 的段是 retain(n)（保留 n 个字符）时：

-   op2 的 retain(n)不需要调整长度，但需要在变换后的 op2' 中先插入这个 insert 操作，再保留 n 个字符（或反之，取决于插入的位置）；
-   本质是：插入操作会 “插入到” retain 操作的前面，导致 retain 的位置后移，但 retain 的长度不变。

案例：

-   原始文档："abc"（长度 3）。
-   op1（用户 A）：retain(1) + insert("x") + retain(2)（在位置 1 插入 "x"，文档变为"axbc"）。
-   op2（用户 B）：retain(2) + insert("y") + retain(1)（在位置 2 插入 "y"，文档变为"abyc"）。

变换 op2 以适应 op1（op2'）：

1. 遍历 op1 的 retain(1)和 op2 的 retain(2)：先处理 retain (1)，op2 的 retain 剩余 1。
2. 遇到 op1 的 insert("x")：在 op2' 中插入 insert("x")，op2 的 retain (1) 保持不变。
3. 处理 op1 的 retain(2)和 op2 的 retain(1)：合并为 retain (2)。

最终 op2'：retain(1) + insert("x") + retain(1) + insert("y") + retain(1)。应用后文档会与 “先执行 op1 再执行 op2” 的结果一致。

#### OT 算法的经典变体与实现

OT 算法经过数十年的发展，出现了多个经典变体，适用于不同的场景：

1. JOT：简化的 OT 实现，适用于纯文本编辑，核心是基于位置的操作转换。
2. OT.js：开源的 OT 库，支持文本和 JSON 文档的协作编辑。
3. Google Wave OT：Google 为 Wave 设计的 OT 算法，支持复杂的富文本编辑。
4. Etherpad OT：Etherpad 采用的 OT 实现，基于行的编辑模型，适合轻量级协作编辑。
