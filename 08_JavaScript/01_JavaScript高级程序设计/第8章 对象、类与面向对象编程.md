# 第8章 对象、类与面向对象编程

- 总结自《JavaScript高级程序设计》第4版 第8章

- ECMA-262 将对象定义为一组属性的无序集合。
- 对象就是一组没有特定顺序的值
- 对象的每个属性或方法都由一个名称来表示，这名称映射到一个值。
- 正因为如此，可以把ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数

## 8.1 理解对象

创建自定义对象的通常方式是创建object 的一个实例，然后再给它添加属性和方法：

- ```
  let person = new object();
  person.name = "abc";
  person.sayName = function() {
  	console.log( this.name );
  }
  ```

- 早期js开发者频繁使用这种方式创建对象。

- 几年后，对象字面量变成了更流行的方式

前面的例子如果使用对象字面量可以这样写：

- ```
  let person = {
  	name = 'abc';
  	sayName() {
  		console.log ( this.name );
  	}
  }
  ```

### 8.1.1 属性的类型

- ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由JavaScript 实现引擎的规范定义的。
- 因此，开发者不能再JavaScript中直接访问这些特性。
- 为了将某个特性表示为内部特性，规范会用两个中括号把特性的名称括起来。
- 比如：[ [ Enumerable ] ]
- **属性分为两种：数据属性和访问器属性**

#### **数据属性**

- 数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。

- 数据属性由4个特性描述它们的行为。

- [ [ Configurable ] ] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为访问器属性。

  - 默认情况下，所有直接定义在对象上的属性的这特性都是true
  - **一个属性被定为为不可以配置后，就不能再变回可配置的了。再次调用 object.defineProperty() 并修改任何非 writable 属性会导致错误**

- [ [ Enumberable] ] ：表示属性是否可以通过for-in循环返回。

  - 默认情况下，所有直接定义在对象上的属性的这个特征都是true

- [ [ Writeable ] ] ：表示属性的值是否可以被修改。

  - 默认情况下，所有直接定义在对象上的属性的这个特性都true

- **[ [ Value ] ] ：包含属性的实际的值。**

  - 这就是前面提到的那个读取和写入属性值的位置。

  - 这默认值为undefined

  - ```
    let person = {
    	name: 'abc'
    };
    这意味着[[Value]]特性会被设置为'abc'，之后对这个值的任何修改都会保存这个位置。 
    ```

  - **要修改属性的默认特性就必须使用object.defineProperty()方法。**

  - 这个方法接收3个参数：要给其添加的属性的对象、属性的名称和一个描述符对象

  - 最后一个参数，即描述符对象上的属性可以包含：

  - configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。

  - 根据要修改的特性，可以设置其中一个或多个值。比如：

  - ```
    let person = {};
    object.defineProperty(persion,"name",{
    	writable: false,
    	value: 'abc'
    });
    console.log(person.name);// "abc"
    person.name = 'cde';// 在非严格模式下尝试给着属性重新赋值会被忽略。在严格模式下，尝试修改制度属性的值会抛出错误
    console.log(person.name);// "abc"
    ```

- **虽然可以对同一个属性多次调用 object.defineProperty(),但再把 configurable设置为false 之后就会受限制了。**

- **再调用object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。**

多数情况下，可能都不需要 object.defineProperty() 提供的这些强大的设置，但要理解 JS对象，就要理解这些概念。



#### 访问器属性

- 访问器属性不包含数据值。相反，它包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需要的。在读取访问器属性时，会调用获取函数，这函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。

- **访问器属性有4个特性描述它们的行为：**

  - [ [ configurable ] ]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为数据属性。
    - 默认情况下，所有直接定义在对象上的属性的这个特性都是true。
  - [ [ Enumerable ] ]：表示属性是否可以通过for-in循环返回。
    - 默认情况下，所有直接定义在对象上的属性的这个特征都是true
  - [ [ Get ] ]：获取函数，在读取属性时调用。默认值为underfined
  - [ [ Set ] ]：设置函数，在写入属性时调用。默认值为underfined

- **访问属性是不能直接定义的，必须使用object.defineProperty**

- 下面是一个例子：

- ```
  let book = {
  	year_:2017,
  	edition:1
  };
  Object.defineProperty(book,"year",{
  	get() {
  		return this.year_;
  	}
  	set(newValue) {
  		if(newValue > 2017) {
  			this.year_ = newValue;
  			this.edition + = newValue - 2017;
  		}
  	}
  });
  book.year = 2018;
  console.log(book.education); // 2
  // 将属性year定义为一个访问器属性
  // 获取函数简单地返回year_值
  // 设置函数会做也写计算以决定正确的版本(edition)
  // 因此，把year属性修改为2018会导致year_变成2018,education变成2
  ```

- 获取函数和设置函数不一定要都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。

#### 8.1.2 定义多个属性

- **使用Object.defineProperties()方法**

  - 它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或者修改的属性一一对应。比如：

  - ```
    let book = {};
    Object.defineProperties(book,{
    // 定义了两个数据属性（year_ and edition）和一个访问器属性（year）
    	year_:{
    		value:2017
    	},
    	
    	edition:{
    		value:1
    	},
    	
    	year:{
    		get() {
    			return this.year_;
    		},
    		set(newValue) {
    			if(newValue > 2017) {
    				this.year_ = newValue;
    				this.edition + = newValue - 2017;
    			}
    		},
    	}
    });
    ```

#### 8.1.3 读取属性的特性

- **使用Object.getOwnPropertyDescriptor()方法**
  - 这个方法接收两个参数；属性所在的对象和要取得其描述符的属性名。返回值是一个对象。
  - 例：Object.getOwnPropertyDesciptor(book,"year")
  - 对于访问器属性包含：configurable、enumerable、get 和 set 属性
  - 对于数据属性包含 configurable、enumberable、writable 和 value 属性。
- ES 2017新增了Object.getOwnPropertyDescriptors()静态方法。
  - 这个方法实际上会在每一个自有属性上调用Object.defineProperties（）并在一个新对象中返回它们。
  - Object.getOwnPropertyDescriptors(book)

#### 8.1.4 合并对象

#### 8.1.5 对象标识及相等判定00

#### 8.1.6 增强的对象语法

- 属性值简写

  - 若属性名和变量名是一样的。例如

  - ```
    let name = ”Matt“;
    
    let person = {
    	name:name
    };
    可以简写为：
    let person = {
    	name
    };
    ```

- 可计算属性性

  - 引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。

  - 没引入之前只能这样写：

    - ```
      const nameKey = 'name';
      let person = {};
      person[nameKey] = 'Matt'
      ```

  - 引入之后：

    - ```
      const nameKey = 'name';
      // 可以在对象字面量中直接动态命名属性
      let person = {
      	[nameKey]:'Matt',
      };
      console.log(person); // { name:'Matt' }
      ```

  - 注意：计算数学本身还可以是复杂的表达式，在实例化时再求值，例如：

  - ```
    const nameKey = 'name';
    let uniqueToken = 0;
    function getUniqueKey(key) {
    	return '${key}_${uniqueToken++}';
    }
    let person = {
    	[getUniqueKey(nameKey)]:'Matt',
    };
    console.log(person);// { name_0:'Matt'}
    ```

  - 注意如果表达式抛出错误，那么之前完成的计算是不能回滚的

- 简写方法名

  - ```
    简写前
    let person = {
    	sayName:function(name) {
    		console.log('My name is ${name}');
    	}
    };
    
    简写后
    let person = {
    	sayName(name) {
    		console.log('My name is &(name)');
    	}
    }
    ```

  - 简写方法名对获取函数（get）和设置函数（set）也是适用的

  - 简写方法名可与计算属性键相互兼容；

  - ```
    const methodKey = 'sayName';
    
    let person = {
    	[methodKey](name) {
    		console.log('My name is $(name)');
    	}
    }
    
    person.sayName('Matt'); // My name is Matt
    ```

#### 8.1.7 对象解构

- ES6新增了对象结构语法，对象结构就是使用与对象匹配的结构来实现对象属性赋值（获取对象属性值）

- 不适用对象解构语法时要获取属性值：

  - ```
    let person = {
    	name: 'Matt'
    	age:27
    };
    let personName = person.name // 获取name的值
    let personAge = person.age // 获取age的值
    // 如果有多个属性值要获取将十分繁琐
    ```

- 使用对象解构语法获取值：

  - ```
    let { name: personName,age:personAge } = person;
    // name的值会被赋值给personName age的值会被赋值给personAge
    // 很明显方便了许多
    ```

  - 如果直接使用属性的名称可以简写为：

  - ```
    let { name,age } = person;
    // 此时name的值为person.name age的值为person.age
    ```

  - 注意：如果引用的属性不存在，则该变量的值就是undefined

  - ```
    let { name,job } = perosn;
    console.log(job);//undefined
    ```

  - 也可以在解构赋值的同时定义默认值，这适用于引用属性不存在于源对象中的情况：

  - ```
    let person = {
    	name: 'Matt',
    	age: 27
    }
    let { name,job = 'Sofaware engineer' } = person;
    console.log(name); // Matt
    console.log(job); // Software engineer
    ```

- 注意：解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：

  - ```
    let personName,personAge;
    ({name:personName,age:personAge} = person);
    console.log(personName,personAge);	// Matt,27
    ```

- 嵌套解构

- 部分解构

- 参数上下文匹配

## 8.2 创建对象

### 8.2.1 概述

### 8.2.2 工厂模式

- 概念：工厂模式是一种众所周知的设计模式，广发应用于软件工程领域，用于抽象创建特定对象的过程。

- ```
  function createPerson(name,age,job) {
  	let o = new object();
  	o.name = name;
  	o.age = age;
  	o.job = job;
  	o.sayName = function() {
  		console.log(this.name);
  	};
  	return o;
  }
  let person1 = createPerson("Nicholas",29,"Software Engineer");
  let person2 = createPerson("Greg",27,"Doctor");
  ```

- 这里，函数createPerson()接收3个参数，根据这几个参数构建了一个包含person信息的对虾。

- **这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题(即新创建的对象是什么类型)**

### 8.2.3 构造函数模式

- 前面使用的例子使用构造函数模式可以这样写

- ```
  function Person(name,age,job) {
  	this.name = name;
  	this.age = age;
  	this.job = job;
  	this.sayName = function() {
  		console.log(this.name);
  	} 
  }
  let person1 = new Person("Nicholas",29,"Software Engineer");
  let person2 = new Person("Greg",27,"Doctor");
  
  person1.sayName();// Nicholas
  person2.sayName();// Greg
  ```

- 实际上person()内部的代码跟createPerson()基本是一样的，只是有如下区别：

  - 没有显示地创建对象
  - 属性和方法直接赋值给了this
  - 没有return

- **按照惯例构造函数名称的首字母都是要大写的**

- 要创建Person实例，应使用new操作符。这种方式构造函数会执行如下操作：

  - 在内存中创建一个新对象
  - 在这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性
  - 构造函数内部的this被赋值为这个新对象（即this指向新对象）
  - 执行构造函数内部的代码（给新对象添加属性）
  - 如果构造函数返回非空对象，则返回该对象，否则，返回刚创建的新对象

### 8.2.4 原型模式

每个创建的**函数**都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。**prototype就是通过调用构造函数创建的那个对象实例的原型对象。使用原型对象的好处是可以就让所有对象实例共享它所包含的属性和方法。**例：

```
function Person(){
}

Person.prototype.name = ‘ken’;
Person.prototype.age = 28;
Person.prototype.job = ‘frontend’;
Person.prototype.sayName = function(){
alert(this.name);
};
// person1 和 person2 对象共享原型对象prototype的属性和方法
var person1 = new Person();
var person2 = new Person();
alert(person1.sayName == person2.sayName);   //true （不加括号，否则对比的是运行值）
```

14.无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。

15.在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性指向prototype属性所在函数的指针。例如Person.prototype.constructor指向Person。

16.当调用构造函数创建一个新实例后，该实例的内部将包含一个[[prototype]]指针（主流浏览器中的_proto_属性）**。要明确的重要一点是，这个连接存在于实例与原型对象之间，而不是存在于实例与构造函数之间。**

17.**虽然在所有实例中都无法访问[[prototype]]，但可以通过isPrototypeOf()方法（返回值表示调用对象是否在另一个对象的原型链上。）来确定对象之间是否存在这种关系。**

```
// 表示Person原型对象存在于person1和person2对象的原型链上
alert(Person.prototype.isPrototypeOf(person1));   //true
alert(Person.prototype.isPrototypeOf(person2));   //true
```

18.**Ojbect.getPrototypeOf()方法返回[[prototype]]的值。**

```
alert(Object.getPrototypeOf(person1))  //Person.prototype
alert(Object.getPrototypeOf(person1).name)  //ken
```

19.虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性，但不会修改那个属性。不过，使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

```
var person1 = new Person();
person1.name = 'jason';
delete person1.name;
alert(person1.name);   //ken
```

20.单独使用in操作符，会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。
`alert('name' in person1); //true;`

使用for-in循环时，返回的是所有能够通过对象访问的，可枚举的属性，其中既包含存在于实例中的属性，也包括存在原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的（除了IE8及更早版本）。

要取得对象上所有**可枚举的实例属性**，可以使用ECMAScript5中的***Object.keys()***方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。

如果想要得到所有实例属性，无论它是否可枚举，都可以使用**Object.getOwnPropertyNames()**。

总结：
for-in 实例+原型、可枚举；
Object.keys() 实例、可枚举；
Object.getOwnPropertyNames() 实例、可枚举+不可枚举

21.更简单的原型语法（重点）：

```
function Person(){
}

Person.prototype = {
    name:'Ken',
    age:28,
    job:'FrontEnd Engineer',
    sayName:function(){
        alert(this.name);
    }
};
```

**使用这样的语法创建原型对象，constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建他的prototype对象。在这里使用的语法，本质上完全重写了默认的prototype对象，因此，constructor属性也就变成了新对象的constructor属性(指向Object构造函数)，不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确立对象的类型了。**

**如果constructor的值真的很重要，那么在使用上面的语法重写原型对象时，可以手动将construtor的属性值设为Person。注意，以这种方式重设constructor属性会导致他的[[Enumerable]]特性被置为true。可以通过Object.defineProperty()方法将属性置为默认的不可枚举：**

```
Object.defineProperty(Person.prototype,'constructor',{
    enumerable: false,
    value: Person
});
```

22.原型的动态性（重点）
由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来--即使是先创建了实例后修改原型也照样如此。

尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但**如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。**

23.不推荐在产品化的程序中修改原生对象的原型。

**24.将构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，这是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。（重点）**

```
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['wesley','fox'];
}

Person.prototype = {
    constructor:Person,
    sayName:function(){
        alert(this.name)
    }
}
```

25.**动态原型模式**解决了构造函数与原型分别独立、没有封装在一起的问题。

```
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ['wesley','fox'];
    if (typeof this.sayName !== 'function') {
        Person.prototype.sayName = function(){
            alert(this.name)
        }
    }
}
```

#### 寄生构造函数

26.**寄生构造函数模式**解决了这样一个场景下的问题：假设想创建一个具有额外方法的特殊数组，又不能直接修改Array构造函数，就可以使用这个模式。**除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的**。

```
function SpecialArray(){
    var values = new Array();
    values.push.apply(values,arguments);  //此处使用apply是因为apply可以方便地把arguments添加到values数组。
    values.toPipeString = function(){
        return this.join('|');
    }
    return values;
}

var colors = new SpecialArray('red','blue','green');
alert(colors.toPipeString());    //'red|blue|green'
```

关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与构造函数外部创建的对象没什么不同。为此，**不能依赖instanceof操作符来确定对象类型**。由于存在上述问题，我们建议在在可以使用其他模式的情况下，不要使用这种模式。

```
alert(SpecialArray.prototype.isPrototypeOf(colors));    //false
alert(colors instanceof SpecialArray);    //false
```

#### 稳妥对象

27.所谓**稳妥对象**，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境会禁止使用this和new），或者防止数据被其他应用程序改动时使用。**稳妥构造函数模式遵循与寄生构造函数模式类似的模式，但有两点不同：一是新创建对象实例方法不引用this；二是不使用new操作符调用构造函数。**

```
function Person(name,age,job){
    //var name = name，age = age,job = job;
    var o = new Object();
    o.sayName = function(){
        alert(name);
    };
    return o;
}

var friend = Person('ken','28','FrontEnd Engineer');
friend.sayName();    //ken
```

这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法和数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系型，因此instanceof操作符对这种对象也没有意义。（**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。）

### 8.2.5 对象迭代

## 8.3 继承

## 8.4 类

## 8.5 小结