# 第一篇 变化侦测

- 从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染，应用在运行时会不断地进行重新渲染。
- 而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。
- 变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

## 第 2 章　Object的变化侦测

### 2.1　什么是变化侦测

通常，在运行时应用内部的状态会不断发生变化，此时需要不停地重新渲染。这时如何确定状态中发生了什么变化？

```
变化侦测就是用来解决这个问题的，它分为两种类型：一种是“推”（push），另一种是“拉”（pull）。
```

```
Angular和React中的变化侦测都属于“拉”，这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。
```

```
而Vue.js的变化侦测属于“推”。当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。
```

```
所谓更细粒度的更新，就是说：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。
```

```
但是它也有一定的代价，因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。
```

**Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。**

### 2.2　如何追踪变化

```
其实这个问题还是比较简单的。学过JavaScript的人都知道，有两种方法可以侦测到变化：使用Object.defineProperty和ES6的Proxy。
```

```
由于使用Object.defineProperty来侦测变化会有很多缺陷，所以Vue.js的作者尤雨溪说日后会使用Proxy重写这部分代码
```

### 2.3　如何收集依赖

```
收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了。
```

总结起来，其实就一句话，在getter中收集依赖，在setter中触发依赖。

### 2.4　依赖收集在哪里

假设依赖是一个函数，保存在window.target上，现在就可以把defineReactive函数稍微改造一下：

![image-20211120105552376](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120105552376.png)

但是这样写有点耦合，我们把依赖收集的代码封装成一个Dep类，它专门帮助我们管理依赖。使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。其代码如下：

![image-20211120105649422](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120105649422.png)

之后再改造一下defineReactive：

![image-20211120105720448](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120105720448.png)

### 2.5 依赖是谁

在上面的代码中，我们收集的依赖是window.target，那么它到底是什么？我们究竟要收集谁呢？

```
收集谁，换句话说，就是当属性发生变化后，通知谁。
```

```
我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch;

这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个。

接着，它再负责通知其他地方。所以，我们要抽象的这个东西需要先起一个好听的名字。嗯，就叫它Watcher吧。
```

```
现在就可以回答上面的问题了，收集谁？Watcher！
```

### 2.6　什么是Watcher

Watcher是**一个中介的角色**，数据发生变化时通知它，然后它再通知其他地方。

![image-20211120201045299](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120201045299.png)

思考一下，怎么实现这个功能呢？

```
好像只要把这个watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。
```

![image-20211120201028372](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120201028372.png)

注意：window.target 其实就是 vue 作者自己在 window 上定义的一个变量，就是简单的用于存值，不是什么内置对象。

```
这段代码可以把自己主动添加到data.a.b.c的Dep中去，是不是很神奇？
```

```
因为我在get方法中先把window.target设置成了this，也就是当前watcher实例，然后再读一下data.a.b.c的值，这肯定会触发getter。

触发了getter，就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从window.target中读取一个依赖并添加到Dep中。

这就导致，只要先在window.target赋一个this，然后再读一下值，去触发getter，就可以把this主动添加到keypath的Dep中。

依赖注入到Dep中后，每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldValue传到参数中。
```

**所以，其实不管是用户执行的vm.$watch('a.b.c', (value,oldValue) => {})，还是模板中用到的data，都是通过Watcher来通知自己是否需要发生变化。**

```
这里有些小伙伴可能会好奇上面代码中的parsePath是怎么读取一个字符串的keypath的，下面用一段代码来介绍其实现原理：
```

![image-20211120201550775](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120201550775.png)

### 2.7　递归侦测所有key

```
现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个Observer类
```

**这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化**

![image-20211120201731165](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120201731165.png)

```
在上面的代码中，我们定义了Observer类，它用来将一个正常的object转换成被侦测的object。然后判断数据的类型，只有Object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。
```

```
当data中的属性发生变化时，与这个属性对应的依赖就会接收到通知。也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。
```

### 2.8　关于Object的问题

Vue2( Vue 3 通过 proxy 已经可以了)通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。

为了解决这个问题，Vue.js提供了两个API——vm.$set与vm.$delete，第4章会详细介绍它们。

### 2.9　总结

```
变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。
```

```
我们需要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的依赖数据发生了变化。
```

```
收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep，它用来收集依赖、删除依赖和向依赖发送消息等。
```

```
所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。
```

```
Watcher的原理是先把自己设置到全局唯一的指定位置（例如window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。
```

```
此外，我们创建了Observer类，它的作用是把一个object中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测object中所有数据（包括子数据）的变化。
```

![image-20211120203310982](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20211120203310982.png)