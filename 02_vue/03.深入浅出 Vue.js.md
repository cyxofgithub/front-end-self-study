# 深入浅出 Vue.js

# 第 1 章　Vue.js简介

当应用程序开始变复杂后，我们需要频繁操作DOM。由于缺乏正规的组织形式，我们的代码变得非常难以维护。这本质上是命令式操作DOM的问题，我们曾经用jQuery操作DOM写需求，但是当应用程序变复杂后，代码就像一坨意大利面一样，有点难以维护。我们无法继续使用命令式操作DOM，**所以Vue.js提供了声明式操作DOM的能力来解决这个问题。**

通过描述状态和DOM之间的映射关系，就可以将状态渲染成DOM呈现在用户界面中，也就是渲染到网页上。

## 1.1　什么是Vue.js

Vue.js，通常简称为Vue，是一款友好的、多用途且高性能的JavaScript框架，能够帮助我们创建可维护性和可测试性更强的代码。它是目前所有主流框架中学习曲线最平缓的框架，非常容易上手，其官方文档也写得非常清晰、易懂。

它是一款渐进式的JavaScript框架。关于什么是渐进式，其实一开始我琢磨了好久，后来才弄懂，就是说如果你已经有一个现成的服务端应用，也就是非单页应用，可以将Vue.js作为该应用的一部分嵌入其中，带来更加丰富的交互体验。

## 1.2　Vue.js简史

# 第一篇　变化侦测 （很多地方不懂）

## 1.0 概述

Vue.js最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JavaScript对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见的问题。——官方文档

**从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染**，应用在运行时会不断地进行重新渲染。而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

简单来说，**变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新**。

本篇中，我们将针对变化侦测的实现原理做一个详细介绍，并且会带着你一步一步从0到1实现一个变化侦测的逻辑。学完本篇，你将可以自己实现一个变化侦测的功能。

# 第 2 章　Object的变化侦测

**大部分人不会想到Object和Array的变化侦测采用不同的处理方式。事实上，它们的侦测方式确实不一样。**

## 2.1　什么是变化侦测

Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。

**如何确定状态中发生了什么变化？**

变化侦测就是用来解决这个问题的，**它分为两种类型**：一种是“推”（push），另一种是“拉”（pull）。



**Angular和React中的变化侦测都属于“拉”，**这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。



**而Vue.js的变化侦测属于“推”。**当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。



**所谓更细粒度的更新，就是说**：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。

但是它也有一定的代价，**因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。**



Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

## 2.2　如何追踪变化

**在JavaScript（简称JS）中，如何侦测一个对象的变化？**

有两种方法可以侦测到变化：使用Object.defineProperty和ES6的Proxy。



由于ES6在浏览器中的支持度并不理想，到目前为止Vue.js还是使用Object.defineProperty来实现的，所以书中也会使用它来介绍变化侦测的原理。

由于使用Object.defineProperty来侦测变化会有很多缺陷，所以Vue.js的作者尤雨溪说日后会使用Proxy重写这部分代码。好在本章讲的是原理和思想，所以即便以后用Proxy重写了这部分代码，书中介绍的原理也不会变。



知道了Object.defineProperty可以侦测到对象的变化，那么我们可以写出这样的代码：

![image-20210514084010557](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084010557.png)

这里的函数defineReactive用来对Object.defineProperty进行封装。从函数的名字可以看出，其作用是定义一个响应式数据。也就是在这个函数中进行变化追踪，封装后只需要传递data、key和val就行了。

封装好之后，每当从data的key中读取数据时，get函数被触发；每当往data的key中设置数据时，set函数被触发。

## 2.3　如何收集依赖

**举个例子：**

![image-20210514084323831](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084323831.png)

该模板中使用了数据name，所以当它发生变化时，要向使用了它的地方发送通知。

注意　在Vue.js 2.0中，**模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。**

对于上面的问题，我的回答是，**先收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了**。

**总结起来，其实就一句话，在getter中收集依赖，在setter中触发依赖。**

## 2.4　依赖收集在哪里

思考一下，首先想到的是每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上，现在就可以把defineReactive函数稍微改造一下：

![image-20210514084718191](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084718191.png)

这样写有点耦合，我们把依赖收集的代码封装成一个Dep类，它专门帮助我们管理依赖。使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。其代码如下：

![image-20210514085341061](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085341061.png)

之后再改造一下defineReactive：

![image-20210514085358005](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085358005.png)

依赖收集到哪儿？收集到Dep中。

## 2.5　依赖是谁

**我们收集的依赖是window.target，那么它到底是什么？我们究竟要收集谁呢？**

收集谁，换句话说，就是当属性发生变化后，通知谁。

我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个。接着，它再负责通知其他地方。所以，我们要抽象的这个东西需要先起一个好听的名字。嗯，就叫它**Watcher**吧。

现在就可以回答上面的问题了，收集谁？Watcher！

## 2.6　什么是Watcher（有不理解的地方）

Watcher是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。

关于Watcher，先看一个经典的使用方式：

![image-20210514085643276](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085643276.png)

这段代码表示当data.a.b.c属性发生变化时，触发第二个参数中的函数。

**怎么实现这个功能呢？**（看不懂代码）

好像只要把这个watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。

写出如下代码：

![image-20210514085824453](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085824453.png)

tips：![image-20210514093447755](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514093447755.png)

**调用this.getter（）就是调用this.get（）**

这段代码可以把自己主动添加到data.a.b.c的Dep中去，是不是很神奇？

因为我在get方法中先把window.target设置成了this，也就是当前watcher实例，然后再读一下data.a.b.c的值，这肯定会触发getter。

触发了getter，就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从window.target中读取一个依赖并添加到Dep中。

这就导致，只要先在window.target赋一个this，然后再读一下值，去触发getter，就可以把this主动添加到keypath的Dep中。有没有很神奇的感觉啊？

依赖注入到Dep中后，每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldValue传到参数中。

所以，其实不管是用户执行的vm.$watch('a.b.c', (value, oldValue) => {})，还是模板中用到的data，都是通过Watcher来通知自己是否需要发生变化。

这里有些小伙伴可能会好奇上面代码中的parsePath是怎么读取一个字符串的keypath的，下面用一段代码来介绍其实现原理：

![image-20210514091537401](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514091537401.png)

可以看到，这其实并不复杂。先将keypath用 . 分割成数组，然后循环数组一层一层去读数据，最后拿到的obj就是keypath中想要读的数据。

## 2.7　递归侦测所有key（不理解我跑去看视频了）

现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个Observer类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化：

![image-20210514094552614](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514094552614.png)

在上面的代码中，我们定义了Observer类，它用来将一个正常的object转换成被侦测的object。

然后判断数据的类型，只有Object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。

最后，在defineReactive中新增new Observer(val)来递归子属性，这样我们就可以把data中的所有属性（包括子属性）都转换成getter/setter的形式来侦测变化。

当data中的属性发生变化时，与这个属性对应的依赖就会接收到通知。

也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。

# 第 3章　Array的变化侦测

## 3.11　侦测新增元素的变化

数组中有一些方法是可以新增数组内容的，比如push，而新增的内容也需要转换成响应式来侦测变化，否则会出现修改数据时无法触发消息等问题。因此，我们必须侦测数组中新增元素的变化。

**其实现方式其实并不难，只要能获取新增的元素并使用Observer来侦测它们就行。**

### 3.11.1　获取新增元素

![image-20210524145557025](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524145557025.png)

在上面的代码中，我们通过switch对method进行判断，如果method是push、unshift、splice这种可以新增数组元素的方法，那么从args中将新增元素取出来，暂存在inserted中。

接下来，我们要使用Observer把inserted中的元素转换成响应式的。

### 3.11.2　使用Observer侦测新增元素

前面介绍过Observer会将自身的实例附加到value的 __ob__ 属性上。所有被侦测了变化的数据都有一个 __ob__ 属性，数组元素也不例外。

因此，我们可以在拦截器中通过this访问到 __ob__，然后调用 __ob__ 上的observeArray方法就可以了：

![image-20210524145902381](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524145902381.png)

在上面的代码中，我们从this.__ob__ 上拿到Observer实例后，如果有新增元素，则使用ob.observeArray来侦测这些新增元素的变化。

## 3.12　关于Array的问题

前面介绍过，对Array的变化侦测是通过拦截原型的方式实现的。正是因为这种实现方式，其实有些数组操作Vue.js是拦截不到的，例如：

![image-20210524150031372](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150031372.png)

即修改数组中第一个元素的值时，无法侦测到数组的变化，所以并不会触发re-render或watch等。

例如：

![image-20210524150058227](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150058227.png)

这个清空数组操作也无法侦测到数组的变化，所以也不会触发re-render或watch等。

因为Vue.js的实现方式决定了无法对上面举的两个例子做拦截，也就没有办法响应。在ES6之前，无法做到模拟数组的原生行为，所以拦截不到也是没有办法的事情。ES6提供了元编程的能力，所以有能力拦截，我猜测未来Vue.js很有可能会使用ES6提供的Proxy来实现这部分功能，从而解决这个问题。

## 3.13　总结

**Array追踪变化的方式和Object不一样。因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式来追踪变化。**

为了不污染全局Array.prototype，我们在Observer中只针对那些需要侦测变化的数组使用 __proto__ 来覆盖原型方法，但 __proto__ 在ES6之前并不是标准属性，不是所有浏览器都支持它。因此，针对不支持 __proto__ 属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截Array.prototype上的原生方法。

**Array收集依赖的方式和Object一样，都是在getter中收集。**但是由于使用依赖的位置不同，数组要在拦截器中向依赖发消息，所以**依赖不能像Object那样保存在defineReactive中，而是把依赖保存在了Observer实例上。**

**在Observer中，我们对每个侦测了变化的数据都标上印记 ob，并把this（Observer实例）保存在 ob 上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据取到 ob，从而拿到Observer实例上保存的依赖。当拦截到数组发生变化时，向依赖发送通知。**

**除了侦测数组自身的变化外，数组中元素发生的变化也要侦测。**我们在Observer中判断如果当前被侦测的数据是数组，则调用observeArray方法将数组中的每一个元素都转换成响应式的并侦测变化。

由于在ES6之前，JavaScript并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化，**只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用length清空数组的操作就无法拦截。**

# 第 4 章　变化侦测相关的API实现原理

## 4.1　vm.$watch

### 4.1.1　用法

![image-20210524150644584](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150644584.png)

● 参数：

● {string | Function} expOrFn

● {Function | Object} callback、

● {Object} [options]

​	{boolean} deep

​	● {boolean} immediate

● 返回值：{Function} unwatch

**用法**：用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以用函数代替表达式。

例如：

![image-20210524151000418](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151000418.png)

vm.$watch返回一个取消观察函数，用来停止触发回调：

![image-20210524151027211](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151027211.png)

最后，简要介绍一下 [options] 的两个选项deep和immediate。

deep。为了发现对象内部值的变化，可以在选项参数中指定deep: true：

![image-20210524151101011](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151101011.png)

这里需要注意的是，监听数组的变动不需要这么做。

immediate。在选项参数中指定immediate: true，将立即以表达式的当前值触发回调：

![image-20210524151126137](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151126137.png)

### 4.1.2　watch的内部原理

vm.$watch其实是对Watcher的一种封装，Watcher的原理在第2章中介绍过。通过Watcher完全可以实现vm.$watch的功能，但vm.$watch中的参数deep和immediate是Watcher中所没有的。下面我们来看一看vm.$watch到底是怎么实现的：

![image-20210524151217123](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151217123.png)

可以看到，代码不多，逻辑也不算复杂。先执行new Watcher来实现vm.$watch的基本功能。

这里有一个细节需要注意，expOrFn是支持函数的，而我们在第2章中并没有介绍。这里我们需要对Watcher进行一个简单的修改，具体如下：

![image-20210524151513890](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151513890.png)

上面的代码新增了判断expOrFn类型的逻辑。如果expOrFn是函数，则直接将它赋值给getter；如果不是函数，再使用parsePath函数来读取keypath中的数据。这里keypath指的是属性路径，例如a.b.c.d就是一个keypath，说明从vm.a.b.c.d中读取数据。

当expOrFn是函数时，会发生很神奇的事情。它不只可以动态返回数据，其中读取的所有数据也都会被Watcher观察。**当expOrFn是字符串类型的keypath时，Watcher会读取这个keypath所指向的数据并观察这个数据的变化。而当expOrFn是函数时，Watcher会同时观察expOrFn函数中读取的所有Vue.js实例上的响应式数据。也就是说，如果函数从Vue.js实例上读取了两个数据，那么Watcher会同时观察这两个数据的变化，当其中任意一个发生变化时，Watcher都会得到通知。**

说明　事实上，Vue.js中计算属性（Computed）的实现原理与expOrFn支持函数有很大的关系，我们会在后面的章节中详细介绍。

执行new Watcher后，代码会判断用户是否使用了immediate参数，如果使用了，则立即执行一次cb。

最后，返回一个函数unwatchFn。顾名思义，它的作用是取消观察数据。

当用户执行这个函数时，实际上是执行了watcher.teardown()来取消观察数据，其本质是把watcher实例从当前正在观察的状态的依赖列表中移除。



前面介绍Watcher时并没有介绍teardown方法，现在要在Watcher中添加该方法来实现unwatch的功能。

首先，需要在Watcher中记录自己都订阅了谁，也就是watcher实例被收集进了哪些Dep里。然后当Watcher不想继续订阅这些Dep时，循环自己记录的订阅列表来通知它们（Dep）将自己从它们（Dep）的依赖列表中移除掉。

先在Watcher中添加addDep方法，该方法的作用是在Watcher中记录自己都订阅过哪些Dep：

![image-20210524152310424](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152310424.png)

在上述代码中，我们使用depIds来判断如果当前Watcher已经订阅了该Dep，则不会重复订阅。在第2章中，我们介绍过Watcher读取value时，会触发收集依赖的逻辑。当依赖发生变化时，会通知Watcher重新读取最新的数据。如果没有这个判断，就会发现每当数据发生了变化，Watcher都会读取最新的数据。而读数据就会再次收集依赖，这就会导致Dep中的依赖有重复。这样当数据发生变化时，会同时通知多个Watcher。为了避免这个问题，只有第一次触发getter的时候才会收集依赖。

接着，执行this.depIds.add来记录当前Watcher已经订阅了这个Dep。

然后执行this.deps.push(dep)记录自己都订阅了哪些Dep。

最后，触发dep.addSub(this)来将自己订阅到Dep中。

在Watcher中新增addDep方法后，Dep中收集依赖的逻辑也需要有所改变：

![image-20210524152724558](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152724558.png)

此时，Dep会记录数据发生变化时，需要通知哪些Watcher，而Watcher中也同样记录了自己会被哪些Dep通知。它们其实是多对多的关系，如图4-1所示。

![image-20210524152831256](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152831256.png)

图4-1　Watcher与Dep的关系

有些人可能会感到困惑，为什么是多对多的关系。Watcher每次只读一个数据，不是应该只有一个Dep吗？

其实不是。如果Watcher中的expOrFn参数是一个表达式，那么肯定只收集一个Dep，并且大部分都是这样。但凡事总有例外，expOrFn可以是一个函数，此时如果该函数中使用了多个数据，那么这时Watcher就要收集多个Dep了，例如：

![image-20210524152942616](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152942616.png)

这种情况下Watcher内部会收集两个Dep——name的Dep和age的Dep，同时这两个Dep中也会收集Watcher，这导致age和name中的任意一个数据发生变化时，Watcher都会收到通知。

**言归正传，当我们已经在Watcher中记录自己都订阅了哪些Dep之后，就可以在Watcher中新增teardown方法来通知这些订阅的Dep，让它们把自己从依赖列表中移除掉：**

![image-20210524153054366](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153054366.png)

上面做的事情很简单，只是循环订阅列表，然后分别执行它们的removeSub方法，来把自己从它们的依赖列表中移除掉。接下来，看看removeSub中都发生了什么：

![image-20210524153219233](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153219233.png)

上面的代码把Watcher从sub中删除掉，然后当数据发生变化时，将不再通知这个已经删除的Watcher，这就是unwatch的原理。

## 还没看完

# 第二篇　虚拟DOM

# 第 5 章　虚拟DOM简介

## 5.1　什么是虚拟DOM

本质上，我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫作渲染，如图5-1所示

![image-20210524153626752](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153626752.png)

每当状态发生变化时，都需要重新渲染。如何确定状态中发生了什么变化以及需要在哪里更新DOM？

在这种情况下，最简单粗暴的解决方式是，既不需要关心状态发生了什么变化，也不需要关心在哪里更新DOM，我们只需要把所有DOM全删了，然后使用状态重新生成一份DOM，并将其输出到页面上显示出来就好了。

但是访问DOM是非常昂贵的。按照上面说的方式做，会造成相当多的性能浪费。状态变化通常只有有限的几个节点需要重新渲染，所以我们不仅需要找出哪里需要更新，还需要尽可能少地访问DOM。

![image-20210524153743681](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153743681.png)

这个问题有很多种解决方案。目前，各大主流框架都有自己的一套解决方案，在Angular中就是脏检查的流程，React中使用虚拟DOM，Vue.js 1.0通过细粒度的绑定。**因此，虚拟DOM本质上只是众多解决方案中的一种，可以用但并不一定必须用。**

**虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。**

虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。

![image-20210524154141583](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154141583.png)

## 5.2　为什么要引入虚拟DOM

事实上，Angular和React的变化侦测有一个共同点，那就是它们都不知道哪些状态（state）变了。因此，就需要进行比较暴力的比对，React是通过虚拟DOM的比对，Angular是使用脏检查的流程。

Vue.js的变化侦测和它们都不一样，它在一定程度上知道具体哪些状态发生了变化，这样就可以通过更细粒度的绑定来更新视图。也就是说，在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对。事实上，在Vue.js 1.0的时候就是这样实现的。

但是这样做其实也有一定的代价。因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及一些依赖追踪的开销。当状态被越多的节点使用时，开销就越大。对于一个大型项目来说，这个开销是非常大的。

**因此，Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入了虚拟DOM。**组件级别是一个watcher实例，就是说即便一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对与渲染。这是一个比较折中的方案。

Vue.js之所以能随意调整绑定的粒度，本质上还要归功于变化侦测。关于Vue.js的变化侦测原理，我们在第3章中已经详细介绍过。

## 5.3　Vue.js中的虚拟DOM

在Vue.js中，我们使用模板来描述状态与DOM之间的映射关系。Vue.js通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面，具体如图5-4所示。

![image-20210524154538259](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154538259.png)

**虚拟DOM的终极目标是将虚拟节点（vnode）渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。**

**例如**，一个ul标签下有很多li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替换旧的ul，其实除了那个发生了变化的li节点之外，其他节点都不需要重新渲染。

由于DOM操作比较慢，所以这些DOM操作在性能上会有一定的浪费，避免这些不必要的DOM操作会提升很大一部分性能。

**为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。**

图5-5给出了虚拟DOM的整体运行流程，先将vnode与oldVnode做比对，然后再更新视图。

![image-20210524154708894](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154708894.png)

**图5-5　虚拟DOM的执行流程**

可以看出，**虚拟DOM在Vue.js中所做的事情其实并没有想象中那么复杂，它主要做了两件事。**

​	● 提供与真实DOM节点所对应的虚拟节点vnode。

​	● 将虚拟节点vnode和旧虚拟节点oldVnode进行比对，然后更新视图。

对两个虚拟节点进行比对是虚拟DOM中最核心的算法（即patch），它可以判断出哪些节点发生了变化，从而只对发生了变化的节点进行更新操作。关于patch，我们会在第7章中详细介绍。

## 5.4　总结

虚拟DOM是将状态映射成视图的众多解决方案中的一种，它的运作原理是使用状态生成虚拟节点，然后使用虚拟节点渲染视图。

之所以需要先使用状态生成虚拟节点，是因为如果直接用状态生成真实DOM，会有一定程度的性能浪费。而先创建虚拟节点再渲染视图，就可以将虚拟节点缓存，然后使用新创建的虚拟节点和上一次渲染时缓存的虚拟节点进行对比，然后根据对比结果只更新需要更新的真实DOM节点，从而避免不必要的DOM操作，节省一定的性能开销。

由于Vue.js的变化侦测粒度更细，所以当状态发生变化时，Vue.js知道的信息更多，一定程度上可以知道哪些位置使用了状态。因此，Vue.js可以通过细粒度的绑定来更新视图，Vue.js 1.0就是这样实现的。

但是这样做也有一定的代价。因为粒度太细，就会有很多watcher同时观察某些状态，会有一些内存开销以及一些依赖追踪的开销，所以Vue.js 2.0采取了一个中等粒度的解决方案，状态侦测不再细化到某个具体节点，而是某个组件，组件内部通过虚拟DOM来渲染视图，这可以大大缩减依赖数量和watcher数量。

Vue.js中通过模板来描述状态与视图之间的映射关系，所以它会先将模板编译成渲染函数，然后执行渲染函数生成虚拟节点，最后使用虚拟节点更新视图。

**因此，虚拟DOM在Vue.js中所做的事是提供虚拟节点vnode和对新旧两个vnode进行比对，并根据比对结果进行DOM操作来更新视图。**

# 第 6 章　VNode

在虚拟DOM中，VNode是比较重要的知识点。本章中，我们将详细介绍什么是VNode，VNode的作用，以及不同类型的VNode之间有什么区别。

## 6.1　什么是VNode

在Vue.js中存在一个VNode类，使用它可以实例化不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。

例如，DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。

VNode类的代码如下：

![image-20210524155639538](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524155639538.png)

从上面的代码可以看出，vnode只是一个名字，本质上其实是JavaScript中一个普通的对象，是从VNode类实例化的对象。我们用这个JavaScript对象来描述一个真实DOM元素的话，那么该DOM元素上的所有属性在VNode这个对象上都存在对应的属性。

**简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。**

例如，tag表示一个元素节点的名称，text表示一个文本节点的文本，children表示子节点等。

vnode表示一个真实的DOM元素，所有真实的DOM节点都使用vnode创建并插入到页面中，如图6-1所示。

![image-20210524155900675](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524155900675.png)

**图6-1　VNode创建DOM并插入到视图**

图6-1展示了使用vnode创建真实DOM并渲染到视图的过程。可以得知，vnode和视图是一一对应的。我们可以把vnode理解成JavaScript对象版本的DOM元素。

从图6-1还可以得知，渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后插入到页面渲染视图。

## 6.2　VNode的作用

由于每次渲染视图时都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的vnode缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之间有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM。

**Vue.js目前对状态的侦测策略采用了中等粒度。当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图。**

如图6-2所示，当某个状态发生改变时，只通知使用了这个状态的组件（图6-2通知了第二个组件）。

![image-20210524160209390](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160209390.png)

也就是说，只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染。

**如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。这也是vnode最重要的一个作用。**

## 6.3　VNode的类型

vnode的类型有以下几种：

● 注释节点

● 文本节点

● 元素节点

● 组件节点

● 函数式组件

● 克隆节点

前面我们介绍了什么是vnode，知道vnode是JavaScript中的一个对象，不同类型的vnode之间其实只是属性不同，准确地说是有效属性不同。因为当使用VNode类创建一个vnode时，通过参数为实例设置属性时，无效的属性会默认被赋值为undefined或false。对于vnode身上的无效属性，直接忽略就好。接下来，我们详细讨论这些类型的vnode都有哪些有效属性。

### 6.3.1　注释节点

由于创建注释节点的过程非常简单，所以直接通过代码来介绍它有哪些属性：

![image-20210524160634820](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160634820.png)

可以看出，一个注释节点只有两个有效属性——text和isComment，其余属性全是默认的undefined或者false。

例如，一个真实的注释节点：

![image-20210524160654036](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160654036.png)

所对应的vnode是下面的样子：

![image-20210524160709652](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160709652.png)

### 6.3.2　文本节点

文本节点的创建过程也非常简单，我们也可以直接通过代码来了解它有哪些有效属性：

![image-20210524160819587](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160819587.png)

通过上面的代码可以了解到，当文本类型的vnode被创建时，它只有一个text属性：

![image-20210524160830395](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160830395.png)

上面代码所展示的对象就是文本类型的vnode。

### 6.3.3　克隆节点

克隆节点是将现有节点的属性复制到新节点中，让新创建的节点和被克隆节点的属性保持一致，从而实现克隆效果。**它的作用是优化静态节点和插槽节点（slotnode）。**

以静态节点为例，当组件内的某个状态发生变化后，当前组件会通过虚拟DOM重新渲染视图，静态节点因为它的内容不会改变，所以除了首次渲染需要执行渲染函数获取vnode之外，后续更新不需要执行渲染函数重新生成vnode。因此，这时就会使用创建克隆节点的方法将vnode克隆一份，使用克隆节点进行渲染。这样就不需要重新执行渲染函数生成新的静态节点的vnode，从而提升一定程度的性能。

由于创建克隆节点的过程不复杂，所以还是直接通过代码来了解：

![image-20210524161409858](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161409858.png)

可以看出，克隆现有节点时，只需要将现有节点的属性全部复制到新节点中即可。克隆节点和被克隆节点之间的唯一区别是isCloned属性，克隆节点的isCloned为true，被克隆的原始节点的isCloned为false。

### 6.3.4　元素节点

元素节点通常会存在以下4种有效属性。

● tag：顾名思义，tag就是一个节点的名称，例如p、ul、li和div等。

● data：该属性包含了一些节点上的数据，比如attrs、class和style等。

● children：当前节点的子节点列表。

● context：它是当前组件的Vue.js实例。

例如，一个真实的元素节点：

![image-20210524161717987](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161717987.png)

所对应的vnode是下面的样子：

![image-20210524161748330](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161748330.png)

### 6.3.5　组件节点

组件节点和元素节点类似，有以下两个独有的属性。

● componentOptions：顾名思义，就是组件节点的选项参数，其中包含propsData、tag和children等信息。

● componentInstance：组件的实例，也是Vue.js的实例。事实上，在Vue.js中，每个组件都是一个Vue.js实例。

一个组件节点：

![image-20210524162029904](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162029904.png)

所对应的vnode是下面的样子：

![image-20210524162051130](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162051130.png)

### 6.3.6　函数式组件

函数式组件和组件节点类似，它有两个独有的属性functionalContext和functionalOptions。

通常，一个函数式组件的vnode是下面的样子：

![image-20210524162839529](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162839529.png)

## 6.4　总结

VNode是一个类，可以生成不同类型的vnode实例，而不同类型的vnode表示不同类型的真实DOM元素。

由于Vue.js对组件采用了虚拟DOM来更新视图，当属性发生变化时，整个组件都要进行重新渲染的操作，但组件内并不是所有DOM节点都需要更新，所以将vnode缓存并将当前新生成的vnode和上一次缓存的oldVnode进行对比，只对需要更新的部分进行DOM操作可以提升很多性能。

vnode有多种类型，它们本质上都是从VNode类实例化出的对象，其唯一区别只是属性不同。

# 第 7 章　patch

**虚拟DOM最核心的部分是patch，它可以将vnode渲染成真实的DOM。**

patch也可以叫作patching算法，通过它渲染真实DOM时，**并不是暴力覆盖原有DOM，而是比对新旧两个vnode之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新**。这一点从名字就可以看出，patch本身就有补丁、修补等意思，**其实际作用是在现有DOM上进行修改来实现更新视图的目的。**

之所以要这么做，主要是因为DOM操作的执行速度远不如JavaScript的运算速度快。因此，把大量的DOM操作搬运到JavaScript中，使用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提升性能。这本质上其实是使用JavaScript的运算成本来替换DOM操作的执行成本，而JavaScript的运算速度要比DOM快很多，这样做很划算，所以才会有虚拟DOM。

## 7.1　patch介绍

对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的其实是修改DOM节点，也可以理解为渲染视图。上面说过，patch不是暴力替换节点，而是在现有DOM上进行修改来达到渲染视图的目的。对现有DOM进行修改需要做三件事：

● 创建新增的节点；

● 删除已经废弃的节点；

● 修改需要更新的节点。

**我们知道patch的过程其实就是创建节点、删除节点和修改节点的过程**，接下来主要讨论在什么情况下创建新节点，插入到什么位置；在什么情况下删除节点，删除哪个节点；在什么情况下修改节点，修改哪个节点等。

在详细讨论什么情况下需要对节点进行更改之前，我们需要先弄清楚一个问题。

事实上，我一再强调：**之所以需要通过算法来比对两个节点之间的差异，并针对不同的节点进行更新，主要是为了性能考虑。**

我们完全可以把整个旧节点从DOM中删除，然后使用最新的状态（state）重新生成一份全新的节点并插入到DOM中，这种方式完全可以实现功能。

由于我们的最终目的是渲染视图，所以可以发现渲染视图的标准是以vnode（使用最新状态创建的vnode）来渲染而不是oldVnode（上一次渲染DOM所创建的vnode）。

**也就是说，当oldVnode和vnode不一样的时候，以vnode为准来渲染视图。**

### 7.1.1　新增节点

本节中，我们主要讨论在什么情况下新增节点。之所以讨论什么情况下需要新增节点，本质上是为了使用JavaScript的计算成本来换取DOM的操作成本。如果一个节点已经存在于DOM中，那就不需要重新创建一个同样的节点去替换已经存在的节点。**事实上，只有那些因为状态的改变而新增的节点在DOM中并不存在时，我们才需要创建一个节点并插入到DOM中。**

**首先，新增节点的一个很明显的场景就是，当oldVnode不存在而vnode存在时，就需要使用vnode生成真实的DOM元素并将其插入到视图当中去。**

这通常会发生在首次渲染中。因为首次渲染时，DOM中不存在任何节点，所以oldVnode是不存在的。

![image-20210524203657046](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524203657046.png)

![image-20210524203713982](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524203713982.png)



除了上面介绍的情况需要新增节点之外，还有一种情况也需要新增节点。

**前面介绍过，当oldVnode和vnode不一样的时候，以vnode为标准来渲染视图。因此，当vnode和oldVnode完全不是同一个节点的时候，可以得知vnode就是一个全新的节点，而oldVnode就是一个被废弃的节点。**

这种情况下，我们要做的事情就是使用vnode创建一个新DOM节点，用它去替换oldVnode所对应的真实DOM节点，如图7-3所示。

![image-20210524203819010](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524203819010.png)

### 7.1.2　删除节点

**删除节点的场景上一节略有提及，就是当一个节点只在oldVnode中存在时，我们需要把它从DOM中删除**。因为渲染视图时，需要以vnode为标准，所以vnode中不存在的节点都属于被废弃的节点，而被废弃的节点需要从DOM中删除。

如图7-3所示，当oldVnode和vnode完全不是同一个节点时，在DOM中需要使用vnode创建的新节点替换oldVnode所对应的旧节点，而替换过程是将新创建的DOM节点插入到旧节点的旁边，然后再将旧节点删除，从而完成替换过程。

### 7.1.3　更新节点

前面介绍了新增节点和删除节点的场景，我们发现它们之间有一个共同点，那就是两个虚拟节点是完全不同的。由于我们需要以新节点为标准渲染视图，所以这个时候只有两种操作可以执行：将旧节点删除或者创建新增节点。

**其实除了前面介绍的场景外，另一个更常见的场景是新旧两个节点是同一个节点。当新旧两个节点是相同的节点时，我们需要对这两个节点进行比较细致的比对，然后对oldVnode在视图中所对应的真实节点进行更新。**

**举个简单的例子**，当新旧两个节点是同一个文本节点，但是两个节点的文本不一样时，我们需要重新设置oldVnode在视图中所对应的真实DOM节点的文本。

图7-4给出了用vnode中的文字替换DOM中文字的过程。视图中的文本节点所包含的文字是“我是文字”，而当状态发生变化时，将文本改成了“我是文字2”，这时使用改变后的状态生成了新的vnode，然后将vnode与oldVnode进行比对，发现它们是同一个节点，再将这两个节点进行更详细的比对，比对结果是文字发生了变化，最后将真实DOM节点中的文本改成了vnode中的文字“我是文字2”。

![image-20210524204105927](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524204105927.png)

### 7.1.4　小结

通过前面的介绍，可以发现整个patch的过程并不复杂。当oldVnode不存在时，直接使用vnode渲染视图；当oldVnode和vnode都存在但并不是同一个节点时，使用vnode创建的DOM元素替换旧的DOM元素；当oldVnode和vnode是同一个节点时，使用更详细的对比操作对真实的DOM节点进行更新。

图7-5给出了patch的运行流程。

![image-20210524204257975](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524204257975.png)

## 7.2　创建节点

在创建DOM元素时，最重要的事是根据vnode的类型来创建出相同类型的DOM元素，然后将DOM元素插入到视图中。

事实上，**只有三种类型的节点会被创建并插入到DOM中**：元素节点、注释节点和文本节点。

而要**判断vnode是否是元素节点，只需要判断它是否具有tag属性即可**。如果一个vnode具有tag属性，就认为它是元素属性。接着，我们就可以调用当前环境下的**createElement方法**（在浏览器环境下就是document.createElement）来**创建真实的元素节点**。当一个元素节点被创建后，接下来要做的事情就是将它插入到指定的父节点中。

**将元素渲染到视图的过程非常简单。只需要调用当前环境下的appendChild方法**（在浏览器环境下就是调用parentNode.appendChild），就可以将一个元素插入到指定的父节点中。如果这个指定的父节点已经被渲染到视图，那么把元素插入到它的下面将会自动将元素渲染到视图。

其实创建元素节点还缺了一个步骤，我们刚刚没有说。元素节点通常都会有子节点（children），所以当一个元素节点被创建后，我们需要将它的子节点也创建出来并插入到这个刚创建出的节点下面。

**创建子节点的过程是一个递归过程**。vnode中的children属性保存了当前节点的所有子虚拟节点（child virtual node），所以只需要将vnode中的children属性循环一遍，将每个子虚拟节点都执行一遍创建元素的逻辑，就可以实现我们想要的功能。

创建子节点时，子节点的父节点就是当前刚创建出来的这个节点，所以子节点被创建后，会被插入到当前节点的下面。当所有子节点都创建完并插入到当前节点中之后，我们把当前节点插入到指定父节点的下面。如果这个指定的父节点已经被渲染到视图中，那么将当前这个节点插入进去之后，会将当前节点（包括其子节点）渲染到视图中。

**图7-6给出了从虚拟DOM创建真实DOM，最后渲染到视图的过程。**

![image-20210524205137784](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524205137784.png)

图7-7给出了一个元素节点从创建到渲染视图的过程。

<img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524205218298.png" alt="image-20210524205218298" style="zoom:150%;" />

图7-7　创建元素节点并将其渲染到视图的过程

除了元素节点外，其实还要创建注释节点和文本节点。

**在创建节点时，如果vnode中不存在tag属性，那么它可能会是另外两种节点：注释节点和文本节点。**

在第6章中介绍VNode时，我们介绍过**注释节点有一个唯一的标识属性isComment**。在所有类型的vnode中，只有注释节点的isComment属性是true，所以通过isComment属性就可以判断一个vnode是否是注释节点。

当发现一个vnode的tag属性不存在时，我们可以用isComment属性来判断它是注释节点还是文本节点。**如果是文本节点，则调用当前环境下的createTextNode方法（浏览器环境下调用document.createTextNode）来创建真实的文本节点并将其插入到指定的父节点中；如果是注释节点，则调用当前环境下的createComment方法（浏览器环境下调用document.createComment方法）来创建真实的注释节点并将其插入到指定的父节点中。**

![image-20210524205415724](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524205415724.png)

## 7.3　删除节点(不懂)

在7.1.2节中，我们介绍了在什么情况下需要将元素从视图中删除。本节中，我们将详细介绍一个元素是怎样从视图中删除的。

删除节点的过程非常简单。在Vue.js源码中，删除元素的代码并不多，其实现逻辑如下：

![image-20210524205635417](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524205635417.png)

简单来说，上面代码实现的功能是删除vnodes数组中从startIdx指定的位置到endIdx指定位置的内容。

**removeNode用于删除视图中的单个节点，而removeVnodes用于删除一组指定的节点。**

removeNode的实现逻辑如下：

![image-20210524205843769](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524205843769.png)

上面代码的逻辑是将当前元素从它的父节点中删除，其中nodeOps是对节点操作的封装。

有同学可能会对nodeOps感到奇怪，为什么不直接使用parent.removeChild(child)删除节点，而是将这个节点操作封装成函数放在nodeOps里呢？

其实这涉及跨平台渲染的知识，我们知道阿里开发的Weex可以让我们使用相同的组件模型为iOS和Android编写原生渲染的应用。也就是说，我们写的Vue.js组件可以分别在iOS和Android环境中进行原生渲染。

而跨平台渲染的本质是在设计框架的时候，要让框架的渲染机制和DOM解耦。只要把框架更新DOM时的节点操作进行封装，就可以实现跨平台渲染，在不同平台下调用节点的操作。

这就是将removeChild方法封装到nodeOps中的原因。更多关于跨平台渲染的内容已超出本章的讨论范围，这里不再展开讨论。

## 7.4　更新节点

在7.1.3节中，我们介绍了只有两个节点是同一个节点时，才需要更新元素节点，而更新节点并不是很暴力地使用新节点覆盖旧节点，而是通过比对找出新旧两个节点不一样的地方，针对那些不一样的地方进行更新。本节中，我们将介绍节点更新的详细过程。

### 7.4.1　静态节点

**在更新节点时，首先需要判断新旧两个虚拟节点是否是静态节点，如果是，就不需要进行更新操作，可以直接跳过更新节点的过程。**

**什么是静态节点？**

静态节点指的是那些一旦渲染到界面上之后，无论日后状态如何变化，都不会发生任何变化的节点。（tips：没有变量绑定，写死）

例如：

![image-20210524210317572](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524210317572.png)

上面这个HTML就是一个静态节点，它不会因为状态的变化而发生变化。这个节点一旦被渲染到视图之后，当应用在运行时，无论状态是否发生变化，都不会影响到这个节点，这个节点永远都不需要重新渲染。

### 7.4.2　新虚拟节点有文本属性

当新旧两个虚拟节点（vnode和oldVnode）不是静态节点，并且有不同的属性时，要以新虚拟节点（vnode）为准来更新视图。根据新节点（vnode）是否有text属性，更新节点可以分为两种不同的情况。

**如果新生成的虚拟节点（vnode）有text属性，那么不论之前旧节点的子节点是什么，直接调用setTextContent方法（在浏览器环境下是node.textContent方法）来将视图中DOM节点的内容改为虚拟节点（vnode）的text属性所保存的文字。**

**因为更新是以新创建的虚拟节点（vnode）为准的，所以如果新创建的虚拟节点有文本，那么根本就不需要关心之前旧节点中所包含的内容是什么，无论是文本还是元素节点，这都不重要。唯一需要关心的是，如果之前的旧节点也是文本，并且和新节点的文本相同，那么就不需要执行setTextContent方法来重复设置相同的文本。**

**简单来说，就是当新虚拟节点有文本属性，并且和旧虚拟节点的文本属性不一样时，我们可以直接把视图中的真实DOM节点的内容改成新虚拟节点的文本。**

### **7.4.3　新虚拟节点无文本属性**

如果新创建的虚拟节点没有text属性，那么它就是一个元素节点。元素节点通常会有子节点，也就是children属性，但也有可能没有子节点，所以存在两种不同的情况。

**有children的情况**

当新创建的虚拟节点有children属性时，其实还会有两种情况，那就是要看旧虚拟节点（oldVnode）是否有children属性。

**如果旧虚拟节点也有children属性**，那么我们要对新旧两个虚拟节点的children进行一个更详细的对比并更新。更新children可能会移动某个子节点的位置，也有可能会删除或新增某个子节点，具体更新children的过程我们会在7.5节中详细介绍。

**如果旧虚拟节点没有children属性**，那么说明旧虚拟节点要么是一个空标签，要么是有文本的文本节点。如果是文本节点，那么先把文本清空让它变成空标签，然后将新虚拟节点（vnode）中的children挨个创建成真实的DOM元素节点并将其插入到视图中的DOM节点下面。

**无children的情况**

当新创建的虚拟节点既没有text属性也没有children属性时，这说明这个新创建的节点是一个空节点，它下面既没有文本也没有子节点，这时如果旧虚拟节点（oldVnode）中有子节点就删除子节点，有文本就删除文本。有什么删什么，最后达到视图中是空标签的目的。

### 7.4.4　小结

本节重点讨论了更新节点的详细过程以及处理逻辑，讨论的内容包括新虚拟节点有文本时如何处理，有children属性时如何处理，以及没有children属性时怎么处理等。图7-9给出了更新节点的整体逻辑。

![image-20210524211300932](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524211300932.png)

在源码中，真实的实现过程如图7-10所示。

![image-20210524211502518](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524211502518.png)

图7-10　更新节点的具体实现过程

## 7.5　更新子节点

在7.4节中，我们详细讨论了更新节点的过程，其中讨论了当新节点的子节点和旧节点的子节点都存在并且不相同时，会进行子节点的更新操作。但我们并没有详细讨论子节点是如何更新的，本节将详细讨论如何更新子节点。

事实上，**更新子节点大概可以分为4种操作：更新节点、新增节点、删除节点、移动节点位置**。因此，更新子节点更多的是在讨论什么情况下需要更新节点，什么情况下新增节点等。

**更新子节点首先要对比两个子节点都有哪些不同，然后针对不同的情况做不同的处理。**

**例如**，newChildren（新子节点列表）中有一个节点在oldChildren（旧子节点列表）中找不到相同的节点，这说明这个节点是因本次状态更改而新增的节点，此时就需要进行新增节点的操作。

**再例如**，newChildren中的某个节点和oldChildren中的某个节点是同一个节点，但位置不同，这说明这个节点是由于状态变化而位置发生了移动的节点，这时需要进行节点移动的操作。

**对比两个子节点列表（children），首先需要做的事情是循环。循环newChildren（新子节点列表），每循环到一个新子节点，就去oldChildren（旧子节点列表）中找到和当前节点相同的那个旧子节点。**如果在oldChildren中找不到，说明当前子节点是由于状态变化而新增的节点，我们要进行创建节点并插入视图的操作；如果找到了，就做更新操作；如果找到的旧子节点的位置和新子节点不同，则需要移动节点等。

### 7.5.1　更新策略

本节主要针对新增节点、更新节点、移动节点、删除节点等操作进行讨论。

#### **创建子节点**

关于新增节点，我们主要讨论什么情况下需要创建节点，以及把创建的节点插入到真实DOM子节点中哪个位置的问题。

前面提到过，新旧两个子节点列表是通过循环进行比对的，所以创建节点的操作是在循环体内执行的，其具体实现是在oldChildren（旧子节点列表）中寻找本次循环所指向的新子节点。

如果在oldChildren中没有找到与本次循环所指向的新子节点相同的节点，那么说明本次循环所指向的新子节点是一个新增节点。**对于新增节点，我们需要执行创建节点的操作，并将新创建的节点插入到oldChildren中所有未处理节点（未处理就是没有进行任何更新操作的节点）的前面。当节点成功插入DOM后，这一轮的循环就结束了。**关于创建节点，我们在7.2节中详细介绍过。

**你可能会对为什么插入到oldChildren中所有未处理节点的前面感到很困惑**，没关系，下面我们举例说明一下。

我们先看图7-11所示的例子，最上面的DOM节点是视图中的真实DOM节点。左下角的节点是新创建的虚拟节点，右下角的节点是旧的虚拟节点。

![image-20210524212235772](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524212235772.png)

图7-11表示已经对前两个子节点进行了更新，当前正在处理第三个子节点。当在右下角的虚拟子节点中找不到与左下角的第三个节点相同的节点时，证明它是新增节点，**这时候需要创建节点并插入到真实DOM中，插入的位置是所有未处理节点的前面，也就是虚线所指定的位置。**

**你可能会说，插入到所有已处理节点的后面不也行吗？不是的，如果这个新节点后面也是一个新增节点呢？**

图7-12是我们希望插入到真实DOM中的位置。而如果以插入到已处理节点后面这样的逻辑插入节点，则会出现如图7-13所示的问题。

![image-20210524212518006](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524212518006.png)

图7-12　插入到未处理节点的前面

![image-20210524212554751](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524212554751.png)

从图7-13中我们会发现，节点插入的位置不是我们希望插入的位置，因为顺序反了，这个节点的位置应该是第四位，而不是第三位。你可能会问，为什么？

**因为我们是使用虚拟节点进行对比，而不是真实DOM节点做对比，所以是左下角的虚拟节点和右下角的旧虚拟节点进行对比，而右下角的虚拟节点表示已处理的节点只有两个，不包括我们新插入的节点，所以用插入到已处理节点后面这样的逻辑来插入节点，就会插入一个错误的位置。**

可能你现在又有疑问了，节点插入进真实DOM中后，真实DOM中的节点越来越多，为什么没看见删除节点的逻辑？

关于删除节点的逻辑，我们将在后面详细介绍。

#### 更新子节点

更新节点本质上是当一个节点同时存在于newChildren和oldChildren中时需要执行的操作。

如图7-14所示，两个节点是同一个节点并且位置相同，这种情况下只需要进行更新节点的操作即可。关于更新节点，我们在7.4节中已详细介绍过。

![image-20210524212934457](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524212934457.png)

图7-14　子节点位置相同

**但如果oldChildren中子节点的位置和本次循环所指向的新子节点的位置不一致时**，除了对真实DOM节点进行更新操作外，我们还需要对这个真实DOM节点进行移动节点的操作。

#### 移动子节点（有不懂的地方）

移动节点通常发生在newChildren中的某个节点和oldChildren中的某个节点是同一个节点，但是位置不同，所以在真实的DOM中需要将这个节点的位置以新虚拟节点的位置为基准进行移动。

如图7-15所示，当oldChildren中找到的节点和newChildren中的节点位置不同时，视图中真实DOM节点就会移动到newChildren中节点所在的位置。

![image-20210524213058447](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524213058447.png)

**通过Node.insertBefore()方法，我们可以成功地将一个已有节点移动到一个指定的位置。**

**但怎么得知新虚拟节点的位置是哪里呢？换句话说，怎么知道应该把节点移动到哪里呢？（不懂）**

其实得到这个位置并不难。对比两个子节点列表是通过从左到右循环newChildren这个列表，然后每循环一个节点，就去oldChildren中寻找与这个节点相同的节点进行处理。也就是说，newChildren中当前被循环到的这个节点的左边都是被处理过的。那就不难发现，这个节点的位置是所有未处理节点的第一个节点。

所以，只要把需要移动的节点移动到所有未处理节点的最前面，就能实现我们的目的，如图7-16所示。

![image-20210524213232688](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524213232688.png)

图7-16表示正在处理第三个节点，这时在oldChildren中找到的相同节点是第四个节点。由于位置不同，所以需要移动节点，移动节点的位置是所有未处理节点的最前面。本例中，将第四个节点移动到所有未处理节点的最前面，就是将节点从第四个变成了第三个。

节点更新并且移动完位置后，开始进行下一轮循环，也就是开始处理newChildren中的第四个节点。

关于怎么分辨哪些节点是处理过的，哪些节点是未处理的，我们将在7.5.3节中详细讨论。

#### 删除子节点

**删除子节点，本质上是删除那些oldChildren中存在但newChildren中不存在的节点。**

用图7-12来举例，左下角的newChildren和右下角的oldChildren中前两个节点是相同的。在newChildren中，右面两个节点是新增节点；在oldChildren中，右边两个节点是废弃的需要被删除的节点。

可以得出结论，当newChildren中的所有节点都被循环了一遍后，也就是循环结束后，如果oldChildren中还有剩余的没有被处理的节点，那么这些节点就是被废弃、需要删除的节点。

在图7-12中，真实DOM节点中有6个节点，其中最右面的两个节点是需要删除的节点，当这些废弃的节点被删除后，你会发现真实DOM中的子节点和newChildren变成一样的了。这不正是我们想要的效果吗？

### 7.5.2　优化策略

通常情况下，并不是所有子节点的位置都会发生移动，一个列表中总有几个节点的位置是不变的。针对这些位置不变的或者说位置可以预测的节点，我们不需要循环来查找，因为我们有一个更快捷的查找方式。

假设有一个场景，我们只是修改了列表中某个数据的内容，而没有新增数据或者删除数据等，这种情况下newChildren和oldChildren中所有节点的位置都是相同的，这时节点的位置就是可以预测的，不需要循环也可以知道oldChildren中的哪个节点和被寻找的新子节点是同一个节点。

只需要尝试使用相同位置的两个节点来比对是否是同一个节点：如果恰巧是同一个节点，直接就可以进入更新节点的操作；如果尝试失败了，再用循环的方式来查找节点。

这样做可以很大程度地避免循环oldChildren来查找节点，从而使执行速度得到很大的提升。

如果我们把这种很快速的查找节点的方式称为快捷查找，那么它共有4种查找方式，分别是：

● 新前与旧前

● 新后与旧后

● 新后与旧前

● 新前与旧后

你可能会对“新前”“旧前”这些名词感到困惑，没关系，因为这是我自己起的名字。接下来，我将详细介绍这些名词都是什么意思。

从图7-17中可以看出“新前”“新后”“旧前”“旧后”这4个名词分别对应4个节点，图中有两个虚拟节点，左边那个虚拟节点是由于状态的变化而新生成的虚拟节点，右边那个虚拟节点是上一次渲染DOM时用的旧的虚拟节点。

● 新前：newChildren中所有未处理的第一个节点。

● 新后：newChildren中所有未处理的最后一个节点。

● 旧前：oldChildren中所有未处理的第一个节点。

● 旧后：oldChildren中所有未处理的最后一个节点。

![image-20210524215502518](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524215502518.png)

图7-17　“新前”“新后”“旧前”“旧后”所代表的节点

**新前与旧前**顾名思义，“新前”与“旧前”的意思就是尝试使用“新前”这个节点与“旧前”这个节点对比，对比它们俩是不是同一个节点。如果是同一个节点，则说明我们不费吹灰之力就在oldChildren中找到了这个虚拟节点，然后使用7.4节中介绍的更新节点操作将它们俩进行对比并更新视图，如图7-18所示。

![image-20210524215555935](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524215555935.png)

由于“新前”与“旧前”的位置相同，所以并不需要执行移动节点的操作，只需要更新节点即可。

如果不是同一个节点，没关系，一共有4种快捷查找方式，挨个试一遍即可。如果都不行，最后再使用循环来查找节点。

**新后与旧后**

当“新前”与“旧前”对比后发现不是同一个节点，这时可以尝试用“新后”与“旧后”的方式来比对它们俩是否是同一个节点。

“新后”与“旧后”的意思是使用“新后”这个节点和“旧后”这个节点对比，对比它们俩是不是同一个节点。如果是同一个节点，就将这两个节点进行对比并更新视图，如图7-19所示。

![image-20210524215731255](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524215731255.png)

由于“新后”与“旧后”这两个节点的位置相同，所以只需要执行更新节点的操作即可，不需要执行移动节点的操作。

如果对比之后发现“新后”和“旧后”也不是同一个节点，则继续尝试对比“新后”与“旧前”是否是同一个节点。

**新后与旧前**

“新后”与“旧前”的意思是使用“新后”这个节点与“旧前”这个节点进行对比，通过对比来分辨它们俩是不是同一个节点。如果是同一个节点，就对比它们俩并更新视图，如图7-20所示。

![image-20210524215833778](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524215833778.png)

如果“新后”与“旧前”是同一个节点，那么由于它们的位置不同，所以除了更新节点外，还需要执行移动节点的操作，如图7-21所示。

![image-20210524215848739](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524215848739.png)

从图7-21中可以看出，当“新后”与“旧前”是同一个节点时，在真实DOM中除了做更新操作外，还需要将节点移动到oldChildren中所有未处理节点的最后面。

你可能对为什么移动到oldChildren中所有未处理节点的最后面感到困惑，接下来我们会详细介绍为什么移动到这个位置。

更新节点是以新虚拟节点为基准，子节点也不例外，所以在图7-21中，因为“新后”这个节点是最后一个节点，所以真实DOM中将节点移动到最后不难理解，让我们感到困惑的是为什么移动到oldChildren中所有未处理节点的最后面。

这里我们举个例子，如图7-22所示。

![image-20210524220027883](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220027883.png)

如图7-22所示，当真实DOM子节点左右两侧已经有节点被更新，只有中间这部分节点未处理时，“新后”这个节点是未处理节点中的最后一个节点，所以真实DOM节点移动位置时，需要移动到oldChildren中所有未处理节点的最后面。只有移动到未处理节点的最后面，它的位置才与“新后”这个节点的位置相同。

如果对比之后发现这两个节点也不是同一个节点，则继续尝试对比“新前”与“旧后”是否是同一个节点。

**新前与旧后**

“新前”与“旧后”的意思是使用“新前”与“旧后”这两个节点进行对比，对比它们是否是同一个节点，如果是同一个节点，则进行更新节点的操作，如图7-23所示。

![image-20210524220142451](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220142451.png)

由于“新前”与“旧后”这两个节点的位置不同，所以除了更新节点的操作外，还需要进行移动节点的操作，如图7-24所示。

![image-20210524220157962](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220157962.png)

从图7-24中可以看出，当“新前”与“旧后”是同一个节点时，在真实DOM中除了做更新操作外，还需要将节点移动到oldChildren中所有未处理节点的最前面。

将节点移动到oldChildren中所有未处理节点的最前面的原因，与前面介绍的“新后”与“旧前”的逻辑是一样的，如图7-25所示。

![image-20210524220211238](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220211238.png)

**也就是说，已更新过的节点都不用管。因为更新过的节点无论是节点的内容或者节点的位置，都是正确的，更新完后面就不需要再进行更改了。所以，我们只需要在所有未更新的节点区间内进行移动和更新操作即可。**

**如果前面这4种方式对比之后都没找到相同的节点，这时再通过循环的方式去oldChildren中详细找一圈，看看能否找到。大部分情况下，通过前面这4种方式就可以找到相同的节点，所以节省了很多次循环操作。**

### 7.5.3　哪些节点是未处理过的（还没看）

### 7.5.4　小结（还没看）

# 第三篇　模板编译原理

在Vue.js中创建HTML并不是只有模板这一种途径，我们既可以手动写渲染函数来创建HTML，也可以在Vue.js中使用JSX来创建HTML。

渲染函数是创建HTML最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份vnode用于虚拟DOM渲染。所以模板编译其实是配合虚拟DOM进行渲染。

本篇中，我们将会详细介绍模板转换成渲染函数的详细过程。

# 第 8 章　模板编译

在上一篇中，我们详细介绍了虚拟DOM，其中介绍的大部分知识都是关于虚拟DOM拿到vnode后所做的事，而模板编译所介绍的内容是如何让虚拟DOM拿到vnode。**图8-1给出了模板编译在整个渲染过程中的位置。**

![image-20210524220535333](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220535333.png)

Vue.js提供了模板语法，允许我们声明式地描述状态和DOM之间的绑定关系，然后通过模板来生成真实DOM并将其呈现在用户界面上。

**在底层实现上，Vue.js会将模板编译成虚拟DOM渲染函数。当应用内部的状态发生变化时，Vue.js可以结合响应式系统，聪明地找出最小数量的组件进行重新渲染以及最少量地进行DOM操作。**

## 8.1　概念

平时使用模板时，可以在模板中使用一些变量来填充模板，还可以在模板中使用JavaScript表达式，又或者是使用一些指令等。

**这些功能在HTML语法中是不存在的，那么为什么在Vue.js的模板中就可以使用各种很灵活的语法呢？这就多亏了模板编译赋予了模板强大的功能。**

**模板编译的主要目标就是生成渲染函数，如图8-2所示。而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这个vnode进行渲染。**

![image-20210524220726365](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524220726365.png)

那么，如何将模板编译成渲染函数呢？

## 8.2　将模板编译成渲染函数

**将模板编译成渲染函数可以分两个步骤**，先将模板解析成AST（Abstract SyntaxTree，抽象语法树），然后再使用AST生成渲染函数。

**但是由于静态节点不需要总是重新渲染，所以在生成AST之后、生成渲染函数之前这个阶段，需要做一个操作，那就是遍历一遍AST，给所有静态节点做一个标记，这样在虚拟DOM中更新节点时，如果发现节点有这个标记，就不会重新渲染它。**

所以，在**大体逻辑上，模板编译分三部分内容**：

● 将模板解析为AST

● 遍历AST标记静态节点

● 使用AST生成渲染函数

**这三部分内容在模板编译中分别抽象出三个模块来实现各自的功能，分别是**：

● 解析器

● 优化器

● 代码生成器

**图8-3给出了模板编译的整体流程。**

![image-20210524221004646](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221004646.png)

**图8-3　模板编译的整体流程**

### 8.2.1　解析器

在解析器内部，分成了很多小解析器，其中包括过滤器解析器、文本解析器和HTML解析器。然后通过一条主线将这些解析器组装在一起，如图8-4所示。

![image-20210524221036576](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221036576.png)

**图8-4　解析器**

在使用模板时，我们可以在其中使用过滤器，而过滤器解析器的作用就是用来解析过滤器的。

**顾名思义，文本解析器就是用来解析文本的。你可能会问，文本就是一段文字，有什么好解析的？**

其实文本解析器的主要作用是用来解析带变量的文本，什么是带变量的文本？

不带变量的文本是一段纯文本，不需要使用文本解析器来解析。

**最后也是最重要的是HTML解析器，它是解析器中最核心的模块，它的作用就是解析模板，每当解析到HTML标签的开始位置、结束位置、文本或者注释时，都会触发钩子函数，然后将相关信息通过参数传递出来。**

**主线上做的事就是监听HTML解析器。每当触发钩子函数时**，就生成一个对应的AST节点。生成AST前，会根据类型使用不同的方式生成不同的AST。例如，如果是文本节点，就生成文本类型的AST。

这个AST其实和vnode有点类似，都是使用JavaScript中的对象来表示节点。

**当HTML解析器把所有模板都解析完毕后，AST也就生成好了**。关于如何解析，我们会在第9章中详细介绍。

### 8.2.2　优化器

优化器的目标是遍历AST，检测出所有静态子树（永远都不会发生变化的DOM节点）并给其打标记。

当AST中的静态子树被打上标记后，每次重新渲染时，就不需要为打上标记的静态节点创建新的虚拟节点，而是直接克隆已存在的虚拟节点。在虚拟DOM的更新操作中，如果发现两个节点是同一个节点，正常情况下会对这两个节点进行更新，但是如果这两个节点是静态节点，则可以直接跳过更新节点的流程。更多内容可以参见7.4.1节。

**总体来说，优化器的主要作用是避免一些无用功来提升性能。因为静态节点除了首次渲染，后续不需要任何重新渲染操作。**

### 8.2.3　代码生成器

代码生成器是模板编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容可以称为“代码字符串”。

例如，一个简单的模板：

![image-20210524221636627](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221636627.png)

生成后的代码字符串是：

![image-20210524221711423](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221711423.png)

格式化后是：

![image-20210524221722216](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221722216.png)

**这样一个代码字符串最终导出到外界使用时，会将代码字符串放到函数里，这个函数叫作渲染函数。**

当渲染函数被导出到外界后，模板编译的任务就完成了。

那么，如何将代码字符串放到函数里？

举个例子：

![image-20210524221904830](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524221904830.png)

前面介绍过，渲染函数的作用是创建vnode。渲染函数之所以可以生成vnode，是因为代码字符串中会有很多函数调用（例如，上面生成的代码字符串中有两个函数调用 _c和 _v），这些函数是虚拟DOM提供的创建vnode的方法。vnode有很多种类型，不同的类型对应不同的创建方法，所以代码字符串中的 _c和 _v其实都是创建vnode的方法，只是创建的vnode的类型不同。例如，c可以创建元素类型的vnode，而 _v可以创建文本类型的vnode。

## 8.3　总结

本章中，我们主要对模板编译做了一个整体介绍。首先介绍了模板编译在整个渲染流程中的位置，然后介绍了什么是模板编译，最后介绍了如何将模板编译成渲染函数。

而将模板**编译成渲染函数有三部分内容**：先将模板解析成AST，然后遍历AST标记静态节点，最后使用AST生成代码字符串。这三部分内容分别对应三个模块：解析器、优化器和代码生成器。

# 第 9 章　解析器（还没看）

# 第 10 章　优化器（还没看）

# 第 11 章　代码生成器（还没看）

# 第四篇　整体流程

在本篇中，我们更多的是介绍距离用户比较近的内容，例如使用Vue.js开发项目时常用的API、模板中的各种指令、组件里经常使用的生命周期钩子以及使用事件进行父子组件间的通信。此外，我们还会定义一些Vue.js插件和过滤器。

本篇中，我们主要讲解常用功能的内部原理，同时还会介绍Vue.js的架构设计和代码结构，也会讨论如何组建Vue.js这样的开源项目的代码等内容。

# 第 12 章　架构设计与项目结构

本章将介绍Vue.js的架构设计和项目结构，我们会从宏观的角度了解它内部的运行原理，同时了解其代码是如何组建起来的。

## 12.1　目录结构

Vue.js的目录结构如下：

![image-20210524222502125](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524222502125.png)

- packages目录中包含的vue-server-renderer和vue-template-compiler会作为单独的NPM包发布，自动从源码中生成，并且始终与Vue.js具有相同的版本。
- src/compiler目录下的代码逻辑与我们在第8章中介绍的内容一致。
- src/core目录下是Vue.js的核心代码，这部分逻辑是与平台无关的，也就是说，它们可以在任何JavaScript环境下运行，比如浏览器、Node.js或者嵌入在原生应用中。
- src/platforms目录中包含特定平台的代码，跨平台相关的代码也会放在这里。
- dist存放构建后的文件，在这个目录下你会找到很多不同的Vue.js构建版本，表12-1列出了它们之间的区别。

**表12-1　不同的Vue.js构建版本的区别**

![image-20210524222845979](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524222845979.png)

下面简单介绍一下表12-1。

• 完整版：构建后的文件同时包含编译器和运行时。

• 编译器：负责将模板字符串编译成JavaScript渲染函数，这部分内容在第三篇中介绍过。

• 运行时：负责创建Vue.js实例，渲染视图和使用虚拟DOM实现重新渲染，基本上包含除编译器外的所有部分。

• UMD：UMD版本的文件可以通过 <script> 标签直接在浏览器中使用。jsDelivrCDN提供的可以在线引入Vue.js的地址（https://cdn.jsdelivr.net/npm/vue），就是运行时+编译器的UMD版本。

• CommonJS：CommonJS版本用来配合较旧的打包工具，比如Browserify或webpack 1，这些打包工具的默认文件（pkg.main）只包含运行时的CommonJS版本（vue.runtime.common.js）。

• ES Module：ES Module版本用来配合现代打包工具，比如webpack 2或Rollup，这些打包工具的默认文件（pkg.module）只包含运行时的ES Module版本（vue.runtime.esm.js）。

### **运行时 + 编译器与只包含运行时**

如果需要在客户端编译模板（比如传入一个字符串给template选项，或挂载到一个元素上并以其DOM内部的HTML作为模板），那么需要用到编译器，因此需要完整版：

![image-20210524223005829](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223005829.png)

**当使用vue-loader或vueify的时候，*.vue文件内部的模板会在构建时预编译成JavaScript。所以，最终打包完成的文件实际上是不需要编译器的，只需要引入运行时版本即可。**

由于运行时版本的体积比完整版要小30%左右，所以应该尽可能使用运行时版本。如果仍然希望使用完整版，则需要在打包工具里配置一个别名。

对于webpack，需要这么处理：

![image-20210524223124184](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223124184.png)

对于Rollup，需要这么处理：

![image-20210524223134117](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223134117.png)

对于Browserify，需要添加到项目的package.json中：

![image-20210524223143036](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223143036.png)

### 开发环境与生产环境模式

对于UMD版本来说，开发环境和生产环境二者的模式是硬编码的：开发环境下使用未压缩的代码，生产环境下使用压缩后的代码。

CommonJS和ES Module版本用于打包工具，因此Vue.js不提供压缩后的版本，需要自行将最终的包进行压缩。此外，这两个版本同时保留原始的process.env.NODE_ENV检测，来决定它们应该在什么模式下运行。我们应该使用适当的打包工具配置来替换这些环境变量，以便控制Vue.js所运行的模式。把process.env.NODE_ENV替换为字符串字面量，同时让UglifyJS之类的压缩工具完全删除仅供开发环境的代码块，从而减少最终文件的大小。

在webpack中，我们使用DefinePlugin：

![image-20210524223341236](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223341236.png)

在Rollup中，我们使用rollup-plugin-replace：

![image-20210524223354470](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223354470.png)

在Browserify中，应用一次全局的envify转换：

![image-20210524223403477](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223403477.png)

## 12.2　架构设计

上一节中我们介绍了Vue.js的目录结构，本节中我们将介绍它的架构设计，了解如何组织像Vue.js这样的开源项目代码。

**图12-1给出了Vue.js的整体结构，我们可以看到它整体分为三个部分：核心代码、跨平台相关和公用工具函数（这部分是一些辅助函数，不再单独介绍）。同时，其架构是分层的，最底层是一个普通的构造函数，最上层是一个入口，也就是将一个完整的构造函数导出给用户使用。**

![image-20210524223547246](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524223547246.png)

图12-1　程序结构

在最底层和最顶层中间，我们需要逐渐添加一些方法和属性，而构造函数上一层的一些方法会最终添加到构造函数的prototype属性中，再上一层的方法最终会添加到构造函数上，这些方法叫作**全局API（Global API）**，**例如Vue.use。也就是说，先在构造函数的prototype属性中添加方法后，再向构造函数自身添加全局API**。再往上一层是与跨平台相关的内容。在构建时，首先会选择一个平台，然后将特定于这个平台的代码加载到构建文件中。**再上一层是渲染层，其中包含两部分内容：服务端渲染相关的内容和编译器相关的内容。同时，这一层的内容是可选的，构建时会根据构建的目标文件来选择是否需要将编译器加载进来。**事实上，这一层并不权威，因为服务端渲染相关的代码只存在于Web平台下，而且这两个平台有各自的编译器配置。这里之所以把它们放到渲染层，是因为它们都是与渲染相关的内容。

**上一节中我们介绍了dist目录下很多不同的Vue.js构建版本，这些版本中有的只包含运行时，有的是完整版的。如果构建只包含运行时代码的版本，就不会将渲染层中编译器部分的代码加载进来。**

最顶层是入口，也可以叫作出口。对于构建工具和Vue.js的使用者来说，这是入口；对于Vue.js自身来说，这是出口。在构建文件时，不同平台的构建文件会选择不同的入口进行构建操作。

