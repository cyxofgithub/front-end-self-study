# 深入浅出 Vue.js

# 第 1 章　Vue.js简介

当应用程序开始变复杂后，我们需要频繁操作DOM。由于缺乏正规的组织形式，我们的代码变得非常难以维护。这本质上是命令式操作DOM的问题，我们曾经用jQuery操作DOM写需求，但是当应用程序变复杂后，代码就像一坨意大利面一样，有点难以维护。我们无法继续使用命令式操作DOM，**所以Vue.js提供了声明式操作DOM的能力来解决这个问题。**

通过描述状态和DOM之间的映射关系，就可以将状态渲染成DOM呈现在用户界面中，也就是渲染到网页上。

## 1.1　什么是Vue.js

Vue.js，通常简称为Vue，是一款友好的、多用途且高性能的JavaScript框架，能够帮助我们创建可维护性和可测试性更强的代码。它是目前所有主流框架中学习曲线最平缓的框架，非常容易上手，其官方文档也写得非常清晰、易懂。

它是一款渐进式的JavaScript框架。关于什么是渐进式，其实一开始我琢磨了好久，后来才弄懂，就是说如果你已经有一个现成的服务端应用，也就是非单页应用，可以将Vue.js作为该应用的一部分嵌入其中，带来更加丰富的交互体验。

## 1.2　Vue.js简史

# 第一篇　变化侦测 （很多地方不懂）

## 1.0 概述

Vue.js最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JavaScript对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见的问题。——官方文档

**从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染**，应用在运行时会不断地进行重新渲染。而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

简单来说，**变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新**。

本篇中，我们将针对变化侦测的实现原理做一个详细介绍，并且会带着你一步一步从0到1实现一个变化侦测的逻辑。学完本篇，你将可以自己实现一个变化侦测的功能。

# 第 2 章　Object的变化侦测

**大部分人不会想到Object和Array的变化侦测采用不同的处理方式。事实上，它们的侦测方式确实不一样。**

## 2.1　什么是变化侦测

Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。

**如何确定状态中发生了什么变化？**

变化侦测就是用来解决这个问题的，**它分为两种类型**：一种是“推”（push），另一种是“拉”（pull）。



**Angular和React中的变化侦测都属于“拉”，**这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。



**而Vue.js的变化侦测属于“推”。**当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。



**所谓更细粒度的更新，就是说**：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。

但是它也有一定的代价，**因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。**



Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

## 2.2　如何追踪变化

**在JavaScript（简称JS）中，如何侦测一个对象的变化？**

有两种方法可以侦测到变化：使用Object.defineProperty和ES6的Proxy。



由于ES6在浏览器中的支持度并不理想，到目前为止Vue.js还是使用Object.defineProperty来实现的，所以书中也会使用它来介绍变化侦测的原理。

由于使用Object.defineProperty来侦测变化会有很多缺陷，所以Vue.js的作者尤雨溪说日后会使用Proxy重写这部分代码。好在本章讲的是原理和思想，所以即便以后用Proxy重写了这部分代码，书中介绍的原理也不会变。



知道了Object.defineProperty可以侦测到对象的变化，那么我们可以写出这样的代码：

![image-20210514084010557](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084010557.png)

这里的函数defineReactive用来对Object.defineProperty进行封装。从函数的名字可以看出，其作用是定义一个响应式数据。也就是在这个函数中进行变化追踪，封装后只需要传递data、key和val就行了。

封装好之后，每当从data的key中读取数据时，get函数被触发；每当往data的key中设置数据时，set函数被触发。

## 2.3　如何收集依赖

**举个例子：**

![image-20210514084323831](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084323831.png)

该模板中使用了数据name，所以当它发生变化时，要向使用了它的地方发送通知。

注意　在Vue.js 2.0中，**模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。**

对于上面的问题，我的回答是，**先收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了**。

**总结起来，其实就一句话，在getter中收集依赖，在setter中触发依赖。**

## 2.4　依赖收集在哪里

思考一下，首先想到的是每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上，现在就可以把defineReactive函数稍微改造一下：

![image-20210514084718191](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084718191.png)

这样写有点耦合，我们把依赖收集的代码封装成一个Dep类，它专门帮助我们管理依赖。使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。其代码如下：

![image-20210514085341061](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085341061.png)

之后再改造一下defineReactive：

![image-20210514085358005](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085358005.png)

依赖收集到哪儿？收集到Dep中。

## 2.5　依赖是谁

**我们收集的依赖是window.target，那么它到底是什么？我们究竟要收集谁呢？**

收集谁，换句话说，就是当属性发生变化后，通知谁。

我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个。接着，它再负责通知其他地方。所以，我们要抽象的这个东西需要先起一个好听的名字。嗯，就叫它**Watcher**吧。

现在就可以回答上面的问题了，收集谁？Watcher！

## 2.6　什么是Watcher（有不理解的地方）

Watcher是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。

关于Watcher，先看一个经典的使用方式：

![image-20210514085643276](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085643276.png)

这段代码表示当data.a.b.c属性发生变化时，触发第二个参数中的函数。

**怎么实现这个功能呢？**（看不懂代码）

好像只要把这个watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。

写出如下代码：

![image-20210514085824453](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085824453.png)

tips：![image-20210514093447755](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514093447755.png)

**调用this.getter（）就是调用this.get（）**

这段代码可以把自己主动添加到data.a.b.c的Dep中去，是不是很神奇？

因为我在get方法中先把window.target设置成了this，也就是当前watcher实例，然后再读一下data.a.b.c的值，这肯定会触发getter。

触发了getter，就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从window.target中读取一个依赖并添加到Dep中。

这就导致，只要先在window.target赋一个this，然后再读一下值，去触发getter，就可以把this主动添加到keypath的Dep中。有没有很神奇的感觉啊？

依赖注入到Dep中后，每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldValue传到参数中。

所以，其实不管是用户执行的vm.$watch('a.b.c', (value, oldValue) => {})，还是模板中用到的data，都是通过Watcher来通知自己是否需要发生变化。

这里有些小伙伴可能会好奇上面代码中的parsePath是怎么读取一个字符串的keypath的，下面用一段代码来介绍其实现原理：

![image-20210514091537401](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514091537401.png)

可以看到，这其实并不复杂。先将keypath用 . 分割成数组，然后循环数组一层一层去读数据，最后拿到的obj就是keypath中想要读的数据。

## 2.7　递归侦测所有key（不理解我跑去看视频了）

现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个Observer类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化：

![image-20210514094552614](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514094552614.png)

在上面的代码中，我们定义了Observer类，它用来将一个正常的object转换成被侦测的object。

然后判断数据的类型，只有Object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。

最后，在defineReactive中新增new Observer(val)来递归子属性，这样我们就可以把data中的所有属性（包括子属性）都转换成getter/setter的形式来侦测变化。

当data中的属性发生变化时，与这个属性对应的依赖就会接收到通知。

也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。

# 第 3章　Array的变化侦测

## 3.11　侦测新增元素的变化

数组中有一些方法是可以新增数组内容的，比如push，而新增的内容也需要转换成响应式来侦测变化，否则会出现修改数据时无法触发消息等问题。因此，我们必须侦测数组中新增元素的变化。

**其实现方式其实并不难，只要能获取新增的元素并使用Observer来侦测它们就行。**

### 3.11.1　获取新增元素

![image-20210524145557025](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524145557025.png)

在上面的代码中，我们通过switch对method进行判断，如果method是push、unshift、splice这种可以新增数组元素的方法，那么从args中将新增元素取出来，暂存在inserted中。

接下来，我们要使用Observer把inserted中的元素转换成响应式的。

### 3.11.2　使用Observer侦测新增元素

前面介绍过Observer会将自身的实例附加到value的 __ob__ 属性上。所有被侦测了变化的数据都有一个 __ob__ 属性，数组元素也不例外。

因此，我们可以在拦截器中通过this访问到 __ob__，然后调用 __ob__ 上的observeArray方法就可以了：

![image-20210524145902381](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524145902381.png)

在上面的代码中，我们从this.__ob__ 上拿到Observer实例后，如果有新增元素，则使用ob.observeArray来侦测这些新增元素的变化。

## 3.12　关于Array的问题

前面介绍过，对Array的变化侦测是通过拦截原型的方式实现的。正是因为这种实现方式，其实有些数组操作Vue.js是拦截不到的，例如：

![image-20210524150031372](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150031372.png)

即修改数组中第一个元素的值时，无法侦测到数组的变化，所以并不会触发re-render或watch等。

例如：

![image-20210524150058227](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150058227.png)

这个清空数组操作也无法侦测到数组的变化，所以也不会触发re-render或watch等。

因为Vue.js的实现方式决定了无法对上面举的两个例子做拦截，也就没有办法响应。在ES6之前，无法做到模拟数组的原生行为，所以拦截不到也是没有办法的事情。ES6提供了元编程的能力，所以有能力拦截，我猜测未来Vue.js很有可能会使用ES6提供的Proxy来实现这部分功能，从而解决这个问题。

## 3.13　总结

**Array追踪变化的方式和Object不一样。因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式来追踪变化。**

为了不污染全局Array.prototype，我们在Observer中只针对那些需要侦测变化的数组使用 __proto__ 来覆盖原型方法，但 __proto__ 在ES6之前并不是标准属性，不是所有浏览器都支持它。因此，针对不支持 __proto__ 属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截Array.prototype上的原生方法。

**Array收集依赖的方式和Object一样，都是在getter中收集。**但是由于使用依赖的位置不同，数组要在拦截器中向依赖发消息，所以**依赖不能像Object那样保存在defineReactive中，而是把依赖保存在了Observer实例上。**

**在Observer中，我们对每个侦测了变化的数据都标上印记 ob，并把this（Observer实例）保存在 ob 上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据取到 ob，从而拿到Observer实例上保存的依赖。当拦截到数组发生变化时，向依赖发送通知。**

**除了侦测数组自身的变化外，数组中元素发生的变化也要侦测。**我们在Observer中判断如果当前被侦测的数据是数组，则调用observeArray方法将数组中的每一个元素都转换成响应式的并侦测变化。

由于在ES6之前，JavaScript并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化，**只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用length清空数组的操作就无法拦截。**

# 第 4 章　变化侦测相关的API实现原理

## 4.1　vm.$watch

### 4.1.1　用法

![image-20210524150644584](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524150644584.png)

● 参数：

● {string | Function} expOrFn

● {Function | Object} callback、

● {Object} [options]

​	{boolean} deep

​	● {boolean} immediate

● 返回值：{Function} unwatch

**用法**：用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以用函数代替表达式。

例如：

![image-20210524151000418](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151000418.png)

vm.$watch返回一个取消观察函数，用来停止触发回调：

![image-20210524151027211](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151027211.png)

最后，简要介绍一下 [options] 的两个选项deep和immediate。

deep。为了发现对象内部值的变化，可以在选项参数中指定deep: true：

![image-20210524151101011](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151101011.png)

这里需要注意的是，监听数组的变动不需要这么做。

immediate。在选项参数中指定immediate: true，将立即以表达式的当前值触发回调：

![image-20210524151126137](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151126137.png)

### 4.1.2　watch的内部原理

vm.$watch其实是对Watcher的一种封装，Watcher的原理在第2章中介绍过。通过Watcher完全可以实现vm.$watch的功能，但vm.$watch中的参数deep和immediate是Watcher中所没有的。下面我们来看一看vm.$watch到底是怎么实现的：

![image-20210524151217123](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151217123.png)

可以看到，代码不多，逻辑也不算复杂。先执行new Watcher来实现vm.$watch的基本功能。

这里有一个细节需要注意，expOrFn是支持函数的，而我们在第2章中并没有介绍。这里我们需要对Watcher进行一个简单的修改，具体如下：

![image-20210524151513890](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524151513890.png)

上面的代码新增了判断expOrFn类型的逻辑。如果expOrFn是函数，则直接将它赋值给getter；如果不是函数，再使用parsePath函数来读取keypath中的数据。这里keypath指的是属性路径，例如a.b.c.d就是一个keypath，说明从vm.a.b.c.d中读取数据。

当expOrFn是函数时，会发生很神奇的事情。它不只可以动态返回数据，其中读取的所有数据也都会被Watcher观察。**当expOrFn是字符串类型的keypath时，Watcher会读取这个keypath所指向的数据并观察这个数据的变化。而当expOrFn是函数时，Watcher会同时观察expOrFn函数中读取的所有Vue.js实例上的响应式数据。也就是说，如果函数从Vue.js实例上读取了两个数据，那么Watcher会同时观察这两个数据的变化，当其中任意一个发生变化时，Watcher都会得到通知。**

说明　事实上，Vue.js中计算属性（Computed）的实现原理与expOrFn支持函数有很大的关系，我们会在后面的章节中详细介绍。

执行new Watcher后，代码会判断用户是否使用了immediate参数，如果使用了，则立即执行一次cb。

最后，返回一个函数unwatchFn。顾名思义，它的作用是取消观察数据。

当用户执行这个函数时，实际上是执行了watcher.teardown()来取消观察数据，其本质是把watcher实例从当前正在观察的状态的依赖列表中移除。



前面介绍Watcher时并没有介绍teardown方法，现在要在Watcher中添加该方法来实现unwatch的功能。

首先，需要在Watcher中记录自己都订阅了谁，也就是watcher实例被收集进了哪些Dep里。然后当Watcher不想继续订阅这些Dep时，循环自己记录的订阅列表来通知它们（Dep）将自己从它们（Dep）的依赖列表中移除掉。

先在Watcher中添加addDep方法，该方法的作用是在Watcher中记录自己都订阅过哪些Dep：

![image-20210524152310424](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152310424.png)

在上述代码中，我们使用depIds来判断如果当前Watcher已经订阅了该Dep，则不会重复订阅。在第2章中，我们介绍过Watcher读取value时，会触发收集依赖的逻辑。当依赖发生变化时，会通知Watcher重新读取最新的数据。如果没有这个判断，就会发现每当数据发生了变化，Watcher都会读取最新的数据。而读数据就会再次收集依赖，这就会导致Dep中的依赖有重复。这样当数据发生变化时，会同时通知多个Watcher。为了避免这个问题，只有第一次触发getter的时候才会收集依赖。

接着，执行this.depIds.add来记录当前Watcher已经订阅了这个Dep。

然后执行this.deps.push(dep)记录自己都订阅了哪些Dep。

最后，触发dep.addSub(this)来将自己订阅到Dep中。

在Watcher中新增addDep方法后，Dep中收集依赖的逻辑也需要有所改变：

![image-20210524152724558](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152724558.png)

此时，Dep会记录数据发生变化时，需要通知哪些Watcher，而Watcher中也同样记录了自己会被哪些Dep通知。它们其实是多对多的关系，如图4-1所示。

![image-20210524152831256](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152831256.png)

图4-1　Watcher与Dep的关系

有些人可能会感到困惑，为什么是多对多的关系。Watcher每次只读一个数据，不是应该只有一个Dep吗？

其实不是。如果Watcher中的expOrFn参数是一个表达式，那么肯定只收集一个Dep，并且大部分都是这样。但凡事总有例外，expOrFn可以是一个函数，此时如果该函数中使用了多个数据，那么这时Watcher就要收集多个Dep了，例如：

![image-20210524152942616](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524152942616.png)

这种情况下Watcher内部会收集两个Dep——name的Dep和age的Dep，同时这两个Dep中也会收集Watcher，这导致age和name中的任意一个数据发生变化时，Watcher都会收到通知。

**言归正传，当我们已经在Watcher中记录自己都订阅了哪些Dep之后，就可以在Watcher中新增teardown方法来通知这些订阅的Dep，让它们把自己从依赖列表中移除掉：**

![image-20210524153054366](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153054366.png)

上面做的事情很简单，只是循环订阅列表，然后分别执行它们的removeSub方法，来把自己从它们的依赖列表中移除掉。接下来，看看removeSub中都发生了什么：

![image-20210524153219233](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153219233.png)

上面的代码把Watcher从sub中删除掉，然后当数据发生变化时，将不再通知这个已经删除的Watcher，这就是unwatch的原理。

## 还没看完

# 第二篇　虚拟DOM

# 第 5 章　虚拟DOM简介

## 5.1　什么是虚拟DOM

本质上，我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫作渲染，如图5-1所示

![image-20210524153626752](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153626752.png)

每当状态发生变化时，都需要重新渲染。如何确定状态中发生了什么变化以及需要在哪里更新DOM？

在这种情况下，最简单粗暴的解决方式是，既不需要关心状态发生了什么变化，也不需要关心在哪里更新DOM，我们只需要把所有DOM全删了，然后使用状态重新生成一份DOM，并将其输出到页面上显示出来就好了。

但是访问DOM是非常昂贵的。按照上面说的方式做，会造成相当多的性能浪费。状态变化通常只有有限的几个节点需要重新渲染，所以我们不仅需要找出哪里需要更新，还需要尽可能少地访问DOM。

![image-20210524153743681](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524153743681.png)

这个问题有很多种解决方案。目前，各大主流框架都有自己的一套解决方案，在Angular中就是脏检查的流程，React中使用虚拟DOM，Vue.js 1.0通过细粒度的绑定。**因此，虚拟DOM本质上只是众多解决方案中的一种，可以用但并不一定必须用。**

**虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。**

虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。

![image-20210524154141583](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154141583.png)

## 5.2　为什么要引入虚拟DOM

事实上，Angular和React的变化侦测有一个共同点，那就是它们都不知道哪些状态（state）变了。因此，就需要进行比较暴力的比对，React是通过虚拟DOM的比对，Angular是使用脏检查的流程。

Vue.js的变化侦测和它们都不一样，它在一定程度上知道具体哪些状态发生了变化，这样就可以通过更细粒度的绑定来更新视图。也就是说，在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对。事实上，在Vue.js 1.0的时候就是这样实现的。

但是这样做其实也有一定的代价。因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及一些依赖追踪的开销。当状态被越多的节点使用时，开销就越大。对于一个大型项目来说，这个开销是非常大的。

**因此，Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入了虚拟DOM。**组件级别是一个watcher实例，就是说即便一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对与渲染。这是一个比较折中的方案。

Vue.js之所以能随意调整绑定的粒度，本质上还要归功于变化侦测。关于Vue.js的变化侦测原理，我们在第3章中已经详细介绍过。

## 5.3　Vue.js中的虚拟DOM

在Vue.js中，我们使用模板来描述状态与DOM之间的映射关系。Vue.js通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面，具体如图5-4所示。

![image-20210524154538259](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154538259.png)

**虚拟DOM的终极目标是将虚拟节点（vnode）渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。**

**例如**，一个ul标签下有很多li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替换旧的ul，其实除了那个发生了变化的li节点之外，其他节点都不需要重新渲染。

由于DOM操作比较慢，所以这些DOM操作在性能上会有一定的浪费，避免这些不必要的DOM操作会提升很大一部分性能。

**为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。**

图5-5给出了虚拟DOM的整体运行流程，先将vnode与oldVnode做比对，然后再更新视图。

![image-20210524154708894](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524154708894.png)

**图5-5　虚拟DOM的执行流程**

可以看出，**虚拟DOM在Vue.js中所做的事情其实并没有想象中那么复杂，它主要做了两件事。**

​	● 提供与真实DOM节点所对应的虚拟节点vnode。

​	● 将虚拟节点vnode和旧虚拟节点oldVnode进行比对，然后更新视图。

对两个虚拟节点进行比对是虚拟DOM中最核心的算法（即patch），它可以判断出哪些节点发生了变化，从而只对发生了变化的节点进行更新操作。关于patch，我们会在第7章中详细介绍。

## 5.4　总结

虚拟DOM是将状态映射成视图的众多解决方案中的一种，它的运作原理是使用状态生成虚拟节点，然后使用虚拟节点渲染视图。

之所以需要先使用状态生成虚拟节点，是因为如果直接用状态生成真实DOM，会有一定程度的性能浪费。而先创建虚拟节点再渲染视图，就可以将虚拟节点缓存，然后使用新创建的虚拟节点和上一次渲染时缓存的虚拟节点进行对比，然后根据对比结果只更新需要更新的真实DOM节点，从而避免不必要的DOM操作，节省一定的性能开销。

由于Vue.js的变化侦测粒度更细，所以当状态发生变化时，Vue.js知道的信息更多，一定程度上可以知道哪些位置使用了状态。因此，Vue.js可以通过细粒度的绑定来更新视图，Vue.js 1.0就是这样实现的。

但是这样做也有一定的代价。因为粒度太细，就会有很多watcher同时观察某些状态，会有一些内存开销以及一些依赖追踪的开销，所以Vue.js 2.0采取了一个中等粒度的解决方案，状态侦测不再细化到某个具体节点，而是某个组件，组件内部通过虚拟DOM来渲染视图，这可以大大缩减依赖数量和watcher数量。

Vue.js中通过模板来描述状态与视图之间的映射关系，所以它会先将模板编译成渲染函数，然后执行渲染函数生成虚拟节点，最后使用虚拟节点更新视图。

**因此，虚拟DOM在Vue.js中所做的事是提供虚拟节点vnode和对新旧两个vnode进行比对，并根据比对结果进行DOM操作来更新视图。**

# 第 6 章　VNode

在虚拟DOM中，VNode是比较重要的知识点。本章中，我们将详细介绍什么是VNode，VNode的作用，以及不同类型的VNode之间有什么区别。

## 6.1　什么是VNode

在Vue.js中存在一个VNode类，使用它可以实例化不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。

例如，DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。

VNode类的代码如下：

![image-20210524155639538](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524155639538.png)

从上面的代码可以看出，vnode只是一个名字，本质上其实是JavaScript中一个普通的对象，是从VNode类实例化的对象。我们用这个JavaScript对象来描述一个真实DOM元素的话，那么该DOM元素上的所有属性在VNode这个对象上都存在对应的属性。

**简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。**

例如，tag表示一个元素节点的名称，text表示一个文本节点的文本，children表示子节点等。

vnode表示一个真实的DOM元素，所有真实的DOM节点都使用vnode创建并插入到页面中，如图6-1所示。

![image-20210524155900675](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524155900675.png)

**图6-1　VNode创建DOM并插入到视图**

图6-1展示了使用vnode创建真实DOM并渲染到视图的过程。可以得知，vnode和视图是一一对应的。我们可以把vnode理解成JavaScript对象版本的DOM元素。

从图6-1还可以得知，渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后插入到页面渲染视图。

## 6.2　VNode的作用

由于每次渲染视图时都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的vnode缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之间有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM。

**Vue.js目前对状态的侦测策略采用了中等粒度。当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图。**

如图6-2所示，当某个状态发生改变时，只通知使用了这个状态的组件（图6-2通知了第二个组件）。

![image-20210524160209390](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160209390.png)

也就是说，只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染。

**如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。这也是vnode最重要的一个作用。**

## 6.3　VNode的类型

vnode的类型有以下几种：

● 注释节点

● 文本节点

● 元素节点

● 组件节点

● 函数式组件

● 克隆节点

前面我们介绍了什么是vnode，知道vnode是JavaScript中的一个对象，不同类型的vnode之间其实只是属性不同，准确地说是有效属性不同。因为当使用VNode类创建一个vnode时，通过参数为实例设置属性时，无效的属性会默认被赋值为undefined或false。对于vnode身上的无效属性，直接忽略就好。接下来，我们详细讨论这些类型的vnode都有哪些有效属性。

### 6.3.1　注释节点

由于创建注释节点的过程非常简单，所以直接通过代码来介绍它有哪些属性：

![image-20210524160634820](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160634820.png)

可以看出，一个注释节点只有两个有效属性——text和isComment，其余属性全是默认的undefined或者false。

例如，一个真实的注释节点：

![image-20210524160654036](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160654036.png)

所对应的vnode是下面的样子：

![image-20210524160709652](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160709652.png)

### 6.3.2　文本节点

文本节点的创建过程也非常简单，我们也可以直接通过代码来了解它有哪些有效属性：

![image-20210524160819587](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160819587.png)

通过上面的代码可以了解到，当文本类型的vnode被创建时，它只有一个text属性：

![image-20210524160830395](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524160830395.png)

上面代码所展示的对象就是文本类型的vnode。

### 6.3.3　克隆节点

克隆节点是将现有节点的属性复制到新节点中，让新创建的节点和被克隆节点的属性保持一致，从而实现克隆效果。**它的作用是优化静态节点和插槽节点（slotnode）。**

以静态节点为例，当组件内的某个状态发生变化后，当前组件会通过虚拟DOM重新渲染视图，静态节点因为它的内容不会改变，所以除了首次渲染需要执行渲染函数获取vnode之外，后续更新不需要执行渲染函数重新生成vnode。因此，这时就会使用创建克隆节点的方法将vnode克隆一份，使用克隆节点进行渲染。这样就不需要重新执行渲染函数生成新的静态节点的vnode，从而提升一定程度的性能。

由于创建克隆节点的过程不复杂，所以还是直接通过代码来了解：

![image-20210524161409858](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161409858.png)

可以看出，克隆现有节点时，只需要将现有节点的属性全部复制到新节点中即可。克隆节点和被克隆节点之间的唯一区别是isCloned属性，克隆节点的isCloned为true，被克隆的原始节点的isCloned为false。

### 6.3.4　元素节点

元素节点通常会存在以下4种有效属性。

● tag：顾名思义，tag就是一个节点的名称，例如p、ul、li和div等。

● data：该属性包含了一些节点上的数据，比如attrs、class和style等。

● children：当前节点的子节点列表。

● context：它是当前组件的Vue.js实例。

例如，一个真实的元素节点：

![image-20210524161717987](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161717987.png)

所对应的vnode是下面的样子：

![image-20210524161748330](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524161748330.png)

### 6.3.5　组件节点

组件节点和元素节点类似，有以下两个独有的属性。

● componentOptions：顾名思义，就是组件节点的选项参数，其中包含propsData、tag和children等信息。

● componentInstance：组件的实例，也是Vue.js的实例。事实上，在Vue.js中，每个组件都是一个Vue.js实例。

一个组件节点：

![image-20210524162029904](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162029904.png)

所对应的vnode是下面的样子：

![image-20210524162051130](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162051130.png)

### 6.3.6　函数式组件

函数式组件和组件节点类似，它有两个独有的属性functionalContext和functionalOptions。

通常，一个函数式组件的vnode是下面的样子：

![image-20210524162839529](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210524162839529.png)

## 6.4　总结

VNode是一个类，可以生成不同类型的vnode实例，而不同类型的vnode表示不同类型的真实DOM元素。

由于Vue.js对组件采用了虚拟DOM来更新视图，当属性发生变化时，整个组件都要进行重新渲染的操作，但组件内并不是所有DOM节点都需要更新，所以将vnode缓存并将当前新生成的vnode和上一次缓存的oldVnode进行对比，只对需要更新的部分进行DOM操作可以提升很多性能。

vnode有多种类型，它们本质上都是从VNode类实例化出的对象，其唯一区别只是属性不同。

