# 深入浅出 Vue.js

# 第 1 章　Vue.js简介

当应用程序开始变复杂后，我们需要频繁操作DOM。由于缺乏正规的组织形式，我们的代码变得非常难以维护。这本质上是命令式操作DOM的问题，我们曾经用jQuery操作DOM写需求，但是当应用程序变复杂后，代码就像一坨意大利面一样，有点难以维护。我们无法继续使用命令式操作DOM，**所以Vue.js提供了声明式操作DOM的能力来解决这个问题。**

通过描述状态和DOM之间的映射关系，就可以将状态渲染成DOM呈现在用户界面中，也就是渲染到网页上。

## 1.1　什么是Vue.js

Vue.js，通常简称为Vue，是一款友好的、多用途且高性能的JavaScript框架，能够帮助我们创建可维护性和可测试性更强的代码。它是目前所有主流框架中学习曲线最平缓的框架，非常容易上手，其官方文档也写得非常清晰、易懂。

它是一款渐进式的JavaScript框架。关于什么是渐进式，其实一开始我琢磨了好久，后来才弄懂，就是说如果你已经有一个现成的服务端应用，也就是非单页应用，可以将Vue.js作为该应用的一部分嵌入其中，带来更加丰富的交互体验。

## 1.2　Vue.js简史

# 第一篇　变化侦测

## 1.0 概述

Vue.js最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JavaScript对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见的问题。——官方文档

**从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染**，应用在运行时会不断地进行重新渲染。而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

简单来说，**变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新**。

本篇中，我们将针对变化侦测的实现原理做一个详细介绍，并且会带着你一步一步从0到1实现一个变化侦测的逻辑。学完本篇，你将可以自己实现一个变化侦测的功能。

# 第 2 章　Object的变化侦测

**大部分人不会想到Object和Array的变化侦测采用不同的处理方式。事实上，它们的侦测方式确实不一样。**

## 2.1　什么是变化侦测

Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。

**如何确定状态中发生了什么变化？**

变化侦测就是用来解决这个问题的，**它分为两种类型**：一种是“推”（push），另一种是“拉”（pull）。



**Angular和React中的变化侦测都属于“拉”，**这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。



**而Vue.js的变化侦测属于“推”。**当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。



**所谓更细粒度的更新，就是说**：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。

但是它也有一定的代价，**因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。**



Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。

## 2.2　如何追踪变化

**在JavaScript（简称JS）中，如何侦测一个对象的变化？**

有两种方法可以侦测到变化：使用Object.defineProperty和ES6的Proxy。



由于ES6在浏览器中的支持度并不理想，到目前为止Vue.js还是使用Object.defineProperty来实现的，所以书中也会使用它来介绍变化侦测的原理。

由于使用Object.defineProperty来侦测变化会有很多缺陷，所以Vue.js的作者尤雨溪说日后会使用Proxy重写这部分代码。好在本章讲的是原理和思想，所以即便以后用Proxy重写了这部分代码，书中介绍的原理也不会变。



知道了Object.defineProperty可以侦测到对象的变化，那么我们可以写出这样的代码：

![image-20210514084010557](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084010557.png)

这里的函数defineReactive用来对Object.defineProperty进行封装。从函数的名字可以看出，其作用是定义一个响应式数据。也就是在这个函数中进行变化追踪，封装后只需要传递data、key和val就行了。

封装好之后，每当从data的key中读取数据时，get函数被触发；每当往data的key中设置数据时，set函数被触发。

## 2.3　如何收集依赖

**举个例子：**

![image-20210514084323831](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084323831.png)

该模板中使用了数据name，所以当它发生变化时，要向使用了它的地方发送通知。

注意　在Vue.js 2.0中，**模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。**

对于上面的问题，我的回答是，**先收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了**。

**总结起来，其实就一句话，在getter中收集依赖，在setter中触发依赖。**

## 2.4　依赖收集在哪里

思考一下，首先想到的是每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上，现在就可以把defineReactive函数稍微改造一下：

![image-20210514084718191](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514084718191.png)

这样写有点耦合，我们把依赖收集的代码封装成一个Dep类，它专门帮助我们管理依赖。使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。其代码如下：

![image-20210514085341061](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085341061.png)

之后再改造一下defineReactive：

![image-20210514085358005](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085358005.png)

依赖收集到哪儿？收集到Dep中。

## 2.5　依赖是谁

**我们收集的依赖是window.target，那么它到底是什么？我们究竟要收集谁呢？**

收集谁，换句话说，就是当属性发生变化后，通知谁。

我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个。接着，它再负责通知其他地方。所以，我们要抽象的这个东西需要先起一个好听的名字。嗯，就叫它**Watcher**吧。

现在就可以回答上面的问题了，收集谁？Watcher！

## 2.6　什么是Watcher（有不理解的地方）

Watcher是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。

关于Watcher，先看一个经典的使用方式：

![image-20210514085643276](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085643276.png)

这段代码表示当data.a.b.c属性发生变化时，触发第二个参数中的函数。

**怎么实现这个功能呢？**（看不懂代码）

好像只要把这个watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。

写出如下代码：

![image-20210514085824453](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514085824453.png)

tips：![image-20210514093447755](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514093447755.png)

**调用this.getter（）就是调用this.get（）**

这段代码可以把自己主动添加到data.a.b.c的Dep中去，是不是很神奇？

因为我在get方法中先把window.target设置成了this，也就是当前watcher实例，然后再读一下data.a.b.c的值，这肯定会触发getter。

触发了getter，就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从window.target中读取一个依赖并添加到Dep中。

这就导致，只要先在window.target赋一个this，然后再读一下值，去触发getter，就可以把this主动添加到keypath的Dep中。有没有很神奇的感觉啊？

依赖注入到Dep中后，每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldValue传到参数中。

所以，其实不管是用户执行的vm.$watch('a.b.c', (value, oldValue) => {})，还是模板中用到的data，都是通过Watcher来通知自己是否需要发生变化。

这里有些小伙伴可能会好奇上面代码中的parsePath是怎么读取一个字符串的keypath的，下面用一段代码来介绍其实现原理：

![image-20210514091537401](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514091537401.png)

可以看到，这其实并不复杂。先将keypath用 . 分割成数组，然后循环数组一层一层去读数据，最后拿到的obj就是keypath中想要读的数据。

## 2.7　递归侦测所有key（不理解我跑去看视频了）

现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个Observer类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化：

![image-20210514094552614](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210514094552614.png)

在上面的代码中，我们定义了Observer类，它用来将一个正常的object转换成被侦测的object。

然后判断数据的类型，只有Object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。

最后，在defineReactive中新增new Observer(val)来递归子属性，这样我们就可以把data中的所有属性（包括子属性）都转换成getter/setter的形式来侦测变化。

当data中的属性发生变化时，与这个属性对应的依赖就会接收到通知。

也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。