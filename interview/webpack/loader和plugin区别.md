## 核心区别

| 对比项       | Loader（加载器）                               | Plugin（插件）                                               |
| :----------- | :--------------------------------------------- | :----------------------------------------------------------- |
| **主要职责** | 转换模块的源代码内容，实现代码编译、预处理等   | 扩展和增强 Webpack 构建流程，实现更多功能                    |
| **工作时机** | 模块被加载和解析时（loader 链式处理）          | 编译过程任意生命周期阶段（通过钩子机制）                     |
| **输入输出** | 输入：源代码字符串<br>输出：转换后的代码字符串 | 输入输出灵活，可访问和修改 compiler、compilation、构建结果等 |
| **作用范围** | 只针对单个文件进行处理                         | 影响整个项目的构建流程，作用全局                             |

## 有了 plugin 为什么还要 loader

Loader 能做而 Plugin 难做的事

1. 文件内容的链式处理
   Loader 天然支持链式调用，比如：

    ```js
    {
      test: /\.scss$/,
      use: ['style-loader', 'css-loader', 'sass-loader']
      // 处理顺序：sass-loader -> css-loader -> style-loader
      // 每个 loader 只关注自身的转换，互不干扰，简洁高效
    }
    ```

    这种链式机制由 Webpack 内部自动调度，非常适合对文件内容进行多步转换。

2. 接口简单、专注于内容转换
   Loader 的实现方式非常直接，只需处理输入内容并返回新内容即可：

    ```js
    // 最简单的 loader 模板
    module.exports = function(source) {
      // source 是传入的文件内容
      const transformedSource = // ...处理逻辑
      return transformedSource; // 返回转换后的内容
    }
    ```

    如果用 Plugin 实现同样的功能，则需要：

    - 拦截模块解析钩子
    - 手动处理模块依赖和状态
    - 处理缓存
      实现难度和复杂度都大大提升。

3. 架构设计角度看

-   单一职责：Loader 只做转换，Plugin 做其他一切
-   组合优于继承：多个 Loader 可以组合使用
-   关注点分离：让简单的事情简单化

**总结：**

-   Loader 更专注于把某类资源（如 JS、CSS、图片等）转换为模块，处理单个文件。
-   Plugin 更强大，能在构建的各个阶段参与，控制和扩展 Webpack 的打包流程。
