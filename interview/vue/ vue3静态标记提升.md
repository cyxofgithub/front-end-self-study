在 Vue3 中，**静态提升（Static Hoisting）** 是模板编译阶段的一项关键优化，其核心目标是通过识别并特殊处理“静态节点”，减少渲染时虚拟 DOM 的创建和比较开销，从而提升性能。

### 先理解：什么是“静态节点”？

静态节点指的是**不会随组件状态（响应式数据）变化而改变的节点**。例如：

-   纯文本节点（如 `<span>Hello</span>`）；
-   没有动态绑定（指令、插值等）的元素（如 `<div class="static">固定内容</div>`）；
-   由多个静态节点组成的“静态片段”（如连续的静态元素）。

这些节点的结构、内容、属性在组件生命周期内始终不变。

### Vue2 的问题：静态节点的“无意义开销”

在 Vue2 中，无论节点是否静态，每次组件重新渲染时，都会**重新创建所有节点的虚拟 DOM**，并在虚拟 DOM 对比（diff）阶段对所有节点进行比较。

这会导致明显的性能浪费：静态节点明明不会变，却要重复创建虚拟 DOM，还要参与 diff 过程，徒增计算成本。

### Vue3 的优化：静态提升如何解决问题？

Vue3 在模板编译阶段会主动识别静态节点，并对其进行“提升”处理，具体分为两步：

#### 1. 编译时：标记并缓存静态节点

编译模板时，Vue3 的编译器会通过静态分析，识别出所有静态节点，并将其**创建逻辑“提升”到渲染函数（render）之外**，用一个变量缓存起来。

例如，对于模板：

```vue
<template>
    <div>
        <p>静态文本</p>
        <!-- 静态节点 -->
        <p>{{ message }}</p>
        <!-- 动态节点（依赖message） -->
    </div>
</template>
```

编译后生成的渲染函数大致如下（简化版）：

```js
// 静态节点被提升到渲染函数外，只创建一次
const hoisted = createVNode('p', null, '静态文本');

function render() {
    return createVNode('div', null, [
        hoisted, // 直接复用缓存的静态节点
        createVNode('p', null, message.value), // 动态节点每次重新创建
    ]);
}
```

可以看到：静态节点的虚拟 DOM（`hoisted`）只会在首次渲染时创建一次，之后每次重新渲染都直接复用这个缓存的结果，不再重复创建。

#### 2. 运行时：diff 阶段跳过静态节点

由于静态节点的虚拟 DOM 被缓存，每次渲染时复用的是同一个引用，因此在虚拟 DOM 对比（diff）阶段，Vue3 会直接判断“新旧虚拟 DOM 中的静态节点是同一个引用”，从而**跳过对静态节点的比较**，只专注于动态节点的差异计算。

### 核心价值

静态提升通过“编译时标记+缓存”和“运行时跳过比较”，从两个层面减少了性能开销：

-   避免静态节点的虚拟 DOM 被重复创建；
-   避免静态节点参与无意义的 diff 对比。

这对于包含大量静态内容（如页面布局、固定文本）的组件来说，性能提升尤为明显。

### 总结

Vue3 的静态提升是“编译时优化”的典型体现：通过提前识别不变的静态节点，将其创建逻辑提升并缓存，最终在运行时减少虚拟 DOM 的创建和比较成本，让渲染更高效。
