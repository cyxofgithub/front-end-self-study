## 如何提升组件的渲染效率，避免不必要的 render

### shouldComponentUpdate

class 组件中 shouldComponentUpdate 方法在组件准备重新渲染之前被调用，它接收两个参数：nextProps 和 nextState，分别表示组件即将接收的新属性和新状态。该方法需要返回一个布尔值，指示组件是否需要重新渲染。如果返回 true，组件将重新渲染；如果返回 false，组件将跳过重新渲染。

```javascript
class MyComponent extends React.Component {
    shouldComponentUpdate(nextProps, nextState) {
        // 比较当前属性和状态与新的属性和状态
        if (
            this.props.someProp !== nextProps.someProp ||
            this.state.someState !== nextState.someState
        ) {
            return true; // 需要重新渲染
        }
        return false; // 不需要重新渲染
    }

    render() {
        // 组件的渲染逻辑
        return <div>{/* ... */}</div>;
    }
}
```

### PureComponent

```javascript
import React from "react";

class MyComponent extends React.PureComponent {
    render() {
        // 组件的渲染逻辑
        return <div>{/* ... */}</div>;
    }
}
```

注：在上述示例中，我们创建了一个继承自 React.PureComponent 的类组件 MyComponent。MyComponent 会继承 PureComponent 的 shouldComponentUpdate 实现，以进行浅比较来决定是否需要重新渲染。

### react.memo

React.memo 用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似。但不同的是， React.memo 只能用于函数组件。如果需要深层次比较，这时候可以给 memo 第二个参数传递比较函数

```javascript
function arePropsEqual(prevProps, nextProps) {
    // your code
    return prevProps === nextProps;
}

export default memo(Button, arePropsEqual);
```

### useCallback

当有回调需要当作属性传入组件时，useCallback 可以配合 react.memo(浅比较)，因为在依赖项不变时能返回相同的引用

### useMemo

减少不必要的重复计算，也能配合 react.memo

### immutable

1、Immutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据

2、对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象(利用这个特性可以巧妙配合上面浅比较更新的问题)

3、Immutable 实现的原理是 Persistent Data Structure（持久化数据结构）:

-   用一种数据结构来保存数据
-   当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费
