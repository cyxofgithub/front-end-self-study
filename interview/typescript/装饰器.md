## 是什么

TypeScript 装饰器是一种特殊的语法，用于修改类、方法、属性或参数的行为或添加元数据。装饰器使用 @ 符号应用于目标对象，并可以在目标对象声明之前或之后使用。

## 怎么用

由于 typescript 是一个实验性特性，若要使用，需要在 tsconfig.json 文件启动，如下：

```javascript
```

## 类型

### 类装饰器

```javascript
function classDecorator(target: any) {
    // 修改类的行为或添加元数据
    target.prototype.newMethod = function() {
        console.log('This is a new method added by the class decorator.');
    };
}

@classDecorator
class MyClass {
    // 类的定义
}

const myObject = new MyClass();
//@ts-ignore
myObject.newMethod(); // 输出: This is a new method added by the class decorator.
```

在上面的例子中，类装饰器 classDecorator 接收一个参数 target，该参数是构造函数的引用。在装饰器函数内部，我们通过修改原型对象来添加一个新的方法 newMethod，该方法可以在类的实例上调用

### 方法装饰器

```javascript
function methodDecorator(target: any, methodName: string, descriptor: PropertyDescriptor) {
    // 修改方法的行为或添加元数据
    const originalMethod = descriptor.value;
    descriptor.value = function() {
        console.log(`Calling ${methodName} method.`);
        originalMethod.apply(this, arguments);
    };
}

class MyClass {
    @methodDecorator
    myMethod() {
        console.log('This is the original method.');
    }
}

const myObject = new MyClass();
myObject.myMethod(); // 输出: Calling myMethod method. This is the original method.
```

在上面的例子中，方法装饰器 methodDecorator 接收三个参数：目标对象的原型 target，方法的名称 methodName 和属性描述符 descriptor。在装饰器函数内部，我们修改了方法的行为，添加了一段在方法调用前输出方法名称的逻辑。

### 属性装饰器

```javascript
function propertyDecorator(target: any, propertyName: string) {
    // 修改属性的行为或添加元数据
    const newPropertyName = `_${propertyName}`;
    Object.defineProperty(target, newPropertyName, {
        value: target[propertyName],
        writable: true,
        enumerable: true,
        configurable: true,
    });

    delete target[propertyName];

    Object.defineProperty(target, propertyName, {
        get: function() {
            console.log(`Getting the value of ${propertyName}.`);
            return this[newPropertyName];
        },
        set: function(value) {
            console.log(`Setting the value of ${propertyName} to ${value}.`);
            this[newPropertyName] = value;
        },
        enumerable: true,
        configurable: true,
    });
}

class MyClass {
    @propertyDecorator
    myProperty: string;
}

const myObject = new MyClass();
myObject.myProperty = 'Hello, World!'; // 输出: Setting the value of myProperty to Hello, World!
console.log(myObject.myProperty); // 输出: Getting the value of myProperty. Hello, World!
```

在上面的例子中，属性装饰器 propertyDecorator 接收两个参数：目标对象的原型 target 和属性的名称 propertyName。在装饰器函数内部，我们修改了属性的行为，将属性的值存储在一个新的私有属性 \_propertyName 中，并定义了新的 get 和 set 方法来访问和修改属性的值。

## 参数装饰器

```javascript
function parameterDecorator(target: any, methodName: string, parameterIndex: number) {
    // 修改参数的行为或添加元数据
    console.log(`Decorating parameter ${parameterIndex} of ${methodName} method.`);
}

class MyClass {
    myMethod(@parameterDecorator myParam: string) {
        console.log(`The value of myParam is ${myParam}.`);
    }
}

const myObject = new MyClass();
myObject.myMethod('Hello!'); // 输出: Decorating parameter 0 of myMethod method. The value of myParam is Hello!
```

在上面的例子中，参数装饰器 parameterDecorator 接收三个参数：目标对象的原型 target，方法的名称 methodName 和参数的索引 parameterIndex。在装饰器函数内部，我们在控制台输出了参数的装饰信息。

## 原理

本质就是改写原型、代理、方法的嵌套
