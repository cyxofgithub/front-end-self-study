## 数字马力一面(2 年)

### taiwindcss 的优势在哪里

[twindcss 的优势在哪里](../css/twindcss的优势.md)

-   开发效率：告别 “写样式”，专注 “拼样式”
-   样式一致性：基于主题的 “标准化”，避免 “样式碎片化”
-   消除命名困扰与冲突：原子化类名天然 “防污染”
-   极致精简：按需生成样式，告别 “冗余 CSS 垃圾
-   零构建门槛：即开即用，适配多场景

### less 和 scss 区别

[less 和 scss 的区别](../css/less%20和%20scss%20区别.md)

1. SCSS 功能更丰富，支持更复杂的变量、嵌套、继承、条件、循环等高级用法，组件化和可维护性更强，生态活跃，主流 UI 框架多选用 SCSS。
2. Less 语法更简单、学习曲线平缓，适合小型或简单项目，工具链支持较全，但在灵活性和社区活跃度上不及 SCSS。
3. 建议：团队化开发、复杂大型项目优先选 SCSS；个人或小型项目可考虑 Less，上手快但可扩展性弱。

### 对函数式编程的理解，你还理解其他编程范式吗？面向对象编程范式

|          | 函数式编程                       | 面向对象编程                       |
| -------- | -------------------------------- | ---------------------------------- |
| 组成单元 | 函数                             | 对象                               |
| 数据管理 | 不可变，数据只读，变化生成新数据 | 可变，状态保存在对象内部           |
| 副作用   | 不鼓励副作用，尽量纯函数         | 可以有副作用，如方法内修改成员变量 |
| 抽象方式 | 用高阶函数、函数组合抽象操作     | 用类、对象、继承实现抽象           |
| 复用手段 | 函数组合、高阶函数               | 继承、接口、多态、组合             |
| 并发安全 | 更易实现（无共享状态）           | 要注意并发时的状态一致性           |
| 代码风格 | 声明式、表达式驱动               | 命令式、语句驱动                   |

如何理解并发安全？

并发调用同一个函数时可能改变对象的状态，而函数不会

### 数组去重，将 id 重复的对象去重

```javascript
function filterRepeatObj(arr) {
    const ids = [];

    const res = arr.reduce((pre, cur) => {
        if (!ids.includes(cur.id)) {
            pre.push(cur);
        }
        ids.push(cur.id);

        return pre;
    }, []);

    return res;
}

console.log(filterRepeatObj([{ id: 1 }, { id: 2 }, { id: 1 }, { id: 3 }]));
```

更优解法：

```javascript
function filterRepeatObj(arr) {
    const idMap = new Map();
    // 遍历数组，仅保留首次出现的id对应的对象
    for (const item of arr) {
        if (!idMap.has(item.id)) {
            // Map的has方法查找复杂度为O(1)
            idMap.set(item.id, item);
        }
    }
    // 将Map的值转为数组返回
    return Array.from(idMap.values());
}

console.log(filterRepeatObj([{ id: 1 }, { id: 2 }, { id: 1 }, { id: 3 }]));
// 输出：[{ id: 1 }, { id: 2 }, { id: 3 }]
```

### 说说对 promise 的理解，它的 API、它的实现原理

理解：

-   本质就是状态机，有三种不可变状态：pedding/fulfildd/rejected
-   解决 “回调地狱”：通过链式调用（then）替代多层嵌套回调。
-   便于错误捕获：通过 catch 统一捕获链中的所有错误，无需在每个回调中单独处理。

实现原理：

参考 [promise 简易版](../../21_Promise/promise简易版实现.md)

-   状态不可逆
-   then 链式调用
-   catch 就是没有 onResolve 的 then
-   finally 不管状态是什么都要执行, 且透传原来状态

### vue3 中是如何使用 proxy 进行代理的

比如 reactvie 在 get 中收集依赖，在 set 和 deleteProperty 中触发依赖

参考

-   [vue3 reactive 原理](../vue/vue3%20reactive%20原理.md)
-   [vue3 为什么改用 proxy](../vue/vue3为什么改用proxy.md)
