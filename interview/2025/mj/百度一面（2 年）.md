## 百度一面（2 年）

### 谈谈你对闭包的理解

允许函数访问其词法作用域（Lexical Scope）中的变量，即使这个函数在其词法作用域之外被调用。闭包的核心在于函数和其词法环境的结合，总结：闭包的核心价值在于状态保留与作用域隔离

闭包的实际场景有哪些？

私有变量、工程函数、事件处理与回调函数、 防抖与节流、模块化（隔离作用域）、柯里化（Currying）

参考 [闭包](../js/闭包.md)

### 说说防抖和节流

防抖：搜索框最后一次输入才发起请求

节流：抢票你点得多快都只在一定频率发一次请求

代码：
参考[防抖与节流函数](./code/八、前端工程化相关/1、防抖与节流函数.js)

### 说说原型和原型链

每个对象都有个隐藏属性[prototype]即这个对象的原型，在代码用[__proto__]读取，原型向上查找的终点是 null

当我们查询一个节点属性时我们会先从对象自身查找，查询不到会沿着原型链查找，如果还没找到返回 undefined

参考：[原型链](./js核心原理.md)

### 说说继承的几种方式

核心分类与关键特点

-   ES6 之前的继承（基于构造函数和原型）
    -   原型链继承：子类原型指向父类实例，继承原型方法，但引用类型属性会被所有实例共享，且无法向父类传参。
    -   构造函数继承：用 call/apply 在子类中调用父类构造函数，解决引用类型共享问题，支持传参，但无法继承父类原型方法。
    -   组合继承：结合前两者（原型链继承方法 + 构造函数继承属性），但父类构造函数会被调用两次，产生冗余属性。
    -   **寄生组合式继承**（最佳实践）：优化组合继承，通过 Object.create 让子类原型直接继承父类原型（而非父类实例），仅调用一次父类构造函数，避免冗余，是 ES6 前的最优解。
    -   原型式 / 寄生式继承：基于对象创建新对象（类似浅拷贝），适合简单场景，但方法无法复用，引用类型仍共享。
-   ES6 类继承（class + extends）
    -   语法层面简化继承，底层仍是原型链，但自动处理原型关联和构造函数指向。
        用 extends 声明继承，super() 调用父类构造函数，清晰直观，是现代 JS 推荐的方式。

参考: [继承的方法和优缺点](../js/继承的方法和优缺点.md)

**ES6 继承是否等同于寄生组合式继承？**

不是完全等同，但核心思想一致：
两者的核心逻辑相同：通过 “构造函数继承实例属性”+“原型链继承原型方法” 实现继承，且都避免了父类构造函数被重复调用（无冗余属性）。
差异在于：

-   ES6 继承是语法层面的封装，底层做了更多优化和扩展（比如处理静态方法继承、super 的灵活使用、更严格的语法约束等）
-   寄生组合式继承是 ES6 之前通过原生 JS 手动实现的 “最佳实践”。

简单说：ES6 的 class + extends 是基于寄生组合式继承的思想，但提供了更简洁、更健壮的语法糖，解决了手动实现时的细节繁琐问题。主要记住寄生组合继承

### es6 class 继承调用 super 的原因

super() 的核心作用是完成父类对子类实例的初始化，是 ES6 为了规范继承逻辑而设置的强制步骤。它**确保了父类的属性和方法能正确绑定到子类实例上**，同时避免了因 this 未初始化而导致的错误。

简单说：没有 super()，子类的 this 就 “不存在”，继承关系无法建立。

### 说说事件循环

事件循环（Event Loop）是专门处理异步任务的机制

浏览器循环流程：同步代码(本质第一个宏任务)->清空微任务->宏任务

node：同步代码(本质第一个宏任务)->清楚所有 process.nextTrick->所有微任务->6 个阶段(每个阶段执行完后会执行重复 2、3 步骤)->宏任务

参考[事件循环](./js核心原理.md)

### vue2、vue3 的区别

参考 [这里](../vue/vue2与vue3的区别.md)

| 维度             | Vue2                       | Vue3                      |
| :--------------- | :------------------------- | :------------------------ |
| 响应式原理       | Object.defineProperty      | Proxy                     |
| 响应式缺陷       | 新增/删除属性无响应        | 完全响应式                |
| 性能             | 普通                       | 更快更优                  |
| API 组织方式     | Options API                | Options + Composition API |
| 生命周期部分钩子 | beforeDestroy/destroyed    | beforeUnmount/unmounted   |
| TypeScript 支持  | 基本（有 Typex/vue-class） | 原生高适配                |
| 多根节点         | 不支持                     | Fragment 支持             |
| 新特性           | 无                         | Teleport、Suspense 等     |
| 体积             | 相对偏大                   | 可 tree-shaking，更小     |

### 箭头函数与普通函数的区别

参考[箭头函数与普通函数的区别](../js/箭头函数与普通函数区别.md)

-   没有 argument（可以用剩余参数来获取参数...args）、protatype（所以也不能作为构造器）
-   语言简洁，this 根据外部作用域

### vue2 中如何实现对数组的操作

参考 [vue2 中如何实现对数组的操作](../vue/vue2%20中如何实现对数组的操作.md)

-   修改数组内容推荐用 push/pop/shift/unshift/splice/sort/reverse 等方法，vue 重写了这几个方法发生变化会触发响应
-   如果希望通过**索引赋值**让视图响应，必须用 `Vue.set` 或 `this.$set`
-   不建议直接写 `arr[i] = val` 或 `arr.length = n`，这些 Vue2 检测不到
