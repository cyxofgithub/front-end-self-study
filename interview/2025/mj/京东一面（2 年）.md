## 京东一面（2 年）

### webpack 打包优化

参考 [讲讲 webpack 优化](../webpack//讲讲webpack优化.md)

话术：webpack 打包优化一般来说主要是优化两个方面的内容：

-   1、构建速度的优化
-   2、优化打包体积

构建速度优化一般来说有以下几种方式：

-   开启多进程打包
-   通过 includes、exclude 来减少 loader 处理的范围
-   通过 dllplugin 来可以将稳定的第三方库单独打包，下次构建只需要引用而不是重复处理从而加快主项目的构建速度
-   webpack5 持久化缓存 缓存文件不变的转换结果

像优化打包体积的话一般可以通过：

-   treeshaking
-   代码分割
-   代码压缩
-   通过 external 将一些库通过 cdn 引入
-   通过设置 babel presetEnv “按需转译”减少 profill 代码

### webpack 压缩到底压缩了什么内容

Webpack 的文件压缩本质是 **“保留功能，剔除冗余”**：

-   对 JS/CSS：主要通过移除空白、注释、死代码，简化命名和语法，合并重复内容来减小体积；
-   对图片 / 字体：通过优化存储方式、剔除无效数据、降低非必要质量来压缩；
-   最终目的是在不影响运行效果的前提下，减少文件传输大小，提升页面加载速度。

### 大文件上传是如何设计的

参考 [断点续传](../前端常见问题/断点续传怎么做.md)
总结来说就是： 拆分传输 + 断点续传 + 可靠合并

常见问题：

-   网络波动导致分片上传失败： 实现错误重试机制，结合断点续传跳过已传分片
-   服务端内存溢出：用文件流合并分片，避免一次性读取大文件到内存
-   客户端计算 MD5 耗时过长： 用 Web Worker 后台计算 MD5，或采用 “文件名 + 大小 + 最后修改时间” 生成临时 fileId
-   分片合并后文件损坏：客户端和服务端分别计算原文件 / 合并后文件的 MD5，进行一致性校验

### 如何区分消息来源？

比如 iframe 和 web worker：发送消息时增加来源标识

如何区分不同脚本 web worker 的消息，为创建的 web worker 分配一个唯一 id：

```javascript
// 主线程
let workerId = 0; // 用于生成唯一标识

// 创建 Worker 并分配 ID
function createWorker(scriptPath) {
    const id = `worker_${workerId++}`; // 唯一标识（如 worker_0, worker_1）
    const worker = new Worker(scriptPath);

    // 存储 Worker 实例与 ID 的映射（可选，用于反向操作）
    worker._id = id;
    worker._scriptPath = scriptPath; // 也可使用脚本路径作为标识

    return worker;
}

// 创建两个不同脚本的 Worker
const workerA = createWorker('worker-a.js');
const workerB = createWorker('worker-b.js');
```

### 如何限制 git 提交信息

有 husky 工具配置提交前的钩子

### jwt 如何使用 如何在 axios 进行二次封装

#### jwt 介绍

JWT（JSON Web Token）是一种基于 JSON 的轻量级身份认证令牌，用于在客户端与服务端之间安全传递用户身份信息。它由三部分组成，通过 . 连接：

-   Header（头部）：指定令牌类型（JWT）和加密算法（如 HS256）；
-   Payload（载荷）：存储用户标识（如 userId）、过期时间（exp）等非敏感信息；
-   Signature（签名）：通过头部指定的算法，结合密钥对 Header 和 Payload 加密生成，用于验证令牌完整性和真实性。
    特点：
-   无状态：服务端无需存储令牌，通过签名即可验证有效性；
-   自包含：载荷中包含用户信息，减少服务端查询数据库的次数；
-   适用于分布式系统：可在多个服务间共享认证信息。

#### 使用流程

JWT Token 的使用流程

-   用户登录：客户端提交用户名 / 密码到服务端；
-   生成令牌：服务端验证通过后，生成 JWT 令牌并返回给客户端；
-   客户端存储：客户端将令牌存储在 localStorage、sessionStorage 或 Cookie 中；
-   携带令牌请求：后续请求时，客户端在 HTTP 头（如 Authorization）中携带令牌；
-   服务端验证：服务端解析令牌，验证签名和过期时间，通过则允许访问，否则拒绝。
-

### 在 axios 二次封装

#### 请求拦截器（自动携带令牌）

```javascript
// 请求拦截器
service.interceptors.request.use(
    (config) => {
        // 从存储中获取令牌，存在则添加到请求头
        const token = getToken();
        if (token) {
            config.headers.Authorization = `Bearer ${token}`; // 规范格式：Bearer + 空格 + token
        }
        return config;
    },
    (error) => {
        // 请求错误（如网络错误）
        return Promise.reject(error);
    }
);
```

#### 3. 响应拦截器（处理令牌过期、错误统一处理）

```javascript
// 响应拦截器
service.interceptors.response.use(
    (response) => {
        // 成功响应：直接返回数据（根据后端格式调整）
        const { data } = response;
        return data;
    },
    async (error) => {
        // 错误处理
        const { response } = error;

        // 处理 401 未授权（令牌过期或无效）
        if (response && response.status === 401) {
            // 尝试刷新令牌（需后端提供刷新接口）
            const newToken = await refreshToken();
            if (newToken) {
                // 刷新成功：重新设置令牌，并重试原请求
                const originalRequest = error.config;
                originalRequest.headers.Authorization = `Bearer ${newToken}`;
                return service(originalRequest); // 重试
            } else {
                // 刷新失败：清除令牌，跳转登录页
                removeToken();
                window.location.href = '/login'; // 跳转到登录页
                return Promise.reject('令牌已过期，请重新登录');
            }
        }

        // 其他错误（如 403 权限不足、500 服务器错误）
        const errorMsg = response?.data?.message || '请求失败';
        console.error('请求错误：', errorMsg);
        return Promise.reject(errorMsg);
    }
);
```

### 网络请求 301 和 302 的意思

参考[HTTP 状态码的分类与含义](./计算机网络.md/)

### 数组乱序，为什么从后往前

做法[乱序的数组](./code/社招面筋/乱序的数组.js)

总结：从后往前时，每轮从 [0, i] 中选一个索引与 i 交换，之后 i 不再参与，从而避免重复选择已处理位置。这是 Fisher-Yates 洗牌算法的标准实现方式

### 如何实现垂直居中

参考[垂直居中方式](./面经总结)

translate 和 margin 有什么不同

前者需要配合定位会脱离文档流
后者只能对块级元素生效

### 如何实现加载中效果

```css
/* 旋转圆环容器 */
.loader-circle {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3; /* 浅色边框 */
    border-top: 4px solid #3498db; /* 高亮边框（旋转时形成动态效果） */
    border-radius: 50%; /* 圆形 */
    animation: spin 1s linear infinite; /* 旋转动画 */
    margin: 40px auto;
    display: block;
}
/* 定义旋转关键帧 */
@keyframes spin {
    0% {
        transform: rotate(0deg);
    } /* 起始角度 */
    100% {
        transform: rotate(360deg);
    } /* 结束角度（一圈） */
}
```
