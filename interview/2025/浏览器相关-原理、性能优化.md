## 浏览器渲染原理

### 浏览器渲染流程

-   关键渲染路径：HTML → DOM 树 → CSSOM 树 → 渲染树 → 布局 → 绘制
-   重排(Reflow)：改变元素几何属性时触发
-   重绘(Repaint)：改变元素外观属性时触发

### 常见问题

#### 重排和重绘的区别？

-   重排：改变元素尺寸、位置等几何属性
-   重绘：改变颜色、背景等外观属性
-   重排必定引起重绘，重绘不一定引起重排

#### 如何减少重排重绘？

```javascript
// 批量修改DOM
const el = document.getElementById('test');
el.style.cssText = 'width: 100px; height: 100px; background: red;';

// 使用transform代替top/left
el.style.transform = 'translateX(100px)';
```

#### 为什么 transform 可以减少重排重绘

**一、浏览器将 HTML/CSS 转换为屏幕上的像素，通常经历三个阶段：**
1、布局（Layout，又称重排）：
计算元素的几何信息（位置、大小、尺寸等）。例如：一个元素的宽度变化可能导致其父元素、兄弟元素的位置改变，因此需要重新计算整个页面的布局关系。这一步是最耗时的，因为 DOM 元素的布局相互依赖，牵一发而动全身。

2、绘制（Paint，又称重绘）：
在确定元素的几何位置后，将元素的视觉属性（颜色、阴影、背景等）绘制到图层中。例如：修改元素的颜色，不需要改变布局，但需要重新绘制该元素。这一步的耗时取决于元素的数量和复杂度（如渐变、阴影等效果会增加绘制成本）。

3、合成（Composite）：
将所有绘制好的图层（Layer）合并为最终的屏幕图像。浏览器会将页面拆分为多个图层（如视频、Canvas、固定定位元素等会被单独分层），合成阶段仅需处理图层的合并，不涉及元素的几何或视觉属性计算，效率极高。

**二、transform 如何跳过重排和重绘？**
transform 是 CSS 中用于元素变换的属性（如平移 translate、缩放 scale、旋转 rotate 等），其特殊之处在于：**它的变换操作仅在 “合成阶段” 处理，完全跳过布局和绘制阶段。**

具体原因如下：
**1、transform 作用于合成层，不影响布局**
浏览器会将应用了 transform 的元素自动提升为一个独立的合成层（类似 “图层”）。合成层内的元素变换不会影响其他元素的几何信息，因此不需要重新计算布局（重排）。
例如：用 transform: translate(10px, 0) 移动元素，不会改变元素的实际占位空间（布局位置），其他元素的布局不受影响；而如果用 left: 10px 移动元素，则会触发布局重算。

**2、transform 的变换由 GPU 加速，无需重绘**
合成层的操作由 GPU（图形处理器）负责，而 GPU 擅长处理矩阵运算（如平移、缩放、旋转的本质是矩阵变换）。

当使用 transform 时，元素的像素已经在绘制阶段被缓存到合成层中，GPU 只需直接对缓存的像素进行变换（如移动图层位置、拉伸图层尺寸），无需重新绘制元素的细节（如颜色、阴影），因此跳过了重绘阶段

**三、注意：并非所有 transform 都绝对不触发重排**

少数情况下，transform 可能间接导致重排，例如：

-   当 transform 导致元素的 “布局边界” 变化（如元素从屏幕内移到屏幕外，触发滚动条出现）；
-   过度使用 transform 导致合成层过多，可能引发 “图层爆炸”（图层数量超过 GPU 处理上限），反而降低性能。
    但在大多数场景下（如元素平移、缩放、旋转），transform 都是性能最优的选择。

## 性能优化

### 资源加载优化

-   CDN 加速：使用就近节点
-   资源压缩：Gzip、Brotli 压缩
-   懒加载：图片、组件按需加载
-   预加载：<link rel="preload">

### 缓存策略

#### HTTP 缓存

##### 1、核心机制：强缓存 + 协商缓存

HTTP 缓存通过 “两级缓存” 决定是否复用本地缓存资源：

-   强缓存：直接复用本地缓存，不发送请求到服务器；
-   协商缓存：发送请求到服务器，由服务器判断是否复用本地缓存。

（1）强缓存：由 Cache-Control 主导
强缓存的核心是通过 Cache-Control（HTTP/1.1）或 Expires（HTTP/1.0，已被 Cache-Control 替代）定义资源的 “新鲜期”。在新鲜期内，浏览器直接使用本地缓存，不与服务器通信。
Cache-Control 的关键指令（多个指令可组合使用）：

-   **max-age**=<seconds>：资源的新鲜期（秒），从请求成功时间开始计算。例如 max-age=3600 表示 1 小时内可直接使用缓存。
-   public：资源可被任何缓存（浏览器、CDN、代理服务器等）缓存。
-   private：资源仅能被浏览器缓存（默认值），代理服务器不可缓存（如用户个人数据）。
-   **no-cache**：不启用强缓存，但可启用协商缓存（必须与服务器验证后才能使用缓存）。
-   no-store：完全不缓存，每次请求都需从服务器获取完整资源（如支付页面）。
-   immutable：资源一旦缓存，在 max-age 内不会改变（如带哈希的静态资源 app.123.js），浏览器无需验证直接使用（减少协商请求）。

（2）协商缓存：由 ETag 与 Last-Modified 主导
当强缓存过期（或 Cache-Control: no-cache）时，浏览器会发送请求到服务器，通过 “验证机制” 判断资源是否更新：若未更新，服务器返回 304 Not Modified，浏览器复用本地缓存；若已更新，返回 200 OK 及新资源。

核心验证头：

-   ETag + If-None-Match：
    -   服务器为资源生成唯一标识（如哈希值，ETag: "abc123"），随响应返回。
    -   浏览器再次请求时，在请求头中携带 If-None-Match: "abc123"，服务器对比标识：若一致，返回 304；若不一致，返回新资源和新 ETag。
    -   优势：比 Last-Modified 更精确（可识别秒内的修改，如文件内容变但修改时间不变的情况）。
-   Last-Modified + If-Modified-Since：
    -   服务器返回资源最后修改时间（Last-Modified: Tue, 15 Aug 2023 12:00:00 GMT）。
    -   浏览器再次请求时，携带 If-Modified-Since: Tue, 15 Aug 2023 12:00:00 GMT，服务器对比时间：若资源未修改，返回 304；否则返回新资源和新时间。

##### 2. 缓存位置：浏览器的 “资源存储分层”

浏览器会将缓存资源存在不同位置，读取优先级从高到低为：

-   Memory Cache（内存缓存）：临时存储，关闭页面后释放（如 Base64 图片、小型 JS/CSS），读取最快。
-   Disk Cache（磁盘缓存）：持久化存储，关闭浏览器后保留（如大型 JS/CSS、图片），读取速度次之。
-   Service Worker Cache：由 Service Worker 管理的缓存（单独分类，见下文）。
-   Push Cache（推送缓存）：HTTP/2 推送的资源缓存，生命周期极短（关闭页面即释放）。

##### 3、适用场景与优缺点

-   适用场景：静态资源（JS、CSS、图片、字体），尤其是不常变化的资源（如第三方库、图标）。
-   优点：完全自动化（浏览器与服务器协作，无需前端代码干预）、性能极高（强缓存可零请求）。
-   缺点：灵活性低（依赖服务器响应头，前端无法主动控制缓存更新）；无法缓存动态数据（如 API 接口返回的用户信息）。

#### Service Worker：“可编程的离线缓存”

Service Worker 是运行在浏览器后台的独立线程（与页面线程隔离），可拦截网络请求、管理缓存，核心价值是实现离线访问（PWA 核心特性）。它的缓存逻辑完全由开发者通过代码控制，比 HTTP 缓存更灵活。

##### 1. 核心机制：生命周期 + Cache API

Service Worker 的缓存能力依赖其生命周期和浏览器的 Cache API（用于操作缓存的对象）。

（1）生命周期：注册 → 安装 → 激活 → 运行

-   注册：页面加载时，前端通过 navigator.serviceWorker.register('sw.js') 注册 Service Worker 脚本（sw.js）。
-   安装（Install）：注册后触发，可在此阶段预缓存关键资源（如 HTML、核心 JS/CSS）

```javascript
// sw.js
self.addEventListener('install', event => {
    // 预缓存资源到名为 "v1" 的缓存
    event.waitUntil(
        caches.open('v1').then(cache => {
            return cache.addAll(['/', '/index.html', '/app.js', '/style.css']);
        })
    );
});
```

-   激活（Activate）：安装完成后触发，可清理旧版本缓存（避免缓存冗余）：

```javascript
self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(cacheNames.filter(name => name !== 'v1').map(name => caches.delete(name)));
        })
    );
});
```

-   运行：激活后，Service Worker 拦截页面的所有网络请求，开发者可定义缓存策略（如 “缓存优先”“网络优先”）。

（2）缓存策略：自定义请求处理逻辑

Service Worker 通过 fetch 事件拦截请求，结合 Cache API 决定是返回缓存、请求网络，还是两者结合：

-   缓存优先（Cache First）：优先用缓存，缓存不存在时请求网络（适合静态资源）：

```javascript
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request).then(response => {
            // 缓存存在则返回，否则请求网络
            return response || fetch(event.request);
        })
    );
});
```

-   网络优先（Network First）：优先请求网络，网络失败时用缓存（适合动态数据）。
-   缓存 + 网络：返回缓存的同时请求网络更新缓存（适合需要实时性但可降级的资源）。

##### 2. 适用场景与优缺点

-   适用场景：离线应用（如文档编辑工具、新闻客户端）、需要精确控制缓存的场景（如资源更新策略自定义）、弱网环境优化。
-   优点：支持离线访问；缓存逻辑完全可编程（前端可控）；可缓存任何资源（包括 HTML、API 数据）。
-   缺点：开发复杂度高（需处理生命周期、缓存更新、跨域等问题）；仅在 HTTPS 或 localhost 下生效（安全限制）；首次访问无法使用（需先安装 Service Worker）。

#### local/seesionStorage

#### 对比

| 维度     | HTTP 缓存                            | Service Worker 离线缓存          | localStorage/sessionStorage |
| -------- | ------------------------------------ | -------------------------------- | --------------------------- |
| 目标     | 减少资源重复请求                     | 实现离线访问 + 自定义缓存逻辑    | 保存客户端业务数据          |
| 控制方   | 服务器主导（响应头）                 | 前端代码主导（JS 逻辑）          | 前端代码主导                |
| 存储内容 | 静态资源（JS、CSS、图片等）          | 任何资源（包括 HTML、API 数据）  | 键值对数据（字符串）        |
| 离线支持 | 不支持（依赖网络验证）               | 支持（可完全离线运行）           | 支持（数据本地存储）        |
| 更新机制 | 依赖服务器响应头（如 max-age、ETag） | 前端代码控制（版本号、缓存清理） | 前端代码手动更新            |

### 网络优化

#### HTTP/2 特性

-   多路复用：一个连接处理多个请求
-   服务器推送：主动推送资源
-   头部压缩：HPACK 算法

#### 请求优化

-   防抖/节流

## 常见面试题

### 浏览器存储

-   Cookie：4KB，每次请求携带
-   localStorage：5MB，永久存储
-   sessionStorage：5MB，会话存储
-   IndexedDB：大容量结构化数据

### 安全相关

-   XSS 防护：输入过滤、输出编码
-   CSRF 防护：Token 验证、SameSite Cookie
-   CSP：内容安全策略

#### csrf 概念和防御措施

可以看这篇文章
https://www.eggjs.org/zh-CN/core/security/#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81-csrf-%E7%9A%84%E9%98%B2%E8%8C%83

攻击流程拆解（以 “银行转账” 为例）：

-   用户登录可信网站：用户在银行网站（bank.com）登录，服务器验证通过后，返回会话 Cookie（如 sessionid=abc123），浏览器保存该 Cookie。
-   恶意网站诱导访问：用户在未退出银行登录的情况下，访问了攻击者的恶意网站（evil.com）。
-   恶意网站发送伪造请求：evil.com 的页面中隐藏着针对 bank.com 的请求（如转账接口）

防御措施：

1、CSRF Token（最有效、应用最广），流程：

-   用户登录后，服务器生成 Token（如 csrf_token=xyz789），存储在服务器端（与用户会话绑定），并通过页面（如 HTML 表单的隐藏字段、JavaScript 变量）返回给客户端。
-   客户端发起敏感请求时，必须在请求中携带该 Token（如表单提交时包含隐藏字段，AJAX 请求时放在 Header 或 Body 中）。
-   服务器收到请求后，对比请求中的 Token 与服务器存储的 Token：一致则合法，不一致则拒绝。

2、验证 Referer/Origin 请求头

3、SameSite Cookie 属性，SameSite 有三个取值：

-   Strict：完全禁止跨站请求携带 Cookie。例如，用户从 evil.com 向 bank.com 发送请求时，不会携带 bank.com 的 Cookie。安全性最高，但可能影响正常跨站功能（如从第三方网站跳转至 bank.com 时，用户需重新登录）。
-   Lax：仅允许 “安全的跨站请求” 携带 Cookie，如通过链接跳转（GET 请求），但禁止表单提交、AJAX 等跨站请求携带。这是浏览器默认值（Chrome 80+），平衡了安全性和可用性。
-   None：允许跨站请求携带 Cookie，但必须同时设置 Secure 属性（仅在 HTTPS 下生效），否则无效。

| 场景                | SameSite=Strict | SameSite=Lax                                 | SameSite=None（+Secure） |
| ------------------- | --------------- | -------------------------------------------- | ------------------------ |
| A 网站跳转到 B 网站 | 不携带          | 携带（因是<a>跳转，属于 Lax 允许的顶级导航） | 携带                     |

4、双重 Cookie（（与 csrf 类似，只是放在 cookie） 验证（辅助措施），流程：

-   用户登录后，服务器生成一个随机值，存入 Cookie（如 csrf_cookie=123）。
-   客户端发起请求时，需从 Cookie 中读取该值，作为请求参数（如 https://bank.com/transfer?csrf_param=123）。
-   服务器验证 csrf_cookie 与 csrf_param 是否一致，一致则通过

### 性能监控

#### 性能指标

-   FCP：首次内容绘制
-   LCP：最大内容绘制
-   TTI：可交互时间：即可交互时间，用于测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。TTI 值越小，代表用户可以更早地操作页面，用户体验就越好。
-   TBT：总阻塞时间：即总阻塞时间，是一个实验室指标，用于计算在首次内容绘制（FCP）和 TTI 之间主线程被阻塞的总时间。在页面加载过程中，主线程负责处理如解析 HTML 或处理 JavaScript 文件等任务，任何超过 50 毫秒的任务被认为是 “长任务”，长任务中超过 50 毫秒的部分即为阻塞时间，TBT 是所有长任务的主线程阻塞时间的总和。

#### 监控工具

```javascript
// Performance API
const observer = new PerformanceObserver(list => {
    for (const entry of list.getEntries()) {
        console.log(entry.name, entry.startTime);
    }
});
observer.observe({ entryTypes: ['navigation', 'resource'] });
```
