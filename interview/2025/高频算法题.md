## 一、数组与字符串操作（高频中的高频）

### 1、两数之和

-   问题：给定数组和目标值，找到两个数的索引使它们的和为目标值。
-   前端应用：数据过滤、表单校验中的快速查找。
-   解题思路：通过哈希表（Map）存储已遍历元素的值与索引，遍历过程中对每个元素计算 “需要匹配的目标值”（target - 当前元素），若哈希表中存在该目标值，则直接返回两个索引（哈希表中存储的前置索引和当前索引）。

```javascript
function twoSum(arr, target) {
    const map = new Map();

    for (let i = 0; i < arr.length; i++) {
        const need = target - arr[i];
        if (map.has(need)) {
            const index = map.get(need);
            return [index, i];
        } else {
            map.set(arr[i], i);
        }
    }

    return [];
}

console.log(twoSum([1, 4, 2, 3, 7], 11));
```

-   时间复杂度：O (n)，仅需遍历一次数组，哈希表的 has 和 set 操作均为 O (1)。
-   空间复杂度：O (n)，哈希表最多存储 n 个元素（n 为数组长度）。

前端应用场景示例

-   数据过滤：在电商商品列表中，需筛选出两件商品总价等于用户预算的组合，可通过类似逻辑快速查找匹配的商品 ID（索引）。

```javascript
// 示例：筛选总价等于预算的两件商品ID
const productPrices = [199, 399, 299, 499]; // 商品价格
const productIds = [101, 102, 103, 104]; // 对应商品ID
const budget = 698; // 预算

function findProductPair(prices, ids, target) {
    const map = new Map();
    for (let i = 0; i < prices.length; i++) {
        const needed = target - prices[i];
        if (map.has(needed)) {
            return [ids[map.get(needed)], ids[i]]; // 返回匹配的商品ID
        }
        map.set(prices[i], i);
    }
    return [];
}

console.log(findProductPair(productPrices, productIds, budget)); // 输出 [102, 103]（399+299=698）
```

### 2、无重复字符的最长子串（LeetCode 3）

问题：求字符串中最长无重复字符的子串长度。
解法：滑动窗口 + 哈希表，动态调整窗口左右边界。
场景：文本编辑器中的实时输入处理。

暴力解：遍历所有子串

-   外层循环执行 n 次（n 为 chars 的长度，即 chars.length）。
-   内层循环：对于第 i 次外层循环，内层循环最多执行 n - i 次（j 从 i 到 n-1）。
-   总循环次数为：n + (n-1) + (n-2) + ... + 1 = n\*(n+1)/2 ≈ O(n²)（等差数列求和）。

滑动窗口思路：通过「滑动窗口」维护一个无重复字符的子串范围，用「哈希表」记录字符最后出现的位置，动态调整窗口左右边界以减少重复计算，时间复杂度优化至 O(n)（n 为字符串长度）。

### 3、三数之和（LeetCode 15）

问题：找到数组中所有不重复的三元组，使它们的和为 0。
解法：排序后双指针法，避免重复组合。
变种：四数之和、最接近的三数之和。

关键思路解析：

-   排序预处理：先对数组排序，便于后续去重和双指针的高效移动。
-   外层循环固定第一个元素：遍历数组，以 nums[i]作为三元组的第一个元素，将问题转化为寻找 “两数之和等于-nums[i]”。
-   双指针寻找剩余两数：左指针 left 从 i+1 开始，右指针 right 从数组末尾开始，根据两数之和与目标值的大小关系移动指针。

去重逻辑：

-   外层循环跳过与前一个元素相同的 nums[i]，避免重复三元组的起始元素。
-   找到有效三元组后，分别跳过左、右指针的重复元素，确保结果中没有重复组合。
-   该解法时间复杂度为 O (n²)（排序 O (n log n) + 双指针遍历 O (n²)），空间复杂度为 O (1)（忽略排序所需空间，仅使用常数级额外空间）。

### 4、合并两个有序数组（LeetCode 88）

问题：将两个有序数组合并为一个有序数组。
解法：从后向前双指针合并，避免额外空间。
扩展：合并 k 个有序链表。

代码说明：

-   指针初始化：i 指向 nums1 中有效元素的最后一位，j 指向 nums2 的最后一位，k 指向 nums1 数组的最后一位（用于填充合并后的元素）。
-   核心合并逻辑：比较 nums1[i] 和 nums2[j]，将较大的元素放入 nums1[k]，并移动对应的指针（i 或 j 左移，k 左移）。
-   处理剩余元素：若 nums2 还有未处理的元素（j >= 0），直接将其依次放入 nums1 剩余的头部位置（因为 nums2 本身有序，且 nums1 剩余元素已在正确位置）。
    复杂度分析：
-   时间复杂度：O (m + n)，仅需遍历两个数组一次。
-   空间复杂度：O (1)，无需额外空间，原地修改 nums1。

### 5、反转字符串（LeetCode 344）

问题：原地反转字符串中的字符。
解法：双指针交换首尾字符。
变形：反转字符串中的单词（LeetCode 151）。

## 二、哈希表与集合（核心数据结构）

### 1、有效的字母异位词（LeetCode 242）

问题：判断两个字符串是否互为字母异位词。
解法：哈希表统计字符频率。

// todo
扩展：分组字母异位词（LeetCode 49）。

### 2、数组中出现次数超过一半的数字（剑指 Offer 39）

问题：找出数组中出现次数超过半数的元素。
解法：摩尔投票法或哈希表统计。
优化：O (1) 空间复杂度。

### 3、快乐数（LeetCode 202）

问题：判断一个数是否为快乐数（不断平方求和，最终是否为 1）。
解法：哈希表记录已出现的数，避免循环。
数学规律：非快乐数会进入 4→16→37→58→89→145→42→20→4 的循环。

## 三、链表操作（前端框架底层核心）

### 1、反转链表（LeetCode 206）

问题：反转单链表。
解法：迭代或递归，迭代法更优（O (1) 空间）。

// todo
扩展：K 个一组反转链表（LeetCode 25）。

### 2、合并两个有序链表（LeetCode 21）

问题：合并两个有序链表为一个有序链表。
解法：递归或迭代，虚拟头节点简化操作。
场景：虚拟 DOM diff 算法中的节点排序。

### 3、环形链表（LeetCode 141）

问题：判断链表是否有环。
解法：快慢指针法，快指针每次走两步。
扩展：找到环的入口节点（LeetCode 142）。 // todo

## 四、树与二叉树（前端组件层级结构）

### 1、二叉树的层序遍历（LeetCode 102）

问题：逐层遍历二叉树，返回每一层的节点值。
解法：队列实现 BFS。
扩展：锯齿形层序遍历（LeetCode 103）。 // todo

### 2、二叉树的最大深度（LeetCode 104）

问题：计算二叉树的最大深度。
解法：递归（DFS）或迭代（BFS）。
变形：平衡二叉树判断（LeetCode 110）。 // todo

### 3、二叉树的最近公共祖先（LeetCode 236）

问题：找到两个节点的最近公共祖先。
解法：递归后序遍历，判断左右子树是否包含目标节点。
场景：前端路由匹配中的层级关系处理。

## 五、动态规划（状态转移核心）

### 1、爬楼梯（LeetCode 70）

问题：每次可爬 1 或 2 步，求到达 n 阶的方法数。
解法：斐波那契数列变形，状态转移方程 dp [i] = dp [i-1] + dp [i-2]。
优化：滚动数组减少空间复杂度。

### 2、买卖股票的最佳时机（LeetCode 121）

问题：给定股价数组，求最大利润。
解法：贪心算法，记录当前最小价格。
扩展：允许多次交易（LeetCode 122）。 // todo

**贪心算法的本质是通过 “短视” 的局部最优选择，在特定问题中高效得到全局最优解。其关键是判断问题是否具备 “贪心选择性质” 和 “最优子结构性质”**—— 这也是区分它与动态规划（需要考虑所有子问题并存储中间结果）的核心差异。

贪心算法在很多经典问题中被广泛使用，例如： // todo

-   找零钱问题（用最少硬币数凑金额）；
-   活动选择问题（在多个时间冲突的活动中选最多不冲突的活动）；
-   哈夫曼编码（数据压缩中的最优编码方式）；
-   最小生成树（Prim 算法、Kruskal 算法）；
-   买卖股票的最佳时机（LeetCode 121）等。

### 3、最长递增子序列（LeetCode 300）

问题：找到数组中的最长递增子序列长度。
解法：动态规划（O (n²)）或贪心 + 二分（O (n log n)）。
场景：可视化图表中的趋势分析。

## 六、排序算法（基础但常考）

### 1、快速排序

原理：分治思想，随机选择枢轴元素。
时间复杂度：平均 O (n log n)，最坏 O (n²)。
优化：三数取中法、尾递归优化。

### 2、归并排序

原理：分治 + 合并，稳定排序。
时间复杂度：O (n log n)，空间复杂度 O (n)。
应用：虚拟 DOM 的 diff 算法（如 React 的 Fiber）。

### 3、堆排序

原理：构建大根堆，每次取出堆顶元素。
时间复杂度：O (n log n)，空间复杂度 O (1)。
扩展：求前 K 个高频元素（LeetCode 347）。

## 七、其他高频题型

### 1、有效的括号（LeetCode 20）

问题：判断括号字符串是否有效。
解法：栈匹配，左括号入栈，右括号出栈比较。
扩展：生成有效括号（LeetCode 22）。

### 2、滑动窗口最大值（LeetCode 239）

问题：给定数组和窗口大小，求每个窗口的最大值。
解法：单调队列维护窗口内的最大值。
场景：实时数据监控中的滑动统计。

### 3、二叉树的序列化与反序列化（LeetCode 297）

问题：将二叉树序列化为字符串，再反序列化为树。
解法：前序遍历 + 分隔符，递归重建树。
注意：空节点的处理。

## 八、前端工程化相关

### 1、防抖与节流函数

防抖：事件触发后延迟执行，若期间再次触发则重新计时。
节流：事件触发后，每隔一段时间执行一次。
实现：闭包 + 定时器，支持立即执行参数。

### 2、深拷贝

问题：递归复制对象，处理循环引用。
解法：WeakMap 记录已复制对象，避免栈溢出。
注意：不可枚举属性和 Symbol 属性的处理。

### 3、数组去重

方法：Set、双重循环 + indexOf、哈希表。
优化：处理引用类型需自定义比较逻辑。

## 备考策略

-   分类突破：优先刷数组、哈希表、链表、树相关题目（占比超 70%）。
-   手写代码：熟练掌握递归与迭代两种实现，注意边界条件（如空数组、单节点链表）。
-   复杂度分析：明确时间 / 空间复杂度，尝试优化（如将 O (n²) 优化为 O (n log n)）。
-   模拟面试：使用 LeetCode 的 “面试模式”，限时完成题目并讲解思路。
-   关注变体：同一问题的不同变形（如两数之和 → 三数之和 → 四数之和）。
