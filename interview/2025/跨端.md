## Hybrid（混合开发）

### 什么是 Hybrid 开发？

Hybrid 开发是一种结合原生（Native）开发和 Web 开发的跨平台开发模式。它以 WebView 为载体（在 App 中嵌入浏览器内核），通过 Web 技术（HTML/CSS/JavaScript）开发页面，同时通过特定机制调用原生能力（如相机、定位等），兼顾 Web 的跨平台灵活性和原生的高性能 / 系统级能力。

### Hybrid 开发的核心原理：JS 与 Native 通信

Hybrid 的核心是 JS（Web 端）和 Native（客户端）的双向通信，其桥梁是 JSBridge。由于 WebView（Web 环境）和 Native（原生环境）是隔离的运行时，需通过 JSBridge 实现数据传递和方法调用。

#### JSBridge 的作用

-   作为 JS 和 Native 的 “翻译官”，定义通信规则（如数据格式、调用方式）；
-   实现双向通信：JS 调用 Native 的能力（如调相机）、Native 触发 JS 的逻辑（如推送通知）。

#### 双向通信的实现方式

##### JS 调用 Native（核心场景）

JS 需要调用原生能力（如获取设备信息、调起支付）时，通过以下方式通知 Native：

###### 方式 1：拦截 URL Scheme（跨平台通用）

原理：JS 构造特定格式的 URL（如 jsbridge://method?params=xxx），Native 的 WebView 拦截该 URL 并解析，执行对应原生方法。

步骤：

1. JS 通过 location.href 或 iframe.src 发起 URL 请求（用 iframe 避免页面跳转）；
2. Native 的 WebViewClient（Android）或 WKNavigationDelegate（iOS）拦截 URL；
3. 解析 URL 中的 method（方法名）和 params（参数），执行原生方法；
4. 执行完毕后，通过 Native 调用 JS 的方式返回结果给 JS。

优点：跨平台兼容；缺点：URL 长度有限制（需压缩参数）、异步处理复杂。

###### 方式 2：注入 API（平台特有）

Native 直接向 WebView 注入对象 / 方法，JS 通过调用注入的 API 实现通信

-   Android：addJavascriptInterface
    原生通过 webView.addJavascriptInterface(对象, "jsBridge") 注入对象，JS 直接调用 window.jsBridge.method(params)。
    注意：API 17 以下存在安全漏洞（远程代码执行），需限制版本或配合校验。
-   iOS（WKWebView）：WKScriptMessageHandler
    原生通过 configuration.userContentController.add(self, name: "jsBridge") 注册消息处理器，JS 通过 window.webkit.messageHandlers.jsBridge.postMessage(params) 发送消息，Native 在 userContentController 中接收并处理。

###### 方式 3：其他补充方式

-   iOS（UIWebView 旧方案）：stringByEvaluatingJavaScriptFromString（已被 WKWebView 替代）；
-   原生拦截 JS 事件（如 alert/confirm），通过修改事件内容传递信息（不推荐，侵入性强）。

##### Native 调用 JS

Native 需要通知 JS（如推送消息、原生事件回调）时，直接调用 WebView 中的 JS 代码：

-   Android：webView.evaluateJavascript("window.jsMethod(params)", callback)（API 19+，异步返回结果）；
-   iOS（WKWebView）：webView.evaluateJavaScript("window.jsMethod(params)") { result, error in ... }。
    原理：Native 通过 WebView 的 API 直接执行 JS 字符串，调用 JS 中定义的全局方法（如 window.onNativeCallback）。

#### 通信的关键细节

-   异步处理：JS 调用 Native 多为异步（如网络请求、设备操作），需通过回调 ID 关联请求和响应（JS 调用时传入 callbackId，Native 返回结果时携带该 ID，JS 通过 ID 匹配回调函数）。
-   数据格式：通常用 JSON 序列化参数（如 {"method":"getLocation","params":{"type":"gps"},"callbackId":"123"}），确保跨平台解析一致性。

### Hybrid 开发的优势与劣势

| 维度     | 优势                                                      | 劣势                                     |
| -------- | --------------------------------------------------------- | ---------------------------------------- |
| 开发效率 | 跨平台复用 Web 代码，迭代快（Web 端更新无需应用商店审核） | 复杂场景需原生与 Web 配合，调试成本高    |
| 性能体验 | 基础页面（如资讯）加载快，接近 Web 体验                   | 复杂交互（如动画、滚动）性能弱于纯原生   |
| 功能覆盖 | 可调用原生能力，兼顾 Web 灵活性                           | 原生能力需通过 JSBridge 封装，扩展成本高 |
| 兼容性   | 依赖 WebView 内核，不同设备表现可能不一致                 | 低版本系统 WebView 存在兼容性问题        |

### Hybrid 开发的常见优化方案

#### 首屏加载优化

-   预加载 WebView：App 启动时提前初始化 WebView，避免使用时再创建；
-   离线包：客户端下载静态资源包（HTML/CSS/JS），WebView 直接加载本地资源，减少网络请求；
-   资源缓存：通过 Cache-Control 或 Service Worker 缓存静态资源

#### 性能优化

-   减少 DOM 操作：复杂 UI 用原生控件替代（如通过 JSBridge 调用原生列表）；
-   避免 WebView 阻塞：将 heavy 任务放在 Web Worker 中执行。

#### 稳定性优化

-   监控 WebView 崩溃 / 白屏：通过原生监听 WebView 生命周期，记录错误日志；
-   降级策略：Web 页面异常时，切换到备用原生页面。

### 常考面试题及解析

#### 拦截 URL Scheme 实现 JS 调用 Native 时，有哪些注意事项？

解析：考察实际开发细节。

-   URL 长度限制：超过长度会被截断，需压缩参数（如用 JSON 字符串 + Base64）；
-   异步回调：原生方法执行后需通过 JS 回调返回结果，需维护回调 ID 映射；
-   安全验证：拦截 URL 时验证来源（如校验页面域名），防止恶意网页调用原生能力；
-   避免页面跳转：用 iframe.src 发起请求（而非 location.href），避免触发 WebView 页面跳转。

#### Android 和 iOS 在实现 JSBridge 时的主要区别是什么？

| 场景                   | Android 实现方式                       | iOS（WKWebView）实现方式                             |
| ---------------------- | -------------------------------------- | ---------------------------------------------------- |
| JS 调用 Native（注入） | addJavascriptInterface 注入对象        | WKScriptMessageHandler 注册消息处理器                |
| 拦截 URL               | WebViewClient.shouldOverrideUrlLoading | WKNavigationDelegate.decidePolicyForNavigationAction |
| 安全问题               | API 17 以下有远程代码执行漏洞          | 无类似漏洞，但需限制消息权限                         |

#### 你用过哪些 Hybrid 框架？它们的底层原理有何不同？

-   Cordova：基于 WebView，通过插件机制封装原生能力（JS 调用插件即调用原生），适合简单场景；
-   React Native：非纯 WebView，通过 JS 引擎解析 JS，生成原生组件（如 View 对应原生 UIView），性能接近原生；
-   Flutter：自绘 UI 引擎（不依赖 WebView 或原生控件），Dart 语言编译为原生代码，跨平台一致性强；
-   小程序框架（如微信小程序）：双线程架构（渲染层 WebView + 逻辑层 JS 引擎），通过 Native 桥接通信。

#### 如何保证 JS 和 Native 通信的安全性？

-   验证来源：Native 拦截 JS 请求时，校验页面域名（如限制仅信任域名的页面可调用）；
-   参数校验：对 JS 传入的参数进行格式 / 合法性校验，防止注入攻击；
-   权限控制：敏感操作（如支付、通讯录）需原生二次验证（如指纹识别）；
-   加密传输：关键参数（如 token）通过非对称加密传递，避免明文泄露。

## 原生渲染方案（React Native/Weex）

### 原生渲染方案的核心逻辑

原生渲染方案（以 React Native、Weex 为代表）是跨平台开发的一种技术路线，其核心逻辑是：通过 JavaScript 编写业务逻辑和 UI 描述，最终将这些逻辑映射到目标平台的原生组件（如 Android 的 View、iOS 的 UIView），而非通过 WebView 渲染 HTML。

这种方案的核心优势在于：

-   性能接近原生：避免了 WebView 的渲染层开销，直接操作原生组件，流畅度、响应速度远超 H5 方案；
-   跨平台一致性：一套代码可运行在 Android、iOS（部分支持 Web），降低开发成本；
-   原生能力复用：可直接调用平台原生 API（如相机、定位），兼顾跨平台效率与原生功能。

### React Native（RN）

React Native 是 Facebook（现 Meta）推出的跨平台原生渲染框架，基于 React 语法，目前是该领域应用最广泛的方案之一。

#### 1. 架构演进：从 Bridge 到新架构

RN 的架构经历了两次重大迭代，核心目标是解决性能瓶颈：

React Native 的架构主要经历了两个阶段，下面简明梳理两者的核心机制、优缺点：

1. **桥接模式（Bridge）**

    - **核心机制**：JS 引擎（如 JSC）与原生通过“桥接层”异步通信，数据需要进行 JSON 序列化和反序列化。
    - **优点**：
        - 实现简单，易于支持多语言通信。
    - **缺点**：
        - 异步通信带来延迟（如用户输入响应慢）。
        - 数据序列化/反序列化开销大，复杂场景下性能较差。
        - JS 端无法直接调用原生方法。

2. **新架构（Fabric + JSI + TurboModules）**
    - **核心机制**：引入 JSI（JavaScript Interface），实现 JS 与原生的直接绑定，支持同步通信。
    - **优点**：
        - 消除了序列化开销，响应速度大幅提升。
        - 支持同步调用原生方法。
        - Fabric 优化了 UI 渲染优先级，提升界面流畅度。
    - **缺点**：
        - 迁移成本较高，需要适配新 API。

##### 为什么桥接架构必须异步通信、JSI 是用同步通信？

桥接架构中，JavaScript 代码和原生代码（Java/Objective-C/Swift）运行在完全隔离的环境中，存在两个核心限制导致必须使用异步通信：

-   线程隔离：
    JavaScript 代码运行在独立的 JS 线程（由 JS 引擎如 JSC 驱动），原生代码运行在原生主线程（或其他原生工作线程）。这两个线程是完全分离的，无法直接共享内存或进行跨线程的同步调用（操作系统级别的线程安全限制）。
-   数据序列化开销：
    JS 和原生之间的通信必须通过序列化 / 反序列化实现（通常是 JSON 格式）。例如，JS 要调用一个原生方法时，需要先将参数转换成 JSON 字符串，通过桥接层传递到原生线程，原生代码解析后执行，再将结果序列化回传。这个过程本质上是 “消息传递”，而非直接调用，因此无法同步等待结果返回。

JSI 是 React Native 新架构（Fabric/ TurboModules）的核心技术，它从根本上改变了 JS 与原生的交互方式：

-   直接内存访问：
    JSI 允许原生代码将方法 “绑定” 到 JS 引擎中，使 JavaScript 可以直接持有原生方法的引用（类似 JS 函数的指针）。此时，JS 调用原生方法不再需要通过桥接层传递序列化消息，而是直接在内存中调用，避免了数据的序列化 / 反序列化开销。
-   线程灵活调度：
    JSI 打破了 JS 线程与原生线程的严格隔离。通过 JSI，JS 可以选择在当前 JS 线程中同步执行原生方法（如果该方法是线程安全的），也可以根据需求调度到其他线程异步执行。这种灵活性使得 “同步调用” 成为可能。

**注意**
JSI 并没有让 JS 获得无限制访问原生资源的能力：

-   权限控制：原生代码仅会将 “允许 JS 调用” 的方法绑定到 JSI，JS 无法随意调用未暴露的原生方法或直接操作原生内存（如修改原生对象的私有属性）。
-   线程安全约束：即使是同步调用，原生方法仍需考虑线程安全（例如避免在 JS 线程中执行耗时操作，或操作 UI 组件），JSI 本身不解决线程安全问题，仍需开发者手动控制。

**总结**

-   桥接架构：JS 与原生是 “隔离的两个世界”，依赖跨线程的序列化消息传递，只能异步通信。
-   JSI：通过直接绑定原生方法到 JS 引擎，实现内存级别的直接调用，支持同步通信，同时大幅减少了性能开销。

#### 2. 工作流程

1. 开发者用 JSX 编写 UI（如<View><Text>Hello</Text></View>）；
2. JSX 通过 Babel 转化为 JavaScript 代码，生成虚拟 DOM（React 元素树）；
3. 虚拟 DOM 经处理后，通过架构层（Bridge 或 JSI）映射到原生组件：

    - Android：转化为 android.view.View 及其子类（如 TextView）；
    - iOS：转化为 UIKit.UIView 及其子类（如 UILabel）；

4. 原生组件最终渲染到屏幕，形成用户可见的界面。

#### 3. 核心特性

-   声明式 UI：同 React，通过状态驱动 UI 更新，简化逻辑；
-   热更新支持：通过 JSBundle 远程更新，无需应用商店审核（受平台限制）；
-   原生交互：可通过 “原生模块”（Native Modules）调用平台 API（如蓝牙、通知）。

**热更新的核心原理**

1. 代码分层设计
   RN 应用的代码分为两部分：

-   原生代码（Native Code）：用 Java（Android）/Objective-C/Swift（iOS）编写，包含原生模块、组件和框架核心逻辑，这部分代码无法热更新，必须通过应用商店审核更新。
-   JavaScript 代码：业务逻辑、UI 组件（JSX）、样式等，被打包成一个或多个 JSbundle（类似压缩后的 JS 文件），这部分代码可以热更新，是热更新的核心对象。

2. 动态加载机制

-   应用首次安装时，JSbundle 被打包在安装包中（main.jsbundle），启动时会优先加载本地 bundle。
-   热更新时，客户端从服务器下载最新的 JSbundle（通常附带版本信息和校验机制），保存到本地沙盒目录。
-   下次启动时，应用会检查是否有更新的 JSbundle，如果有则加载新 bundle，否则加载默认 bundle。

### weex

Weex 是阿里推出的跨平台原生渲染框架，基于 Vue 语法，更贴近前端开发者习惯，广泛应用于阿里系产品（如淘宝、支付宝）

#### 1. 架构设计

Weex 的核心架构分为三层：

-   JS 框架层：基于 Vue 语法，处理业务逻辑和虚拟 DOM 生成；
-   渲染引擎层：将虚拟 DOM 转化为平台无关的渲染指令（如 “创建视图”“设置样式”）；
-   原生渲染层：各平台（Android/iOS/Web）根据指令渲染原生组件（如 Android 的 WXView，iOS 的 WXComponent）。

#### 2. 工作流程

-   开发者用 Vue 语法编写代码（如<template><div>Hello</div></template>）；
-   代码经 Weex 编译器编译为 JSBundle（包含逻辑和渲染描述）；
-   运行时，JSBundle 在 JS 引擎中执行，生成虚拟 DOM；
-   渲染引擎将虚拟 DOM 转化为渲染指令，传递给原生渲染层；
-   原生渲染层解析指令，调用对应平台的原生组件完成渲染。

#### 3. 核心特性

-   Vue 生态兼容：复用 Vue 的语法和工具链（如 Vuex、Vue Router），降低学习成本；
-   轻量灵活：核心库体积小，可嵌入现有原生应用；
-   多端一致性：支持 Android、iOS、Web 三端渲染（Web 端为 H5，但尽量对齐原生体验）。

### RN 与 Weex 的对比

| 维度     | React Native                                  | Weex                           |
| -------- | --------------------------------------------- | ------------------------------ |
| 语法依赖 | 基于 React（JSX）                             | 基于 Vue（模板语法）           |
| 架构核心 | 早期 Bridge，现推进 Fabric/JSI 新架构         | 渲染引擎 + 原生组件映射        |
| 社区支持 | 社区庞大，第三方库丰富（如 React Navigation） | 社区较小，依赖阿里生态         |
| 性能表现 | 新架构下性能接近原生，旧架构有桥接瓶颈        | 中等，复杂场景略逊于 RN 新架构 |
| 适用场景 | 独立 App 或大型跨平台应用                     | 轻量嵌入场景（如电商页面）     |

### 常考面试题及解析

#### 原生渲染方案（RN/Weex）与 WebView 方案的核心区别是什么？

-   渲染层不同：原生渲染直接映射为平台原生组件（如 View/UIView）；WebView 通过 HTML/CSS 渲染，依赖浏览器内核。
-   性能差异：原生渲染避免了 WebView 的 DOM 解析、CSS 渲染开销，滑动、动画等场景更流畅；
-   原生能力调用：桥接效率更高（进程内通信），WebView 需要通过跨进程通信（原生进程与浏览器进程）
-   局限性：原生渲染需维护跨平台组件适配（如 Android/iOS 样式差异），WebView 则受浏览器兼容性限制。

#### React Native 旧架构（Bridge）的性能瓶颈是什么？新架构（Fabric/JSI）如何解决？

-   旧架构问题：
    -   异步通信：JS 与原生通过 Bridge 异步通信，用户输入（如点击）需等待桥接队列，导致延迟；
    -   序列化开销：数据需 JSON 序列化 / 反序列化（如 JS 传递参数到原生），耗时且占内存；
    -   单线程限制：JS 逻辑与 UI 渲染共享 JS 线程，复杂计算会阻塞 UI。
-   新架构优化：
    -   JSI（JavaScript Interface）：允许 JS 直接调用原生 C++ 方法（无需序列化），实现同步通信，消除桥接开销；
    -   Fabric（UI 管理器）：重构 UI 渲染流程，支持异步渲染和优先级调度（如优先处理用户输入）；
    -   TurboModules：原生模块懒加载，按需初始化，减少启动时间。

#### React Native 中如何优化列表性能？

-   使用 FlatList 代替 ScrollView：FlatList 支持按需渲染（只渲染可视区域项），ScrollView 会一次性渲染所有子项，内存占用大；
-   设置 keyExtractor：为每项提供唯一 key，避免重复渲染；
-   优化列表项：
    -   避免项组件重渲染（用 React.memo 包裹）；
    -   减少项内嵌套层级（如用 View 代替多层 Text 嵌套）；
-   启用 getItemLayout：提前计算每项高度，避免动态测量带来的性能损耗；
-   控制 maxToRenderPerBatch：限制每次渲染的项数，避免阻塞 UI 线程。

#### Weex 与 React Native 的核心区别是什么？

-   语法生态：Weex 基于 Vue，适合熟悉 Vue 的开发者；RN 基于 React，依赖 JSX 和 React 生态；
-   架构设计：Weex 更侧重 “渲染引擎 + 原生组件” 的轻量映射，RN 则通过新架构重构底层通信机制；
-   应用场景：Weex 适合嵌入现有 App 的轻量页面（如商品详情），RN 更适合开发独立跨平台 App；
-   热更新支持：RN 热更新方案成熟（如 CodePush），Weex 依赖阿里的 “无线热更新” 体系，灵活性较低。
-   支持平台：RN 支持 ios、android；Weex 支持 ios、Android、h5

#### 原生渲染方案相比纯原生开发的优缺点？

-   优点：
    -   开发效率高：一套代码运行多平台，减少重复开发；
    -   热更新能力：无需应用商店审核即可更新 JS 逻辑；
    -   前端开发者友好：无需学习原生语言（Java/Kotlin/Swift）。
-   缺点：
    -   性能上限低于纯原生：复杂场景（如 3D 渲染、高频动画）仍有差距；
    -   原生适配成本：部分组件需针对 Android/iOS 单独优化（如样式差异）；
    -   版本依赖风险：框架更新可能导致 API 不兼容，需持续维护。

#### React Native 中如何实现 JS 与原生代码的交互

-   JS 调用原生：
    -   原生端定义模块（如 Android 的 ReactContextBaseJavaModule，iOS 的 RCTBridgeModule）；
    -   模块暴露方法（如@ReactMethod 注解）；
    -   JS 端通过 NativeModules 调用（如 NativeModules.MyModule.method()）。
-   原生调用 JS：
    -   JS 端通过 DeviceEventEmitter 注册事件监听；
    -   原生端通过 RCTDeviceEventEmitter 发送事件（如 emit("eventName", data)）；
    -   JS 端监听事件并处理。

#### 为什么 React Native 在复杂动画场景下可能卡顿？如何优化？

-   卡顿原因：
    -   旧架构中，动画计算在 JS 线程，与业务逻辑共享线程，易阻塞；
    -   桥接通信延迟：动画帧数据需通过 Bridge 传递，导致掉帧；
    -   过度重绘：组件频繁重渲染触发原生视图重新计算布局。
-   优化方案：
    -   使用 Animated 库：通过原生驱动（useNativeDriver: true）让动画在原生线程执行，避开 JS 线程；
    -   新架构迁移：JSI 同步通信减少帧数据传递延迟；
    -   减少动画层级：避免嵌套动画组件，简化视图结构；
    -   使用 LayoutAnimation：预定义动画，减少实时计算。

#### React Native 新架构中 Fabric 和 TurboModules 的作用？

-   Fabric：重构的 UI 管理器，解决旧架构 UI 渲染问题：
    -   支持异步渲染：UI 更新可中断并重新排序（如优先处理点击事件）；
    -   同步通信：通过 JSI 直接调用原生渲染方法，减少延迟；
    -   类型安全：用 C++ 接口定义组件属性，避免序列化错误。
-   TurboModules：优化原生模块调用：
    -   懒加载：原生模块按需初始化，减少 App 启动时间；
    -   类型信息暴露：JS 可获取原生模块的方法签名，提前报错；
    -   跨语言调用：通过 JSI 直接调用，无需 Bridge 转发。

## 自绘 UI 方案（Flutter）

### 一、自绘 UI 方案的核心定义

Flutter 的 “自绘 UI 方案” 指其不依赖平台原生控件，而是通过自身渲染引擎直接将 UI 描述绘制到屏幕的技术方案。不同于 React Native 等 “桥接原生控件” 的框架，Flutter 从 UI 逻辑到像素渲染完全自主实现，这是其跨平台一致性的核心保障

### 二、自绘方案的底层支撑

Flutter 自绘能力依赖三大核心机制：**三棵树协作、自主渲染流水线、绘制 API 封装**。

#### 1. 三棵树：UI 描述到渲染的桥梁

Flutter 通过 Widget 树、Element 树、RenderObject 树的协作，将抽象的 UI 描述转化为可绘制的指令：

-   Widget 树：不可变的 UI 配置信息（如颜色、尺寸），仅描述 “是什么”，不涉及渲染逻辑。
-   Element 树：Widget 的实例化节点，负责连接 Widget 和 RenderObject，维护 UI 状态和生命周期。
-   RenderObject 树：自绘的核心载体，负责实际的布局（Layout）、绘制（Paint）、事件处理，是最终执行绘制操作的 “工作单元”。

三者关系：Widget 树触发更新时，Element 树会对比新旧 Widget 并更新对应 RenderObject，最终由 RenderObject 执行渲染。

#### 2. 渲染流水线：从描述到像素的全流程

Flutter 自绘的完整流程可分为 5 个阶段：

-   构建（Build）：根据 Widget 树生成 Element 树，确定 UI 结构。
-   布局（Layout）：RenderObject 树计算每个节点的位置和尺寸（通过 performLayout 方法），采用深度优先遍历，父节点先确定自身尺寸再约束子节点。
-   绘制（Paint）：RenderObject 通过 paint 方法，使用 Canvas 绘制内容（如线条、文本、图片），同样采用深度优先遍历，先绘制父节点再绘制子节点（避免遮挡）。
-   合成（Compositing）：将多个绘制层（Layer）合并为最终画面，Flutter 会自动将透明、动画等元素拆分到独立层，优化重绘效率。
-   渲染（Render）：通过 Skia 引擎（2D 图形库）将合成结果绘制到屏幕，最终生成像素。

#### 3. 自定义绘制的核心 API

开发者通过 Flutter 提供的高层封装实现自绘，核心类包括：

-   CustomPaint：作为自定义绘制的容器 Widget，接收 painter（负责绘制内容）和 foregroundPainter（负责前景绘制，如覆盖层）。
-   CustomPainter：抽象类，需重写 paint(Canvas canvas, Size size) 方法定义绘制逻辑，以及 shouldRepaint(CustomPainter old) 方法判断是否需要重绘（优化性能的关键）。
-   Canvas：提供绘制指令（如 drawLine、drawRect、drawPath、drawText），相当于 “画笔的画布”。
-   Paint：配置绘制样式（如颜色 color、线宽 strokeWidth、填充 / 描边模式 style、渐变 shader），相当于 “画笔”。

### 三、自绘 UI 的优劣势

-   优势：
    -   跨平台一致性：完全自主绘制，避免不同平台原生控件的样式差异（如 Android 的 Material 和 iOS 的 Cupertino 风格可统一）。
    -   高度自定义：可实现复杂 UI（如自定义图表、特殊动画、异形控件），不受原生控件限制。
    -   性能可控：渲染流程透明，可通过优化 RenderObject 或绘制逻辑提升性能（如局部重绘）。
-   劣势：
    -   开发成本高：需手动处理布局、绘制细节，比组合现有 Widget 更复杂。
    -   平台特性适配难：如需调用平台特有 UI 能力（如 iOS 的动态岛），需额外通过 Method Channel 桥接。
    -   学习曲线陡：需理解三棵树、渲染流水线等底层原理，才能写出高效的自绘代码。

### 四、面试常考点及解析

#### 1. Flutter 自绘方案与 React Native 方案的核心区别？

-   原理差异：Flutter 自绘（通过 Skia 直接绘制像素）；React Native 桥接原生控件（UI 最终由 Android/iOS 原生控件渲染）。
-   一致性：Flutter 跨平台表现一致；React Native 受原生控件限制，样式可能因平台不同而差异。
-   性能：Flutter 渲染链路短（无桥接开销），复杂 UI 性能更优；React Native 因 JS 与原生通信开销，高频更新（如动画）可能卡顿。
-   灵活性：Flutter 自绘支持高度自定义；React Native 受限于原生控件能力，复杂 UI 实现难度大。

#### 2. 解释 Flutter 三棵树（Widget、Element、RenderObject）的作用及关系？

-   Widget：UI 配置模板（不可变），仅描述 “是什么”（如 Container 描述一个带背景的容器），不存储状态或执行渲染。
-   Element：Widget 的实例化对象（可变），负责：1）关联 Widget 和 RenderObject；2）维护 UI 状态；3）接收生命周期回调（如 mounted、unmounted）。
-   RenderObject：负责实际渲染，处理布局、绘制、事件检测，是自绘能力的核心载体。

关系：Widget 树变化时，Element 树通过 “diff 算法” 对比新旧 Widget，更新对应 RenderObject 的配置；RenderObject 树最终执行渲染。

#### 3. 如何实现一个自定义绘制控件？请举例说明关键步骤。

以 “绘制一个带进度的圆形” 为例，核心步骤：

##### 继承 CustomPainter 类，重写 paint 和 shouldRepaint：

```javascript
class CircleProgressPainter extends CustomPainter {
  final double progress; // 进度（0-1）

  CircleProgressPainter(this.progress);

  @override
  void paint(Canvas canvas, Size size) {
    // 1. 配置画笔
    final paint = Paint()
      ..color = Colors.blue
      ..strokeWidth = 4
      ..style = PaintingStyle.stroke; // 描边模式

    // 2. 计算圆心和半径
    final center = Offset(size.width / 2, size.height / 2);
    final radius = min(size.width, size.height) / 2 - 2;

    // 3. 绘制背景圆
    canvas.drawCircle(center, radius, paint..color = Colors.grey);

    // 4. 绘制进度圆弧（0到progress*360度）
    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      -pi / 2, // 起始角度（顶部）
      2 * pi * progress, // 扫过角度
      false, // 是否连接到圆心
      paint..color = Colors.blue,
    );
  }

  @override
  bool shouldRepaint(CircleProgressPainter old) {
    // 进度变化时才重绘
    return old.progress != progress;
  }
}
```

##### 使用 CustomPaint 包装自定义 Painter：

```javascript
CustomPaint(
  size: Size(100, 100), // 绘制区域大小
  painter: CircleProgressPainter(0.6), // 进度60%
)
```

#### 4. CustomPainter 中 shouldRepaint 方法的作用？如何优化？

-   作用：判断新的 CustomPainter 实例是否需要触发重绘。返回 true 则调用 paint 方法，返回 false 则跳过。
-   优化原则：仅当绘制内容确实变化时返回 true，避免无效重绘。例如：
    -   若绘制依赖 progress 变量，则对比新旧 progress（如上述例子）。
    -   若依赖多个变量，需对比所有相关变量（如颜色、尺寸）。

#### 5. Flutter 渲染流程中，“布局（Layout）” 和 “绘制（Paint）” 的区别？

-   布局（Layout）：计算 RenderObject 的位置和尺寸，通过 performLayout 方法实现。父节点先确定自身约束（如最大宽度），再递归约束子节点，最终子节点返回自身尺寸。
-   绘制（Paint）：在确定的布局区域内绘制像素，通过 paint 方法实现，使用 Canvas 执行绘制指令（如线条、文本）。

关系：布局是绘制的前提（需先知道 “画在哪里”），绘制是布局的结果呈现。

#### 6. 如何优化自绘 UI 的性能？

-   减少重绘范围：使用 RepaintBoundary 包裹高频重绘区域（如动画控件），使其生成独立图层，避免整个页面重绘。
-   优化 shouldRepaint：精准判断是否需要重绘，避免无效调用 paint。
-   存静态内容：对不变的绘制内容（如背景图），通过 PictureRecorder 缓存为 Picture，复用绘制结果。
-   简化绘制逻辑：减少复杂路径（Path）或渐变（Shader）的使用，复杂图形可预渲染为图片。
-   避免过度重建：使用 const 构造函数（如 const CustomPaint(...)）减少 Widget 不必要的重建，从而减少 Element 和 RenderObject 的更新。

**为什么 const 构造函数能避免过度重建？**

举个例子：

```dart
// 一个简单的页面
class MyPage extends StatefulWidget {
  @override
  _MyPageState createState() => _MyPageState();
}

class _MyPageState extends State<MyPage> {
  int _count = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // 计数器（会变化）
          Text("计数: $_count"),
          // 一个固定不变的文本
          Text("这是一段固定文本"),
          ElevatedButton(
            onPressed: () => setState(() => _count++), // 点击更新计数
            child: Text("增加"),
          ),
        ],
      ),
    );
  }
}
```

const 关键字可以创建 “编译时常量” Widget，它有两个特性：

-   相同参数的 const Widget 会被复用（内存中只有一个实例）。
-   在 build 方法重新执行时，const Widget 不会被重新创建。

修改上面的例子：

```dart
// 用 const 修饰固定文本
Text("这是一段固定文本") → const Text("这是一段固定文本")
```

此时，每次 setState 触发 build 时：

-   计数器 Text("计数: \$\_count") 会重新创建（因为内容变化了）。
-   而 const Text("这是一段固定文本") 不会重新创建，直接复用之前的实例。

Flutter 对比新旧 Widget 时，发现固定文本的 Widget 实例没变，就会跳过对它的 Element 和 RenderObject 的检查，从而减少性能消耗。

#### 7. 自绘控件中如何处理用户交互（如点击）？

有两种方案：

1. 结合 GestureDetector：用 GestureDetector 包裹 CustomPaint，通过回调处理点击（适用于简单交互）：

```javascript
GestureDetector(
  onTap: () => print("点击了圆形"),
  child: CustomPaint(painter: CircleProgressPainter(0.6)),
)
```

2. 重写 RenderObject 的命中检测：对复杂交互（如判断点击是否在特定区域内），需自定义 RenderObject 并重写 hitTest 方法：

```javascript
class RenderCircle extends RenderBox {
  @override
  bool hitTest(HitTestResult result, {required Offset position}) {
    // 判断点击位置是否在圆内
    final center = Offset(size.width/2, size.height/2);
    final isInCircle = (position - center).distance <= radius;
    if (isInCircle) {
      result.add(HitTestEntry(this));
      return true;
    }
    return false;
  }
}
```

#### 8. 为什么 Flutter 能实现跨平台 UI 一致性？

核心原因是自绘引擎 + 统一渲染链路：

-   Flutter 不依赖平台原生控件，而是通过 Skia 引擎直接绘制像素，从 UI 描述到最终渲染完全自主控制。
-   无论是 Android、iOS 还是 Web，Flutter 都使用同一套渲染逻辑（三棵树 + Skia），避免了平台原生控件的样式差异。

## Electron

### 1、什么是 Electron？

Electron 是由 GitHub 开发的开源框架，它允许开发者使用 JavaScript、HTML、CSS 等前端技术栈构建跨平台桌面应用（支持 Windows、macOS、Linux）。其核心本质是将 Chromium（浏览器内核） 和 Node.js 融合，让前端开发者无需学习原生语言（如 C++、Swift）即可开发桌面应用。

典型案例：VS Code、Slack、Discord、Figma 等知名应用均基于 Electron 开发。

### 2、核心架构：多进程模型

Electron 基于 Chromium 的多进程架构，主要包含两种进程：

#### （1）主进程（Main Process）

-   作用：管理应用生命周期、窗口创建、原生功能调用（如菜单、托盘、对话框）等。
-   特点：
    -   一个应用只有 1 个主进程，由 package.json 中的 main 字段指定入口文件（如 main.js）。
    -   可直接调用 Node.js API 和 Electron 提供的主进程模块（如 app、BrowserWindow）。
    -   不能直接操作 DOM（无浏览器环境）。

#### （2）渲染进程（Renderer Process）

-   作用：负责应用的 UI 渲染，每个窗口对应一个独立的渲染进程。
-   特点：
    -   可多个（一个窗口一个），运行在 Chromium 内核的沙箱中。
    -   可直接使用浏览器 API（DOM、BOM）和 Node.js API（需配置开启）。
    -   不能直接调用原生桌面功能（需通过主进程间接调用）。

#### （3）进程通信（IPC：Inter-Process Communication）

-   主进程与渲染进程相互隔离，必须通过 IPC 机制通信：
    -   主进程模块：ipcMain（监听渲染进程发送的消息）。
    -   渲染进程模块：ipcRenderer（向主进程发送消息或监听回复）。
-   通信方式：
    -   同步通信：ipcRenderer.sendSync（可能阻塞渲染进程，慎用）。
    -   异步通信：ipcRenderer.send + ipcMain.on（推荐）。
    -   双向通信：ipcRenderer.invoke + ipcMain.handle（Electron 7+ 新增，更简洁）。

### 3. 核心模块与 API

Electron 提供了丰富的模块，按进程划分：

#### （1）主进程核心模块

-   app：管理应用生命周期（如启动、退出、窗口事件）。

```javascript
app.on('ready', () => {
    /* 应用初始化完成 */
});
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') app.quit();
});
```

-   BrowserWindow：创建和控制窗口（尺寸、标题、是否全屏等）。

```javascript
const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: { nodeIntegration: false }, // 安全配置
});
win.loadFile('index.html'); // 加载页面
```

### Electron 常考面试题及解析

#### 1. 请解释 Electron 的主进程和渲染进程的区别？

-   主进程：全局唯一，负责窗口管理、应用生命周期、原生功能调用，运行 Node.js 环境，无 DOM 访问能力。
-   渲染进程：每个窗口一个，负责 UI 渲染，运行在 Chromium 沙箱中，可访问 DOM 和 Node.js（需配置），但不能直接调用原生功能。
-   通信：必须通过 ipcMain 和 ipcRenderer 进行 IPC 通信。

#### 2. 主进程和渲染进程如何通信？有哪些方式？

主要通过 Electron 提供的 IPC 模块：

-   异步通信：ipcRenderer.send（渲染进程发送） + ipcMain.on（主进程监听），支持双向回调。
-   同步通信：ipcRenderer.sendSync（渲染进程发送） + ipcMain.on（主进程回复），可能阻塞渲染进程，不推荐。
-   invoke/handle 模式（推荐）：ipcRenderer.invoke（渲染进程发起请求） + ipcMain.handle（主进程处理并返回结果），更简洁的 Promise 风格。

```javascript
// 预加载脚本 (preload.js)
const { contextBridge, ipcRenderer } = require('electron');

// 向渲染进程暴露安全的API
contextBridge.exposeInMainWorld('electronAPI', {
    // 转发ping请求
    ping: message => ipcRenderer.invoke('ping', message),
    // 转发文件读取请求
    readFile: filePath => ipcRenderer.invoke('read-file', filePath),
});
```

```javascript
// 主进程 (main.js)
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');

// 创建窗口函数
function createWindow() {
    const mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js'),
            contextIsolation: true, // 启用上下文隔离，更安全
            nodeIntegration: false, // 禁用节点集成
        },
    });

    // 加载HTML文件
    mainWindow.loadFile('index.html');

    // 打开开发者工具
    mainWindow.webContents.openDevTools();
}

// 当Electron初始化完成并准备创建浏览器窗口时调用
app.whenReady().then(() => {
    // 注册处理渲染进程请求的处理器
    ipcMain.handle('ping', async (event, message) => {
        console.log('主进程收到:', message);

        // 模拟异步操作，比如读取文件或网络请求
        await new Promise(resolve => setTimeout(resolve, 1000));

        // 返回结果给渲染进程
        return `来自主进程的响应: Pong! (收到 "${message}")`;
    });

    // 处理文件读取请求
    ipcMain.handle('read-file', async (event, filePath) => {
        const fs = require('fs').promises;
        try {
            const content = await fs.readFile(filePath, 'utf8');
            return { success: true, content, error: null };
        } catch (err) {
            return { success: false, content: null, error: err.message };
        }
    });

    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') app.quit();
});
```

```html
<!-- 渲染进程 (index.html) -->
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Electron IPC Example</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                padding: 20px;
            }
            .container {
                max-width: 800px;
                margin: 0 auto;
            }
            button {
                padding: 10px 20px;
                margin: 5px;
                cursor: pointer;
            }
            #result {
                margin-top: 20px;
                padding: 10px;
                border: 1px solid #ccc;
                min-height: 50px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>IPC Invoke/Handle 示例</h1>
            <button id="pingBtn">发送Ping请求</button>
            <button id="readFileBtn">读取文件</button>
            <div id="result"></div>
        </div>

        <script>
            // 渲染进程脚本
            const resultDiv = document.getElementById('result');
            const pingBtn = document.getElementById('pingBtn');
            const readFileBtn = document.getElementById('readFileBtn');

            // 处理Ping请求
            pingBtn.addEventListener('click', async () => {
                try {
                    resultDiv.textContent = '正在发送请求...';
                    // 调用主进程的ping处理函数
                    const response = await window.electronAPI.ping('Hello from renderer!');
                    resultDiv.textContent = `成功: ${response}`;
                } catch (err) {
                    resultDiv.textContent = `错误: ${err.message}`;
                }
            });

            // 处理文件读取请求
            readFileBtn.addEventListener('click', async () => {
                try {
                    resultDiv.textContent = '正在读取文件...';
                    // 调用主进程的read-file处理函数
                    const response = await window.electronAPI.readFile('package.json');
                    if (response.success) {
                        resultDiv.textContent = `文件内容: ${response.content.substring(0, 500)}...`;
                    } else {
                        resultDiv.textContent = `读取失败: ${response.error}`;
                    }
                } catch (err) {
                    resultDiv.textContent = `错误: ${err.message}`;
                }
            });
        </script>
    </body>
</html>
```

    注意：避免在渲染进程中直接暴露主进程 API，需通过 contextBridge 安全封装。

#### 3. 为什么不推荐使用 remote 模块？替代方案是什么？

-   remote 模块允许渲染进程直接访问主进程对象（如 remote.BrowserWindow），但存在严重安全风险：恶意脚本可通过 remote 绕过沙箱，直接调用主进程 API 操作本地资源。

主进程引入并初始化:

```javascript
// 初始化
require('@electron/remote/main').initialize();
//全局变量
global.shareObject = {
    isDev: isDev,
    currentVersion: currentVersion,
};
```

渲染进程获取数据：

```javascript
// 获取主进程全局变量
const shareObject = window.require('@electron/remote').getGlobal('shareObject');
const isDev = shareObject.isDev;
const currentVersion = shareObject.currentVersion;
// 获取主进程窗口
const { BrowserWindow } = window.require('@electron/remote');
//获取主进程app
const app = window.require('@electron/remote').app;
const version = app.getVersion();
```

-   替代方案：使用 preload 脚本 + contextBridge，在渲染进程和主进程间建立安全的通信桥接，仅暴露必要功能。

```javascript
// preload.js 中安全暴露
contextBridge.exposeInMainWorld('appApi', {
    openNewWindow: () => ipcRenderer.invoke('open-new-window'),
});
// 渲染进程中调用
window.appApi.openNewWindow();
```

#### 4. 如何解决 Electron 应用的安全问题？

**考点：**安全意识与实践。
**解析：**

-   禁用 nodeIntegration（禁止在渲染渲染直接使用 node api）：webPreferences: { nodeIntegration: false }（默认关闭）。
-   开启 contextIsolation：contextIsolation: true（隔离渲染进程上下文）。
-   使用 preload 脚本：通过 contextBridge 有限暴露主进程功能，避免直接暴露 Node.js API。
-   配置 CSP 策略：在 HTML 头部添加 Content-Security-Policy，限制脚本和资源加载（如 default-src 'self'）。
-   避免加载不可信的远程内容：若必须加载，禁用 Node.js 访问并启用沙箱。

#### 5. Electron 应用如何实现自动更新？

**考点：**应用分发与维护。
**解析：**
常用 electron-updater 配合 electron-builder 实现：

1. 配置 package.json 中的更新服务器地址（如 GitHub Releases、私有服务器）。
2. 主进程中监听更新事件：

```javascript
const { autoUpdater } = require('electron-updater');
autoUpdater.setFeedURL({ url: 'https://your-server.com/updates' });
autoUpdater.checkForUpdates();
autoUpdater.on('update-downloaded', () => autoUpdater.quitAndInstall());
```

3. 打包时通过 electron-builder 生成更新元数据（如 latest.yml），并上传到更新服务器。

#### 6. Electron 与 NW.js（Node-WebKit）的区别？

**考点：**同类框架对比。
**解析：**

-   入口差异：Electron 以主进程脚本为入口（分离主 / 渲染进程）；NW.js 直接以 HTML 为入口（早期混合进程模型）。
-   架构设计：Electron 严格分离主 / 渲染进程，安全性更高；NW.js 早期允许渲染进程直接访问 Node.js，安全控制较弱（后期也优化）。
-   生态与社区：Electron 由 GitHub 维护，社区更活跃（如 VS Code 带动）；NW.js 出现更早，但生态相对较小。

#### 7. 如何优化 Electron 应用的性能（如启动速度、内存占用）？

**考点：**性能调优实践。
**解析：**

-   启动速度：
    -   减少主进程初始化工作（延迟加载非必要模块）。
    -   禁用不必要的 Chromium 功能（如 webPreferences: { disableHardwareAcceleration: true } 关闭硬件加速，视场景而定）。
-   内存占用：
    -   限制渲染进程数量（避免过多窗口）。
    -   清理不再使用的渲染进程（win.destroy()）。
    -   优化前端资源（压缩代码、懒加载组件）。
-   打包优化：使用 electron-builder 的 asar 压缩资源，减少文件数量。

#### 8. 如何在 Electron 中调用原生模块（如 C++ 扩展）？

**考点：**原生能力集成。
**解析：**

-   原生模块需针对 Electron 的 Node.js 版本编译（Electron 内置的 Node.js 版本可能与系统不同）。
-   使用 electron-rebuild 工具重新编译原生模块：

```sh
npm install --save-dev electron-rebuild
./node_modules/.bin/electron-rebuild  # 编译适配当前 Electron 版本的原生模块
```

-   注意：原生模块只能在主进程或开启 nodeIntegration 的渲染进程中使用，需配合安全策略。

#### 总结

Electron 的核心是 “前端技术 + 多进程架构”，面试重点考察对主 / 渲染进程模型、IPC 通信、安全机制、打包优化的理解。
实际开发中需平衡跨平台便利性与性能、安全的关系，这也是面试高频考点。

## 多端编译方案（Taro/Uniapp）

### uniapp

#### 核心原理：Uniapp 的跨端实现机制是什么？

**问题本质**
考察对 Uniapp 底层架构的理解，而非仅记「多端编译」的表面结论。需拆解「编译时转译」与「运行时适配」两层逻辑。

**深度解析**
Uniapp 采用「编译时多端转译 + 运行时统一 API 封装」的混合架构，核心分 3 步：

**1. 源码解析与 AST 转换**
Uniapp 基于 Vue 单文件组件（.vue）开发，编译阶段会通过 vue-loader 解析 .vue 文件，生成抽象语法树（AST）。

-   对 模板（template）：根据目标端（如微信小程序、App）将 Vue 模板语法转译为对应端的原生模板（如小程序的 .wxml、App 端 webview 的 .html、nvue 原生渲染的 .ux）。
    例：Vue 的 v-for 会转译为小程序的 wx:for，v-if 转译为 wx:if；
-   对 脚本（script）：通过 Babel 处理 ES6+ 语法，并替换 Uniapp 全局 API（如 uni.request）为对应端的原生 API（如小程序的 wx.request、H5 的 fetch）；
-   对 样式（style）：将 CSS 转译为对应端的样式文件（如小程序的 .wxss、App 端的 .css），同时处理 rpx 适配（按端自动转换为 px/rem/ 原生尺寸单位）。

**2. 运行时 API 与组件适配**
Uniapp 封装了「统一的 API 层（uni 对象）」和「跨端组件库（uni-ui）」：

-   API 适配：uni.xxx 并非直接调用原生 API，而是通过「端判断逻辑」路由到对应端的实现。例如 uni.navigateTo：
    -   小程序端：调用 wx.navigateTo；
    -   H5 端：通过 history.pushState 模拟路由；
    -   App 端（webview 渲染）：调用 webview 的 loadURL 方法；
-   组件适配：Uniapp 基础组件（如 <view> <button>）会根据目标端转译为原生组件（如小程序的 <view>、App 原生渲染的 <div>、H5 的 <div>），避免开发者手动适配组件差异。

**3. 渲染层差异化处理**
Uniapp 支持两种渲染模式，应对不同端的性能需求：

-   Webview 渲染（默认）：App/H5 / 部分小程序端使用 webview 加载转译后的 HTML/CSS/JS，本质是「网页套壳」，开发成本低但性能中等；
-   原生渲染（nvue）：App 端支持 .nvue 文件（基于 weex 引擎），直接调用原生组件（如 Android 的 TextView、iOS 的 UILabel），性能接近原生 App，但样式仅支持 Flex 布局，且组件能力受限（如无 v-html）。

#### 生命周期：Uniapp 的生命周期与 Vue 原生生命周期有何差异？

**问题本质**
考察对 Uniapp 「页面生命周期」与 Vue「组件生命周期」的融合逻辑，以及跨端时的生命周期调用差异。

**深度解析**
Uniapp 生命周期分为 「页面生命周期」 和 「组件生命周期」，前者是 Uniapp 扩展（基于小程序页面生命周期），后者继承 Vue 原生生命周期，两者存在「嵌套调用关系」。

**1. 核心差异：新增页面生命周期**
Vue 仅有「组件生命周期」（如 created mounted），但 Uniapp 为适配小程序的「页面级概念」（如页面跳转、后退），新增了 页面生命周期（如 onLoad onShow onUnload），且优先级高于组件生命周期。

例：页面级组件（pages 目录下的 .vue）的生命周期调用顺序：

```javascript
onLoad（页面加载，仅一次） → created（Vue 组件创建） → onShow（页面显示，每次切换都触发） → mounted（Vue 组件挂载） → onReady（页面首次渲染完成）
```

**2. 跨端生命周期差异**

**小程序端：**严格遵循「页面生命周期」，因小程序是「双线程模型」（逻辑层与渲染层分离），onLoad 在逻辑层初始化时触发，onReady 在渲染层首次渲染完成后触发；
**App 端（webview 渲染）：**生命周期与小程序一致，但 onReady 触发时机略早（webview 加载完成即触发，无需等待渲染层通信）；
**App 端（nvue 原生渲染）：**无 onReady 生命周期（原生渲染无需等待 DOM 加载），且 mounted 触发时机与原生组件初始化同步；
**H5 端：**onLoad 等价于 created（因 H5 无「页面加载」概念，仅路由切换），onUnload 等价于 beforeDestroy。

#### 性能优化：Uniapp 开发小程序 / APP 时，如何解决「列表渲染卡顿」问题？（实战重点）

**问题本质**
考察对「DOM 过量渲染」「重排重绘」「数据更新机制」的理解，需结合 Uniapp 跨端特性给出针对性方案（而非仅搬 Vue 优化手段）。

**深度解析**
列表卡顿的核心原因：一次性渲染过多 DOM 节点 + 频繁数据更新导致重排重绘，需从「渲染量控制」「数据更新优化」「渲染层适配」3 个维度解决：

##### 1. 控制渲染节点数量：虚拟列表 / 分页加载

-   虚拟列表（推荐）：Uniapp 官方提供 <uni-virtual-list> 组件（或第三方 u-list），仅渲染「当前视口内的列表项」，销毁视口外的节点，DOM 数量从 thousands 降至 dozens。
    关键配置：height（列表容器高度）、item-height（列表项固定高度）、data（数据源），需注意：若列表项高度不固定，需通过 estimate-item-height 估算，避免滚动错位；
-   分页加载：通过 onReachBottom（页面触底生命周期）加载下一页数据，每次仅追加 10-20 条，避免初始渲染压力。

##### 2.App 端原生渲染：nvue 替代 vue 处理长列表

若 App 端列表超过 500 项，webview 渲染会明显卡顿，此时改用 .nvue 文件（原生渲染），直接调用原生列表组件（如 Android 的 RecyclerView、iOS 的 UITableView），性能提升 3-5 倍，但需注意：

-   nvue 样式仅支持 Flex 布局，且不支持 v-html scoped 样式；
-   数据更新需通过 this.\$set 触发，避免原生渲染不更新。

#### 工程化：Uniapp 的「条件编译」如何使用？适用场景是什么？（工程化重点）

**问题本质**
考察对 Uniapp 「多端差异化开发」的理解，需讲清条件编译的语法、作用域及实战场景（避免仅记语法，不懂何时用）。

**深度解析**
Uniapp 的「条件编译」是解决「多端代码差异」的核心方案，通过「特殊注释语法」标记某段代码仅在特定端生效，编译时会自动剔除其他端的无效代码。

##### 1. 核心语法：按「端标识」划分

支持在「模板、脚本、样式、配置文件」中使用，语法格式为 #ifdef 端标识 ... #endif（仅在某端生效）或 #ifndef 端标识 ... #endif（不在某端生效）。

常见端标识：MP-WEIXIN（微信小程序）、APP-PLUS（App 端）、H5（H5 端）、MP-ALIPAY（支付宝小程序）。

例 1：模板中差异化渲染（微信小程序显示分享按钮，H5 不显示）：

```javascript
<template>
  <view>
    <!-- #ifdef MP-WEIXIN -->
    <button open-type="share">分享</button>
    <!-- #endif -->
    <!-- #ifndef H5 -->
    <button @click="goNativePage">跳原生页面</button>
    <!-- #endif -->
  </view>
</template>
```

例 2：脚本中差异化 API 调用（App 端用原生存储，H5 用 localStorage）：

```javascript
<script>
export default {
  methods: {
    setStorage(key, value) {
      // #ifdef APP-PLUS
      plus.storage.setItem(key, value); // App 原生存储
      // #endif
      // #ifdef H5
      localStorage.setItem(key, value); // H5 本地存储
      // #endif
    }
  }
}
</script>
```

##### 2. 适用场景（核心）

-   功能差异：某端有专属功能（如微信小程序的「分享到朋友圈」、App 端的「原生推送」），其他端无需实现；
-   API 不兼容：部分 API 仅某端支持（如 uni.getLocation 在 H5 端需 HTTPS 环境，App 端无限制），需差异化处理；
-   性能优化：某端需简化逻辑（如 H5 端无需处理原生插件，可剔除相关代码），减少包体积；
-   样式适配：不同端的样式差异（如 App 端导航栏高度与小程序不同），通过条件编译写专属样式。

##### 3. 注意事项

-   避免过度使用：条件编译会增加代码复杂度，若差异较小（如仅样式不同），优先用 uni.getSystemInfo() 判断端类型，而非条件编译；
-   配置文件中的条件编译：pages.json 中可通过 condition 节点配置某端专属页面（如 App 端新增「会员中心」页面，H5 不显示）。
-

#### 实战问题：Uniapp 开发 App 时，原生插件调用失败如何排查？（难点）

**问题本质**
考察对 Uniapp App 端「原生与前端通信逻辑」的理解，以及问题排查思路（而非仅记解决方案）。

**深度解析**
Uniapp App 端原生插件（如地图、支付、推送）调用失败，核心原因是「原生层配置缺失」或「前端与原生通信异常」，排查步骤分 4 步：

##### 1. 第一步：确认插件适配性

-   检查插件是否支持当前 App 端（Android/iOS）：部分插件仅支持 Android（如某硬件交互插件），iOS 无实现；
-   检查插件版本与 Uniapp 版本兼容性：如 Uniapp 3.x 不兼容 2.x 的旧插件，需升级插件；
-   查看插件文档：确认是否需要「申请原生权限」（如定位插件需在 manifest.json 中配置 android.permission.ACCESS_FINE_LOCATION）。

##### 2. 第二步：检查 manifest.json 配置

Uniapp App 端的原生配置均在 manifest.json 中，常见遗漏点：

-   「App 模块配置」中勾选插件依赖的模块（如支付插件需勾选「支付」模块）；
-   「权限配置」中添加插件所需的原生权限（如相机插件需添加「相机权限」）；
-   「原生插件配置」中正确引入插件（本地插件需填写路径，云端插件需关联 DCloud 账号并勾选）。

##### 3. 第三步：验证前端调用逻辑

-   确认插件初始化时机：原生插件需在「App 启动完成后」调用（如 plusReady 事件后），避免在 onLoad 中直接调用（此时原生层未初始化）；
    例：正确初始化时机：

```javascript
<script>
export default {
  onLoad() {
    // 等待 App 原生层初始化完成
    document.addEventListener('plusready', () => {
      this.initPlugin(); // 调用原生插件
    }, false);
  },
  methods: {
    initPlugin() {
      const plugin = plus.plugins.getPlugin('xxx-plugin'); // 获取插件实例
      if (!plugin) {
        console.error('插件未找到');
        return;
      }
      // 调用插件方法
      plugin.doSomething((res) => { ... }, (err) => { console.error(err) });
    }
  }
}
</script>
```

-   检查参数格式：原生插件对参数类型敏感（如 Android 要求 number 类型，前端传 string 会失败），需严格按插件文档传参。

##### 4. 第四步：查看原生日志定位错误

若前 3 步无问题，需通过原生日志排查：

-   Android 端：在 Android Studio 中打开「Logcat」，过滤关键词（如插件包名），查看原生层报错（如「权限被拒」「方法不存在」）；
-   iOS 端：在 Xcode 中打开「Console」，查看设备日志，定位原生代码异常（如「插件初始化失败」）；
-   Uniapp 自带日志：通过 uni.getLogManager() 获取日志管理器，打印插件调用的详细错误信息。

### Taro

#### 核心原理：Taro 3.x 的跨端架构与 1.x/2.x 有何区别？（必问）

**问题本质**
考察对 Taro 版本演进的理解，以及「编译时」与「运行时」跨端方案的差异（核心考点）。

**深度解析**
Taro 经历了「编译时主导（1.x/2.x）」到「运行时主导（3.x）」的架构升级，核心差异在于「跨端逻辑的实现层」：

Taro 1.x/2.x（编译时方案）和 Taro 3.x（运行时方案）有以下几个核心区别：

1. 核心思想：
   Taro 1.x/2.x 采用**语法转译的方式**，将 React 代码在编译阶段转为各端的原生代码；而 Taro 3.x 则是在**运行时通过适配层**，基于 React/Vue 的运行时，在各端模拟统一的 DOM/BOM 环境，实现跨端适配。

2. 编译与运行流程：
   在 1.x/2.x 中，JSX 会被转为各端的模板（如小程序的 WXML），React 组件也会被转为原生组件，API 需要手动适配（比如 Taro.request 需要转成 wx.request）。
   而 3.x 则是 JSX/React/Vue 语法基本原样保留，运行时通过适配层将 DOM 操作映射为各端的原生操作，API 也会自动适配，无需开发者手动转译。

3. 跨端一致性：
   1.x/2.x 的跨端一致性较低，**开发者需要手动处理一些语法差异**（比如 class 要写成 className）；而 3.x 由于运行时模拟了 DOM/BOM 环境，React 生态的组件可以直接复用，跨端一致性更高。

4. 性能：
   1.x/2.x 性能较高，因为最终编译为原生代码，没有运行时的额外损耗；3.x 因为有运行时的 DOM 映射，会有一定的性能开销，需要针对性优化。

总结来说，Taro 3.x 通过引入运行时适配层，极大提升了跨端一致性和生态复用能力，开发体验更好，但需要注意运行时性能的优化。

**关键结论**
Taro 3.x 的核心升级是「引入运行时适配层」，解决了 1.x/2.x 「编译规则复杂、跨端一致性差、React 生态复用难」的问题。例如：

-   React 组件中使用 document.createElement('div')，Taro 3.x 运行时会在小程序端映射为 createElement('view')，在 H5 端映射为真实 div，开发者无需关心端差异。

#### 编译原理：Taro 如何将 React 组件转译为小程序代码？（深度考点）

**问题本质**
考察对 Taro 编译链路的理解，需拆解「AST 转换」「运行时注入」「模板生成」三个核心步骤。

**深度解析**
以 Taro 3.x 编译 React 组件到微信小程序为例，完整链路分 4 步：

1. 第一步：源码解析与 AST 生成
   Taro 使用 @babel/parser 解析 React 源码（.jsx 文件），生成抽象语法树（AST），识别 JSX 节点、函数组件、Hooks 等语法结构。
   例：React 组件 function App() { return <view>Hello</view> } 会被解析为包含「FunctionDeclaration」「JSXElement」节点的 AST。

2. 第二步：AST 转换与运行时注入
   Taro 通过 @babel/traverse 遍历 AST，进行两项关键操作：

-   JSX 节点转换：将 React 的 JSX 节点转换为 Taro 运行时可识别的格式，例如：
    -   替换 JSX 工厂函数：将 React.createElement 替换为 Taro 运行时的 createElement（来自 @tarojs/runtime）；
    -   处理样式属性：将 className 转换为 class（小程序支持 class），style 转换为小程序支持的内联样式格式；
-   运行时 API 注入：在 AST 中注入 Taro 运行时依赖（如 defineComponent usePageScroll），确保组件能在小程序端正常运行。
    例：转换后的代码会包含 import { defineComponent } from '@tarojs/react'，并将函数组件包裹为 defineComponent(App)。

3. 第三步：模板提取与生成
   Taro 从转换后的 AST 中提取 JSX 模板，生成小程序的 .wxml 文件：

-   分析 JSX 结构，将 div/span 等 HTML 标签映射为小程序原生标签（如 view/text）；
-   将 React 的 useState useEffect 等 Hooks 对应的状态 / 副作用，转换为小程序的「数据响应式系统」（如 data 中的变量、observers 监听）；
-   处理条件渲染（&& ? :）和列表渲染（map），转换为小程序的 wx:if wx:for。

4. 第四步：样式处理与分包配置

-   样式：使用 postcss 处理 CSS 样式，将 px 转换为 rpx（小程序适配单位），并生成 .wxss 文件；
-   分包：根据 taro.config.js 中的 subpackages 配置，将代码拆分为主包和分包，生成小程序的 app.json page.json 配置文件。

#### 性能优化：Taro 开发小程序时，如何减少「重渲染」问题？（实战重点）

**问题本质**
考察对 React 重渲染机制与 Taro 小程序端特性的结合理解，需从「React 优化手段」和「Taro 小程序适配优化」两方面展开。

**深度解析**
Taro 小程序端重渲染的核心原因：React 组件不必要的重渲染 + 小程序双线程模型的通信开销，优化方案分 4 类：

1. 利用 React 原生优化手段：减少组件重渲染触发

-   使用 React.memo 缓存组件：对纯展示组件（props 不变则 UI 不变），用 React.memo 包裹，避免父组件重渲染时子组件跟随重渲染。
    例：

```javascript
const Item = React.memo(({ name }) => {
    console.log('Item 重渲染');
    return <view>{name}</view>;
});
// 仅当 name 变化时，Item 才重渲染
```

-   使用 useMemo/useCallback 缓存数据 / 函数：
    -   useMemo：缓存计算密集型数据（如列表过滤结果），避免每次渲染都重新计算；
    -   useCallback：缓存事件处理函数（如 onClick），避免父组件重渲染时生成新函数，导致子组件 memo 失效。
        例：

```javascript
function Parent() {
    const [count, setCount] = useState(0);
    // 缓存函数，避免每次渲染生成新函数
    const handleClick = useCallback(() => {
        console.log('click');
    }, []);
    // 缓存计算结果，仅当 list 变化时重新计算
    const filteredList = useMemo(() => {
        return list.filter(item => item.age > 18);
    }, [list]);
    return <Item onClick={handleClick} list={filteredList} />;
}
```

2. Taro 小程序端专属优化：减少双线程通信
   小程序是「逻辑层（JS 线程）+ 渲染层（WebView 线程）」双线程模型，数据更新需通过「逻辑层 → 渲染层」通信，频繁通信会导致卡顿。

    - 避免频繁 setState：将多次 setState 合并为一次（如用 useReducer 或批量更新工具）；
      例：避免 for 循环中调用 setCount(count + 1)，改为 setCount(prev => prev + n)；
    - 减少传递给子组件的 props 数量：仅传递子组件必需的 props，避免传递大对象（如整个页面的 state），减少通信数据量；
    - 使用 Taro 提供的 memo 增强版：Taro 扩展了 React.memo，支持忽略某些不影响 UI 的 props 变化（如回调函数），需引入 import { memo } from '@tarojs/react'。

3. 列表渲染优化：虚拟列表 + 固定 key

-   虚拟列表：Taro 官方提供 @tarojs/components 中的 <VirtualList> 组件，原理与 Uniapp 一致，仅渲染视口内列表项；
-   固定 key：列表渲染时，key 需用「唯一且稳定的标识」（如数据 ID），避免用 index 作为 key（数组排序 / 删除时会导致 key 变化，触发全量重渲染）。

#### 生态适配：Taro 如何复用 React 生态组件（如 Ant Design Mobile）？存在哪些坑？（高频）

**问题本质**
考察对 Taro 运行时架构的理解，以及实战中生态适配的经验（而非仅记「能复用」的结论）。

**深度解析**
Taro 3.x 之所以能复用 React 生态组件，核心是「运行时模拟了浏览器的 DOM/BOM 环境」（如 document window addEventListener），让 React 组件误以为运行在浏览器中。但仍存在兼容性问题，需针对性解决。

##### 1. 复用流程（以 Ant Design Mobile 为例）

-   第一步：安装依赖：npm install antd-mobile @tarojs/plugin-html（@tarojs/plugin-html 用于处理 HTML 标签转换）；
-   第二步：在 taro.config.js 中配置插件，启用 HTML 标签转换：

```javascript
module.exports = {
    plugins: [
        [
            '@tarojs/plugin-html',
            {
                // 配置需要转换的 HTML 标签
                convertTagName: {
                    div: 'view',
                    span: 'text',
                    img: 'image',
                },
            },
        ],
    ],
};
```

-   第三步：在组件中直接引入并使用

```javascript
import { Button } from 'antd-mobile';
function App() {
    return <Button onClick={() => console.log('click')}>提交</Button>;
}
```

##### 2. 核心坑点与解决方案

Taro 模拟的 DOM/BOM 并非完全兼容浏览器，常见问题如下：

Taro 复用 React 生态组件时，常见的兼容性问题及应对方法如下：

1. **组件样式错乱**

    - **原因**：React 组件通常使用 CSS Modules 或 Less，而 Taro 对样式的解析规则与 Web 不完全一致，导致样式丢失或错乱。
    - **解决方法**：
        - 在 `taro.config.js` 中配置 `cssLoaderOption`，以支持 CSS Modules。
        - 使用 postcss 插件（如 `postcss-px-to-viewport`）统一处理样式单位，适配小程序端。

2. **事件不触发（如 onClick）**

    - **原因**：React 的事件系统与 Taro 小程序端的事件映射存在差异，例如 onClick 实际需要映射为 bindtap。
    - **解决方法**：
        - 确保已启用 `@tarojs/plugin-html` 插件。
        - 对于不兼容的事件，优先使用 Taro 原生事件（如用 onTap 替代 onClick）。

3. **DOM 操作失效（如 getElementById）**

    - **原因**：Taro 虚拟化了 document，实际并没有真实的 DOM 节点，直接操作 DOM 会失效。
    - **解决方法**：
        - 尽量避免直接操作 DOM，推荐用 React 的状态管理和数据驱动视图。
        - 如确需操作节点，可使用 Taro 提供的 `createSelectorQuery`（即小程序原生 API）进行节点查询。

4. **组件体积过大**
    - **原因**：部分 React 组件库包含大量浏览器专有代码（如 window.scrollTo），Taro 编译时未能完全剔除，导致包体积膨胀。
    - **解决方法**：
        - 配置 `mode: 'production'`，利用 tree-shaking 剔除无用代码。
        - 优先选择更轻量的组件库（如 taro-ui 替代 Ant Design Mobile），减少无关依赖。

通过以上针对性措施，可以大幅提升 Taro 复用 React 生态组件时的兼容性和开发体验。

#### 实战问题：Taro 打包小程序时，出现「包体积超限（>2MB）」如何解决？（高频）

**问题本质**
考察对 Taro 工程化与小程序包体积优化的理解，需从「代码拆分」「资源压缩」「依赖优化」三个维度给出系统性方案。

**深度解析**
小程序主包体积超限会导致无法上传，Taro 优化方案分 5 类，按优先级排序：

##### 1. 优先级 1：分包加载（核心方案）

如前所述，通过 subpackages 配置将代码拆分为「主包 + 分包」，主包仅包含首页和公共资源，分包按需加载。
关键技巧：将「Tab 页面」放入主包，「二级页面」放入分包；将「大型组件库（如 Ant Design Mobile）」放入常用分包（如商品分包），避免主包引入。

##### 2. 优先级 2：依赖优化（减少第三方包体积）

-   替换大体积依赖：如用 lodash-es 替代 lodash（支持 tree-shaking），用 dayjs 替代 moment.js（体积仅为 1/10）；
-   按需引入组件库：如 Ant Design Mobile 需配置 babel-plugin-import 实现按需引入，避免全量引入：

```javascript
// .babelrc
{
  "plugins": [
    ["import", { "libraryName": "antd-mobile", "style": "css" }]
  ]
}
```

-   剔除无用依赖：用 webpack-bundle-analyzer 分析依赖体积，删除未使用的依赖（如 npm uninstall 无用包）。

##### 3. 优先级 3：资源压缩与 CDN 托管

-   图片 / 字体资源：小程序主包内的图片体积是包体积的主要组成部分，需：
    -   将图片上传到 CDN（如腾讯云 COS），用远程 URL 替代本地图片；
    -   压缩图片（如用 tinypng 压缩 PNG/JPG，用 svg-sprite-loader 合并 SVG 图标）；
-   代码压缩：在 taro.config.js 中启用代码压缩：

```javascript
module.exports = {
    mini: {
        webpackChain(chain) {
            // 压缩 JS
            chain.optimization.minimize(true);
            // 压缩 CSS
            chain.plugin('extract-css').tap(args => {
                args[0].minimize = true;
                return args;
            });
        },
    },
};
```

##### 优先级 4：代码拆分（SplitChunks）

用 Webpack 的 splitChunks 插件将公共代码（如 @tarojs/runtime、组件库公共部分）拆分为独立 chunk，避免重复打包：

```javascript
// taro.config.js
module.exports = {
    mini: {
        webpackChain(chain) {
            chain.optimization.splitChunks({
                chunks: 'all',
                minSize: 20000, // 拆分阈值：超过 20KB 的 chunk 才拆分
                cacheGroups: {
                    vendor: {
                        test: /[\\/]node_modules[\\/]/, // 匹配 node_modules 中的依赖
                        name: 'vendor', // 拆分后的 chunk 名
                        priority: 10, // 优先级：高于其他 cacheGroups
                    },
                },
            });
        },
    },
};
```

##### 优先级 5：删除无用代码（Tree-Shaking）

Taro 生产环境默认启用 Tree-Shaking，但需确保代码满足「ES 模块规范」（import/export），避免使用 CommonJS 规范（require/module.exports），否则 Tree-Shaking 失效。

-   检查依赖：确保第三方包支持 ES 模块（如 package.json 中有 module 字段）；
-   代码规范：避免在代码中使用 require，统一用 import 引入模块。

### Taro vs Uniapp 对比

**Uniapp 与 Taro 对比分析**

1. **技术栈依赖**

    - Uniapp：以 Vue 为核心，优先支持 Vue 2，也兼容 Vue 3。对 Vue 开发者极为友好，上手门槛低。
    - Taro：支持 React、Vue 2、Vue 3 等多种技术栈，其中 React 生态适配最佳，适合 React 团队。

2. **跨端覆盖能力**

    - Uniapp：可覆盖小程序、APP、H5、快应用等多端，APP 端采用 nvue 原生渲染，成熟度高。
    - Taro：支持小程序、H5、APP（APP 端基于 React Native，成熟度略低于 Uniapp）。

3. **学习成本**

    - Uniapp：学习曲线平缓，主要是 Vue 语法加上 Uniapp 扩展 API，文档完善，上手非常快。
    - Taro：需要掌握 React/Vue 及 Taro 的运行机制，生态适配过程中可能遇到一些坑，学习成本略高。

4. **性能表现**

    - Uniapp：APP 端原生渲染（nvue）性能较好，小程序和 H5 性能中等。
    - Taro：小程序和 H5 性能中等，APP 端（React Native）性能波动较大。

5. **生态丰富度**

    - Uniapp：拥有自有生态（如 uni-ui），但第三方生态相对较少。
    - Taro：可直接复用 React/Vue 生态（如 Ant Design Mobile、Vant 等），生态资源更丰富。

6. **适用场景**
    - Uniapp：
        1. 需要覆盖 APP 端，尤其有原生渲染需求的项目
        2. 团队以 Vue 技术栈为主
        3. 追求多端快速开发、低定制化场景
    - Taro：
        1. 团队以 React 技术栈为主
        2. 需要复用 React 生态组件
        3. 重点覆盖小程序/H5，APP 端需求不强

## 小程序生态

### 一、基础概念与区别

#### 1、 小程序和 H5 有什么区别？

两者核心差异体现在运行环境、能力边界和开发模式上，具体对比如下：

```javascript
| 维度       | 小程序                                             | H5                                         |
|------------|--------------------------------------------------|--------------------------------------------|
| 运行环境   | 依赖小程序宿主（如微信客户端），有独立运行时       | 依赖浏览器内核，受浏览器环境限制           |
| 开发模式   | 需遵循特定规范（如微信用 wxml/wxss/js），有统一 IDE | 基于 HTML/CSS/JS，无强制 IDE，框架灵活     |
| API 能力   | 可调用宿主原生能力（如支付、扫码、地理位置）       | 仅能调用浏览器 API（如 localStorage、fetch）|
| 性能       | 启动快（预加载机制），渲染性能接近原生             | 依赖网络加载，频繁操作 DOM 易卡顿          |
| 更新机制   | 需通过平台审核后发布，用户自动更新                 | 实时更新（部署到服务器即可）               |
| 访问入口   | 需在宿主内搜索 / 扫码，入口相对固定                | 可通过 URL 直接访问，分享灵活              |
```

#### 2. 小程序的目录结构是怎样的？

一个典型的小程序项目包含全局配置文件和页面文件，核心结构如下：

```javascript
├── app.js         // 应用入口，定义应用生命周期
├── app.json       // 全局配置（页面路径、窗口表现、tabBar等）
├── app.wxss       // 全局样式（作用于所有页面）
├── pages/         // 页面目录（每个页面一个子目录）
│   ├── index/     // 首页
│   │   ├── index.js    // 页面逻辑（生命周期、数据处理）
│   │   ├── index.json  // 页面配置（覆盖全局配置）
│   │   ├── index.wxml  // 页面结构（类似HTML，用组件标签）
│   │   └── index.wxss  // 页面样式（仅作用于当前页面）
├── components/    // 自定义组件目录
├── utils/         // 工具函数目录
└── images/        // 静态资源目录
```

-   app.json 是核心配置，例如通过 pages 数组定义页面路径（第一个为首页），通过 tabBar 配置底部导航。
-   页面的 4 个文件中，.json 和.wxss 可选（无则继承全局配置 / 样式），.wxml 和.js 必选。

### 二、生命周期

1. 小程序的应用生命周期和页面生命周期有哪些？执行顺序是怎样的？
   小程序的生命周期分为应用级和页面级，分别对应整个应用和单个页面的生命周期。
   **应用生命周期（app.js 中定义）：**

-   onLaunch(options)：应用初始化完成时触发（全局只触发 1 次），可获取启动参数（如扫码进入的场景值）。
-   onShow(options)：应用从后台切换到前台时触发（每次显示都会执行）。
-   onHide()：应用从前台切换到后台时触发（如按 Home 键退出微信）。
-   onError(err)：应用发生错误时触发（如代码报错）。

    **页面生命周期（页面 xxx.js 中定义）：**

-   onLoad(options)：页面加载时触发（仅 1 次），可接收路由参数（options 为参数对象）。
-   onShow()：页面显示时触发（每次切换到该页面都会执行，包括从后台切回）。
-   onReady()：页面初次渲染完成时触发（此时可获取 DOM 节点）。
-   onHide()：页面隐藏时触发（如跳转到其他页面）。
-   onUnload()：页面卸载时触发（如 wx.redirectTo 或 wx.navigateBack 关闭页面）。

    **执行顺序（首次打开首页）：**
    app.onLaunch → app.onShow → 页面 onLoad → 页面 onShow → 页面 onReady

2. onLoad 和 onShow 的区别是什么？

-   onLoad：仅在页面首次加载时执行 1 次，适合初始化数据（如从路由参数获取 ID 并请求接口）。
-   onShow：每次页面显示时执行（包括首次加载、从其他页面返回、应用从后台切回），适合刷新数据（如重新请求最新列表）。

### 三、数据绑定与事件处理

#### 1. 小程序如何实现数据绑定？setData 有哪些注意事项？

-   数据绑定：通过{{ }}在 wxml 中绑定 data 中的数据，例如：

```
<view>{{ message }}</view>
<button bindtap="changeMsg">修改内容</button>
```

```javascript
Page({
    data: { message: 'Hello' },
    changeMsg() {
        this.setData({ message: 'World' }); // 更新数据并触发渲染
    },
});
```

-   setData 注意事项：

1. 不能直接修改 data：需通过 setData 更新（直接修改 this.data.message = "World"不会触发渲染）。
2. 异步执行：setData 是异步操作，修改后不能立即获取最新值（如需同步处理，可在回调中操作）。

```javascript
this.setData({ message: 'World' }, () => {
    console.log(this.data.message); // 正确：输出"World"
});
```

3. 批量更新：避免频繁调用（每次调用会触发页面重渲染），建议合并修改：

```javascript
// 推荐：合并更新
this.setData({ a: 1, b: 2 });
// 不推荐：多次调用
this.setData({ a: 1 });
this.setData({ b: 2 });
```

4. 数组 / 对象更新：需指定完整路径，例如修改数组某一项：

```javascript
this.setData({ 'list[0].name': '新名称' }); // 正确
```

#### 2. 事件绑定中 bind 和 catch 有什么区别？target 和 currentTarget 的区别？

-   bind vs catch：

    -   两者都用于绑定事件（如 bindtap、catchtap），核心区别在事件冒泡：
        -   bind：允许事件冒泡（子元素事件会触发父元素同名事件）。
        -   catch：阻止事件冒泡（子元素事件不会触发父元素事件）。

-   target vs currentTarget：
    -   target：触发事件的源组件（如点击子元素时，target 是子元素）。
    -   currentTarget：绑定事件的当前组件（无论点击子元素还是自身，currentTarget 都是绑定事件的组件）。

```html
<view bindtap="onParentTap" id="parent">
    <view bindtap="onChildTap" id="child">点击</view>
</view>
```

点击 child 时：

-   onChildTap 中，e.target.id = "child"，e.currentTarget.id = "child"。
-   onParentTap 中，e.target.id = "child"，e.currentTarget.id = "parent"。

### 四、组件与通信

#### 1. 如何创建和使用自定义组件？

自定义组件是复用 UI 和逻辑的核心方式，步骤如下：

1. 创建组件：在 components 目录新建组件文件夹（如 my-component），生成 4 个文件：

    - my-component.js：组件逻辑（定义 properties、methods 等）。
    - my-component.wxml：组件结构。
    - my-component.wxss：组件样式（默认隔离，不影响外部）。
    - my-component.json：声明为组件（{ "component": true }）。

2. 引入组件：在使用组件的页面 xxx.json 中配置：

```json
{
    "usingComponents": {
        "my-component": "/components/my-component"
    }
}
```

3. 使用组件：在页面 wxml 中直接引用：

```javascript
<my-component title="标题" bind:myevent="onMyEvent"></my-component>
```

#### 2. 组件与页面如何通信？

常见通信方式有 3 种：

1. 父传子（properties）：
    - 组件在 properties 中定义接收的属性：

```javascript
Component({
    properties: {
        title: { type: String, value: '默认标题' }, // 类型+默认值
    },
});
```

-   页面传递：<my-component title="来自页面的标题"></my-component>。

2. 子传父（triggerEvent）：

-   组件通过 triggerEvent 触发事件，携带数据：

```javascript
this.triggerEvent('myevent', { data: '来自组件的数据' });
```

-   页面监听：<my-component bind:myevent="onMyEvent"></my-component>，在 onMyEvent 中通过 e.detail 获取数据。

3. 直接获取组件实例（selectComponent）：

-   页面通过 this.selectComponent(选择器)获取组件实例，直接调用组件方法：

```javascript
const comp = this.selectComponent('#myComp');
comp.setData({ title: '页面直接修改' }); // 调用组件的setData
comp.handleClick(); // 调用组件的自定义方法
```

### 五、路由管理

#### 1. 小程序有哪些路由跳转方式？区别是什么？

小程序提供 5 种路由跳转 API，核心区别在于是否保留当前页面、是否支持跳转到 tabBar 页面：

| API             | 特点                                                | 适用场景                   |
| --------------- | --------------------------------------------------- | -------------------------- |
| wx.navigateTo   | 保留当前页面，跳转到新页面（页面栈最多 10 层）      | 普通页面跳转（可返回）     |
| wx.redirectTo   | 关闭当前页面，跳转到新页面                          | 无需返回的跳转（如登录后） |
| wx.switchTab    | 只能跳转到 tabBar 页面，关闭所有非 tabBar 页面      | 切换底部导航栏页面         |
| wx.reLaunch     | 关闭所有页面，跳转到任意页面（包括 tabBar）         | 重启小程序（如退出登录后） |
| wx.navigateBack | 关闭当前页面，返回上一页面（可指定返回层数，delta） | 从子页面返回父页面         |

#### 2. 如何传递和接收路由参数？

-   传递参数：通过 URL 拼接键值对（?key=value&key2=value2），例如：

```javascript
wx.navigateTo({ url: '/pages/detail/detail?id=1&name=test' });
```

-   接收参数：在目标页面的 onLoad 生命周期中通过 options 获取：

```javascript
Page({
    onLoad(options) {
        console.log(options.id); // 1
        console.log(options.name); // "test"
    },
});
```

### 六、本地存储

1. 小程序的本地存储 API 有哪些？和 H5 的 localStorage 有什么区别？

-   核心 API：
    -   wx.setStorageSync(key, data)：同步存储数据。
    -   wx.getStorageSync(key)：同步获取数据。
    -   wx.removeStorageSync(key)：同步删除数据。
    -   wx.clearStorageSync()：同步清空所有存储。
        （另有异步版本：wx.setStorage 等，需用回调或 Promise）
-   与 localStorage 的区别：

| 维度     | 小程序存储                              | H5 localStorage                  |
| -------- | --------------------------------------- | -------------------------------- |
| 隔离性   | 不同小程序数据隔离，不共享              | 同域名下的页面共享               |
| 存储限制 | 单个 key 最大 1MB，总存储约 10MB        | 一般为 5MB（不同浏览器有差异）   |
| 数据类型 | 支持原生类型、对象、数组（自动序列化）  | 仅支持字符串（需手动序列化）     |
| API 风格 | 同步 / 异步 API 分开（Sync 后缀为同步） | 同步 API（localStorage.setItem） |

### 七、性能优化

#### 1. 如何优化小程序的加载速度？

加载速度是用户体验的核心，主要优化手段如下：

-   **分包加载：**将代码拆分为主包和分包，用户仅下载当前需要的包（主包限 2MB，分包限 2MB / 个，总限 20MB）。

```javascript
// app.json 配置分包
{
  "pages": ["pages/index"], // 主包页面
  "subPackages": [
    {
      "root": "packageA", // 分包根目录
      "pages": ["pages/detail"] // 分包页面
    }
  ]
}
```

-   **预加载分包**：在 app.json 中配置 preloadRule，指定进入某页面时预加载其他分包：

```javascript
"preloadRule": {
  "pages/index": { "network": "all", "packages": ["packageA"] }
}
```

-   **图片优化：**

    -   使用微信 CDN（wx.getImageInfo 获取优化后的链接）。
    -   图片懒加载（wx.createIntersectionObserver 监听元素可见性）。
    -   压缩图片（限制尺寸，使用 WebP 格式）。

-   **减少启动阻塞：**app.js 的 onLaunch 中避免同步操作（如复杂计算），优先执行必要初始化。

#### 2. 如何优化小程序的渲染性能？

-   **减少 setData 调用：**合并多次修改，避免在循环中调用 setData。
-   **合理使用 wx:if 和 hidden：**
    -   wx:if：条件不满足时销毁组件（适合切换频率低的场景）。
    -   hidden：条件不满足时隐藏组件（适合切换频率高的场景，避免频繁销毁 / 创建）。
-   **列表渲染优化：**
    -   给列表项加 key（wx:key），避免重排时全量渲染。
    -   长列表用 recycle-view（虚拟列表，只渲染可视区域项）。
-   **避免过度渲染：**减少嵌套层级（wxml 嵌套不超过 10 层），移除冗余节点。

### 八、常见问题与解决方案

#### 1. 小程序出现白屏的可能原因及解决方法？

-   原因 1：启动时网络请求失败（如接口报错）。
    解决：添加错误捕获（try/catch），显示友好的错误提示。
-   原因 2：代码报错（如语法错误、未定义变量）。
    解决：通过开发者工具的 “调试器” 查看报错信息，修复代码；上线前开启 “代码保护” 避免暴露源码。
-   原因 3：包体积过大，加载超时。
    解决：分包加载、压缩资源（图片 / 代码）、删除冗余代码。
-   原因 4：手机内存不足或微信版本过低。
    解决：提示用户清理内存或更新微信，通过 wx.getSystemInfo 判断版本并兼容。

#### 2. 如何实现小程序的分享功能？

通过页面生命周期 onShareAppMessage 配置分享信息：

```javascript
Page({
    onShareAppMessage(res) {
        return {
            title: '分享标题', // 分享标题
            path: '/pages/index?id=1', // 分享路径（带参数）
            imageUrl: '/images/share.jpg', // 分享图片（建议5:4比例）
        };
    },
});
```

-   点击页面右上角 “三个点” 触发分享时，会调用该方法。
-   如需自定义分享按钮，需给按钮添加 open-type="share"：

```javascript
<button open-type="share">自定义分享</button>
```
