## 一、核心协议：HTTP/HTTPS/TCP/UDP

### 1. HTTP 方法的区别（GET vs POST 是重点）

HTTP 定义了多种请求方法（如 GET、POST、PUT、DELETE 等），核心是 “语义化”—— 通过方法名告诉服务器 “要做什么操作”。其中 GET 和 POST 的区别是高频考点，需从本质差异而非表面现象回答：

| 维度     | GET                                        | POST                                       |
| -------- | ------------------------------------------ | ------------------------------------------ |
| 语义     | 从服务器“获取”资源（只读）                 | 向服务器“提交”资源（可能修改数据）         |
| 数据位置 | 参数放在 URL 中（有长度限制，约 2KB）      | 参数放在请求体（body）中（无长度限制）     |
| 缓存     | 可被浏览器缓存（如 GET 请求的结果）        | 默认不缓存（需手动设置缓存头）             |
| 幂等性   | 幂等（多次请求结果一致，不改变服务器状态） | 非幂等（多次请求可能重复提交数据）         |
| 安全性   | 数据暴露在 URL 中（明文，易被拦截）        | 数据在请求体中（相对安全，但仍为明文传输） |

### 2. HTTP 状态码的分类与含义

状态码是服务器对请求的 “回应状态说明”，需掌握分类逻辑和高频码的场景：

-   1xx（信息类）：服务器已接收请求，需客户端继续处理（如 100 Continue：客户端可继续发送请求体）。
-   2xx（成功类）：请求正常处理（200 OK：成功返回数据；204 No Content：成功但无返回体，如 DELETE 操作）。
-   3xx（重定向）：需要客户端进一步操作（301 永久重定向：浏览器会缓存，适合域名迁移；302 临时重定向：不缓存，适合临时跳转，如登录后跳回原页面）。
-   4xx（客户端错误）：请求有问题（400 Bad Request：请求参数错误；401 Unauthorized：未登录；403 Forbidden：登录后无权限；404 Not Found：资源不存在）。
-   5xx（服务器错误）：服务器处理失败（500 Internal Server Error：服务器代码报错；502 Bad Gateway：服务器作为代理时，上游服务器出错）。

高频考点：

-   301 vs 302 的区别（缓存、SEO 影响）；
-   401 vs 403 的区别（是否登录）。
-

### 3. HTTP 版本差异（1.0/1.1/2.0/3.0）

版本迭代的核心是 “优化性能”，需对比各版本的关键特性：

| 版本     | 核心特性                                                                             | 存在问题/局限性                              |
| -------- | ------------------------------------------------------------------------------------ | -------------------------------------------- |
| HTTP/1.0 | 无长连接（每次请求都需新建 TCP 连接）；不支持管道化                                  | 连接开销大，性能低，三次握手耗时             |
| HTTP/1.1 | 支持长连接（Connection: keep-alive）；管道化（同一连接可并发多个请求）               | 队头阻塞（前一个请求阻塞后续请求）           |
| HTTP/2.0 | 二进制分帧传输；多路复用（同一连接并行处理多个请求，解决应用层队头阻塞）；服务器推送 | 仍基于 TCP，TCP 层队头阻塞未彻底解决         |
| HTTP/3.0 | 基于 QUIC 协议（UDP 之上的可靠传输）；彻底解决队头阻塞；连接建立更快                 | 兼容性尚未完全普及（2024 年主流仍为 HTTP/2） |

#### 为什么 TCP 传输层的队头阻塞依然存在

TCP 是一种 “面向连接的可靠传输协议”，其核心特性之一是 **“顺序交付”**：

-   数据在传输过程中被拆分成多个 TCP 数据包，接收方必须按顺序重组这些数据包（通过序号确认）；
-   如果中间某个数据包丢失或损坏，TCP 会要求发送方重传该数据包，**在此期间，后续已到达的数据包即使完整，也会被暂存队列中，无法交付给应用层**。

对于 HTTP/2 来说，同一 TCP 连接上的所有 “流”（即所有请求）共享这个 TCP 连接。一旦发生数据包丢失，所有流的后续数据都会被阻塞，直到丢失的数据包被重传并确认 —— 这就是 TCP 层的队头阻塞，HTTP/2 无法解决。

**举例说明：**
假设一个 HTTP/2 连接上同时传输 3 个请求（流 A、流 B、流 C），它们的 TCP 数据包在传输中交错发送。若流 B 的某个数据包丢失，TCP 会触发重传：

-   此时，即使流 A 和流 C 的后续数据包已到达接收方，也会因 TCP 需等待流 B 的丢失数据包而被阻塞；
-   所有流（A、B、C）的处理都会暂停，直到重传完成。

**前端视角：**HTTP/2 的多路复用让 “合并资源（如 sprite 图、合并 JS）” 的必要性降低；HTTP/3 更适合移动端（弱网环境下连接恢复更快）。

### 4. HTTPS 的工作原理（为什么比 HTTP 安全？）

HTTPS = HTTP + TLS/SSL，核心是 “加密传输”，需讲清 **TLS 握手过程**和 “对称加密 + 非对称加密” 的结合逻辑：

**1. 客户端发起请求：**客户端向服务器发送 “支持的加密套件” 和 “随机数 A”。
**2. 服务器回应：**服务器返回 “选中的加密套件”“随机数 B” 和 “服务器证书”（含公钥，由 CA 签名）。
**3. 客户端验证证书：**客户端验证证书合法性（检查 CA 签名、有效期等），若合法，生成 “随机数 C”，用服务器公钥加密后发送给服务器。
**4. 生成会话密钥：**服务器用私钥解密得到随机数 C，双方基于 A+B+C 生成 “对称加密密钥”。
**5. 加密传输：**后续所有 HTTP 数据用对称密钥加密传输。

**安全点：**

-   非对称加密（公钥加密、私钥解密）用于传输 “对称密钥的种子（A+B+C）”，避免密钥泄露。
-   对称加密用于实际数据传输（效率高，适合大量数据）。
-   证书防止 “中间人篡改公钥”（CA 签名确保公钥来自真实服务器）。

### 5. TCP 与 UDP 的区别及适用场景

TCP 和 UDP 是传输层核心协议，差异体现在 “可靠性” 和 “效率” 的权衡：

| 特性     | TCP                                                              | UDP                                  |
| -------- | ---------------------------------------------------------------- | ------------------------------------ |
| 可靠性   | 可靠（有三次握手、重传、拥塞控制，保证数据不丢失、不重复、有序） | 不可靠（无握手，数据可能丢失、乱序） |
| 连接性   | 面向连接（传输前需建立连接）                                     | 无连接（直接发送）                   |
| 速度     | 慢（开销大）                                                     | 快（开销小）                         |
| 适用场景 | 数据不允许丢失（如 HTTP、FTP、邮件）                             | 实时性优先（如视频通话、直播、DNS）  |

**高频考点：**TCP 三次握手和四次挥手的原因：

-   三次握手：确保双方 “发送能力” 和 “接收能力” 均正常。
    -   第一次：客户端 → 服务器（“我能发”）。
    -   第二次：服务器 → 客户端（“我能收，也能发”）。
    -   第三次：客户端 → 服务器（“我能收”）。
        （若两次握手，服务器可能为 “失效的客户端请求” 建立连接，浪费资源。）
-   四次挥手：因 TCP 是全双工（双方可同时发送），需分别关闭 “发送通道” 和 “接收通道”。

#### TCP 三次握手

**过程回顾：**

1. **第一次握手（Client → Server）：**
   客户端发送 SYN 报文（SYN=1），并携带自己的初始序列号 ISN_c，请求建立连接。
   此时客户端状态：SYN_SENT（等待服务器确认）。
2. **第二次握手（Server → Client）：**
   服务器收到 SYN 后，回复 SYN+ACK 报文（SYN=1，ACK=1）：
   用 ACK=ISN_c + 1 确认客户端的 ISN_c（表示 “已收到客户端的起始序列”）；
   携带自己的初始序列号 ISN_s（告知客户端 “我将从这个序列开始发送数据”）。
   此时服务器状态：SYN_RCVD（等待客户端确认自己的 ISN）。
3. **第三次握手（Client → Server）：**
   客户端收到 SYN+ACK 后，发送 ACK 报文（ACK=1），用 ACK=ISN_s + 1 确认服务器的 ISN_s。
   此时客户端状态：ESTABLISHED（连接建立）；服务器收到 ACK 后，状态也变为 ESTABLISHED。

**为什么需要三次？而非两次或四次？**

1. **核心目的：同步双方序列号，避免 “无效连接”**
   TCP 必须确保双方都知道 “对方已收到自己的初始序列号”，否则可能因序列号不同步导致数据混乱。
    - 若仅两次握手：服务器收到客户端 SYN 后，直接进入 ESTABLISHED 状态并发送数据，但客户端可能因未收到服务器的 ISN_s 而忽略数据，导致服务器资源浪费（如保留连接缓存）。更严重的是，若客户端的 SYN 报文因网络延迟 “迟到”，服务器会误认为是新连接并建立，而客户端早已放弃，造成 “半开连接” 泄漏。
    - 三次握手的关键：第三次 ACK 让服务器确认 “客户端已收到我的 ISN_s”，双方彻底同步状态，避免上述问题。
2. **为什么不需要四次？**
   第二次握手已同时完成 “确认客户端 ISN” 和 “发送服务器 ISN” 两个动作（SYN+ACK 合并），第三次握手单独确认服务器 ISN 即可，无需额外步骤。四次握手会增加冗余，降低效率。

#### TCP 四次挥手

TCP 是全双工通信（双方可同时发送数据），关闭连接时，需要双方分别关闭各自的 “发送通道”，且需确认对方已接收完所有数据。四次挥手的设计正是为了处理这种 “双向独立关闭” 的需求。

**过程回顾：**

1. 第一次挥手（Client → Server）：
   客户端主动发起关闭，发送 FIN 报文（FIN=1），表示 “我不再发送数据了”，并携带序列号 seq=u（最后一次发送数据的序列号 + 1）。
   此时客户端状态：FIN_WAIT_1（等待服务器确认）。
2. 第二次挥手（Server → Client）：
   服务器收到 FIN 后，回复 ACK 报文（ACK=1），用 ACK=u + 1 确认客户端的关闭请求。
   此时服务器状态：CLOSE_WAIT（告知客户端 “我已收到关闭请求，但我可能还有数据要发”）；客户端状态：FIN_WAIT_2（等待服务器发送自己的关闭请求）。
3. 第三次挥手（Server → Client）：
   服务器发送完所有剩余数据后，发送 FIN 报文（FIN=1），表示 “我也不再发送数据了”，携带序列号 seq=v（服务器最后一次发送数据的序列号 + 1）。
   此时服务器状态：LAST_ACK（等待客户端确认）。
4. 第四次挥手（Client → Server）：
   客户端收到服务器的 FIN 后，发送 ACK 报文（ACK=1），用 ACK=v + 1 确认。
   此时客户端状态：TIME_WAIT（等待一段时间，确保服务器收到确认）；服务器收到 ACK 后，状态变为 CLOSED。客户端等待 2MSL（最大报文段寿命）后，也进入 CLOSED。

**为什么需要四次？而非三次？**

1. 核心原因：全双工通信中，关闭是 “单向独立” 的
   **TCP 允许双方同时发送数据，因此 “关闭” 不是一个整体动作，而是双方各自关闭 “发送方向” 的过程**：

-   客户端发送 FIN 仅表示 “客户端 → 服务器” 的发送通道关闭，但服务器仍可向客户端发送数据（如剩余响应内容）。
-   服务器必须先回复 ACK 确认 “收到客户端的关闭请求”，再在自己的数据发送完毕后，单独发送 FIN 关闭 “服务器 → 客户端” 的通道。
    这两个动作（ACK 和 FIN）无法合并（除非服务器恰好无数据可发，但协议需兼容有数据的场景），因此第二次和第三次挥手必须分开，导致四次挥手。

2. 若强行三次挥手会怎样？
   假设服务器收到客户端 FIN 后，将 ACK 和 FIN 合并发送（类似握手时的 SYN+ACK），**可能导致服务器尚未发送完数据就关闭通道，造成数据丢失**。因此协议必须允许服务器先确认关闭请求，再延迟发送自己的 FIN，这决定了四次挥手的必然性。

3. TIME_WAIT 状态的意义（四次挥手的额外细节）
   客户端最后进入 TIME_WAIT 并等待 2MSL，是为了：
    - 确保服务器能收到最后的 ACK（若 ACK 丢失，服务器会重发 FIN，客户端可再次回复）；
    - 避免已关闭的连接报文干扰新连接（2MSL 内，网络中残留的该连接报文会过期）。

注意：TCP 的 ACK 并非多余，它是确认 “对方已收到信息” 的核心机制，尤其对于 FIN 这类控制报文，必须通过 ACK 确保双方状态同步。

## 二、深度原理：细节与扩展

**1. TCP 拥塞控制（慢启动、拥塞避免）**
TCP 为避免网络拥堵（如服务器发送过快导致路由器缓存满），会动态调整发送速率：

-   慢启动：初始发送窗口小（如 1 个报文），每收到一个确认（ACK），窗口大小翻倍（指数增长），直到达到 “慢启动阈值”。
-   拥塞避免：达到阈值后，窗口大小线性增长（每次 ACK 加 1），若发生丢包（如超时未收到 ACK），则阈值减半，重新慢启动。

**2. HTTP 缓存为什么要区分强缓存和协商缓存？**
设计逻辑是 “平衡性能与准确性”：

-   强缓存优先级高，直接用本地缓存，减少请求次数（性能最优），但可能返回过期数据（如服务器资源已更新但缓存未过期）。
-   协商缓存需发请求，但由服务器判断是否用缓存（准确性高），适合 “数据可能频繁更新但不希望每次都重新传输” 的场景（如接口数据）。

**3. HTTPS 为什么不全程用非对称加密？**
非对称加密（如 RSA）的计算复杂度远高于对称加密（如 AES）。若全程用非对称加密，会导致传输效率极低（尤其是大量数据）。因此设计为 “非对称加密传密钥，对称加密传数据”，兼顾安全与效率。
