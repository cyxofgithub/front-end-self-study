## 00_面试题节选

### 谈谈 JS 运行机制

-  为什么是单线程？
- js 离不开和用户的操作和用途有关
- 如果 js 是多线程，操作 dom 的时候有线程是增加有的是删除，浏览器到底以那个为主？

### arguments 的对象是什么？

 - 箭头函数是没有arguments对象的
 - 是一个类数组对象，有 length 但是没有数组的其他 API

 ```js
function get(){
  console.log(arguments)
  console.log(...arguments);
  // 怎么转化成数组呢 ？？
  console.log(Array.prototype.slice.call(arguments));
}
get(1,2,3)
 ```

 ### 为什么在调用这个函数时，代码中的`b`会变成一个全局变量?

```js
function fun(){
  // let a = b = 0
  let a = (b = 0) // 上面的相当于下面，由于 b 并没有被声明，所以 js 引擎会在全局上创建一个 b
}
```

###  哪些操作会造成内存泄漏？

- 闭包
- 意外的全局变量（像上面的例子）
- 被遗忘的定时器（写了没清除）
- 脱离dom的引用 （获取了 dom 元素，保持着对它的引用，但是在页面这个节点其实已经删除了）

### 什么是高阶函数？

- 将函数作为参数或者返回值的函数 

### 手动实现`Array.prototype.map 方法`

```js
  <script>
    var arr = [1, 2, 3]
    var array = arr.map((item, index) => {
      return item * 2
    })
    console.log(array)


    function map(arr, mapCallback) {
      // 检查参数是否正确
      if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
        return []
      } else {
        // 进行下面的操作
        let result = []
        for (let i = 0, len = arr.length; i < len; i++) {
          // map 回调有三个参数，选项，序号，数组本身
          result.push(mapCallback(arr[i], i, arr))
        }
        return result
      }
    }
    var res = map(arr, (item) => {
      // console.log(item)
      return item * 2
    })
    console.log(res)

  </script>
```

## 01_预编译习题的讲解

## 02_this的面试题

### 在函数中直接使用

```js
    function get(content) {
      console.log(content)
    }
    get('你好')
	// 本质是默认绑定
    get.call(window, '你好')

```

### 函数作为对象的方法被调用(谁调用我 我就指向谁)

```js
    var person = {
      name: '张三',
      run: function (time) {
        console.log(`${this.name} 在跑步 最多${time}min就不行了 `)
      }
    }
	
    person.run(30)
    // 本质是隐式绑定（通过对象调用）
    person.run.call(person, 30)

```

### 面试题

```js
//  阿里的笔试题
    var name = 222
    var a = {
      name: 111,
      say: function () {
        console.log(this.name)
      }
    }

    var fun = a.say
    fun() // window
    a.say() // a

    var b = {
      name: 333,
      say: function (fun) {
        fun() 
      }
    }
    b.say(a.say) // fun() 单独调用 指向 window
    b.say = a.say
    b.say() // b
```

## 03_箭头函数的 this 技巧

## 04_js 的深浅拷贝

### **赋值和浅拷贝的区别**

tips：这是针对引用类型来说

- 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
- 浅拷贝是创建一个**新**对象，这个对象有着原始对象属性值的一份精确拷贝。
  **如果属性是基本类型，拷贝的就是基本类型的值**，**如果属性是引用类型，拷贝的就是内存地址** ，所以如果其中一个对象改变了属性是引用类型的对象的内容，就会影响到另一个对象，而基本类型则不会。

### 浅拷贝和深拷贝区别

- 浅拷贝是创建一个**新**对象，这个对象有着原始对象属性值的一份精确拷贝。

- 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。

### 浅拷贝的实现方式

- Object.assign()
- lodash _.clone
- ... 展开运算符 用的最多的
- Array.prototype.concat
- Array.prototype.slice


### 深拷贝的实现方式

- JSON.parse(JSON.stringify())
- 递归
- jquery.entend()

## 05_防抖函数

### 理解

- 当持续触发事件 一定时间内没有再触发事件 事件处理函数才会执行一次 
- 如果设定的时间到来之前，又一次触发了事件就重新开始延时

（在设定的时间内 又一次触发了事件 重新开始延时 代表的就是重新开始定时器）

（那么意味着上一次还没有结束的定时器要清除掉重新开始）

### **没有防抖时，每次输入都会触发回调**

```js
        // 第一步
        function debounce(delay, arg) {
            setTimeout(function () {
                console.log(arg)
            }, delay)
        }
        var input = document.getElementById('input')
        input.addEventListener('keyup', function (e) {
            debounce(1000, e.target.value)
        })
```

### **理想写法**（不可行）

```js
        // 改进一
        function debounce(delay, arg) {
            let timer
            clearTimeout(timer)
            timer = setTimeout(function () {
                console.log(arg)
            }, delay)
        }
        var input = document.getElementById('input')
        input.addEventListener('keyup', function (e) {
            debounce(1000, e.target.value)
        })
```

tips：你会发现每次 timer 都是 undefined，如何改进 -> 利用闭包 -> 让 timer 存储在内存当中（内存泄漏），不会释放

### **闭包写法**

```js
        function debounce(delay) {
            let timer
            return function (arg) {
                clearTimeout(timer)
                timer = setTimeout(function () {
                    console.log(arg)
                }, delay)
            }
        }
        var input = document.getElementById('input')
        var debounceFn = debounce(1000)
        input.addEventListener('keyup', function (e) {
            debounceFn(e.target.value)
        })
```

## 06_节流函数

### 理解

- 当持续触发事件的时候 保证一段时间内 只调用一次事件处理函数 
- 一段时间内 只做一件事情

### 实例

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>节流</title>
</head>

<body>
  <button id="button">点击</button>
  <script>
    function throttle(func, wait) {
      let timerOut
      return function () {
        // 在你执行回调之前，不管用户怎么点击，都不会触发回调第二次了，因为 timeOut 有值，只有回调执行后才会置为 null
        if (!timerOut) {
          timerOut = setTimeout(function () {
            // 当回调执行了之后便可将 timeOut 设置为空，后面的点击才能继续触发
            timerOut = null
            func()
          }, wait)
        }
      }
    }
    function handle() {
      console.log(Math.random())
    }
    document.getElementById("button").onclick = throttle(handle, 2000)
  </script>
</body>

</html>
```

## 07_js 作用域

### 一般理解

1. 全局作用域
   (1) 全局作用域在页面打开时被创建,页面关闭时被销毁
   (2) 编写在script标签中的变量和函数,作用域为全局，在页面的任意位置都可以访问到
   (3) 在全局作用域中有全局对象window,代表一个浏览器窗口,由浏览器创建,可以直接调用
   (4) 全局作用域中声明的变量和函数会作为window对象的属性和方法保存

2. 函数作用域
   (1) 调用函数时,函数作用域被创建,函数执行完毕,函数作用域被销毁
   (2) 每调用一次函数就会创建一个新的函数作用域,他们之间是相互独立的
   (3) 在函数作用域中可以访问到全局作用域的变量,在函数外无法访问到函数作用域内的变量
   (4) 在函数作用域中访问变量、函数时,会先在自身作用域中寻找,若没有找到,则会到函数的上一级作用域中寻找,一直到全局作用域

### 深层次理解

+ 执行期的上下文 
  - 当函数代码执行的前期，会创建一个执行期上下文的内部对象 AO（作用域） 
  - 这个内部的对象是预编译的时候创建出来的 因为当函数被调用的时候 会先进行预编译 
  - 在全局代码执行的前期会创建一个执行期的上下文的对象GO 


### 函数作用域预编译

1. 创建ao对象 AO{}
2. 找形参和变量声明 将变量和形参名 当做 AO对象的属性名 值为undefined
3. 实参形参相统一 
4. 在函数体里面找函数声明 值赋予函数体

### 全局作用域的预编译

1. 创建 GO对象
2. 找变量声明 将变量名作为GO对象的属性名 值是undefined 
3. 找函数声明 值赋予函数体

```js
// 预编译笔试题一
// function fn(a, c) {
//   console.log(a) 
//   var a = 123
//   console.log(a) 
//   console.log(c)  
//   function a() { }
//   if (false) {
//     var d = 678
//   }
//   console.log(d) 
//   console.log(b) 
//   var b = function () { }
//   console.log(b) 
//   function c() { }
//   console.log(c) 
// }ds
// fn(1, 2)

// 1. 创建ao对象 AO{}
// 2. 找形参和变量声明 将变量和形参名 当做 ao对象的属性名 值为undefined
// 3. 实参形参相统一 
// 4. 在函数体里面找函数声明 值赋予函数体

// AO{
//   a:undefined 1 function a() { }
//   c:undefined 2  function c() { }
//   d:undefined 
//   b:undefined
// }
```

+ 作用域链
  - 会被保存到一个隐式的属性中去 [[scope]] 这个属性是我们用户访问不到的 但是的的确确是存在的  让js引擎来访问的 里面存储的就是作用域链 AO GO AO 和 GO的集合

### 闭包原理理解

```js
var a = 456
function A() {
	const a = 123
	return function B() {
		console.log(a)
	}
}
var test = A()
test() // 123
```

tips：A在执行完之后作用域确实被销毁了，但是 B 还没被执行，仍然保存着自己的作用域、B的作用域和全局作用域，所以输出 123

### 利用闭包实现单例模式

```html
<body>
  <button id="loginBtn">登录</button>
  <script>
    // js的单例模式  实现登录

    var createLogin = function (a, b, c) {
      console.log(a, b, c)
      var div = document.createElement("div")
      div.innerHTML = '我是登录的弹窗'
      div.style.display = 'none'
      document.body.appendChild(div)
      return div
    }

    var getSingle = function (fn) {
      var result;
      // 核心代码：利用闭包实现单例模式(只执行一次)
      return function () {
        // 第一个数是不是 undefined 就会返回，否则返回第二个
        // 而 fn result 就会被赋值，所以该函数调用后，fn 永远只会被执行一次
        return result || (result = fn.apply(this, arguments))
      }
    }
    var create = getSingle(createLogin)
    document.getElementById("loginBtn").onclick = function () {
      var loginLay = create(1, 2, 3)
      console.log(loginLay);
      loginLay.style.display = 'block'
    }
  </script>
</body>
```

## 08_js event-loop

- 事件循环机制 由三部分组成

- 调用栈 微任务队列 消息队列
- event-loop 开始的时候会从全局一行一行的执行遇到函数调用 会压入到调用栈中 被压入的函数 被称之为帧 当函数返回后会从调用栈中弹出

```js
// 执行流程
// fun2进入调用栈 -> 输出 2 -> fun1 进入调用栈 -> 输出 1 -> fun1 执行完毕从调用弹出 -> 输出3 -> fun2 执行完毕从调用弹出
function fun1(){
  console.log(1)
}
function fun2(){
  console.log(2)
  fun1()
  console.log(3)
}
fun2()
```

- js中的异步操作 比如 fetch setTimeout setInterval 压入到调用栈中的时候里面的消息会进去到消息队列中去
- 消息队列会等到调用栈清空之后再执行

```js
function func1(){
  console.log(1)
}
function func2(){
  setTimeout(()=>{
    console.log(2)
  },0)
  func1()
  console.log(3)
}
func2()
```

- promise async await 的异步操作的时候会加入到微任务中去 会在调用栈清空的时候立即执行
- 调用栈中加入的微任务会立马执行，优先级大于消息队列

```js
// 执行流程
// 输出 4 -> resolve(5) 执行完毕弹出，5加入微任务队列 -> log(2) 加入消息队列 -> 输出 1 -> 输出 3 -> 执行微任务 -> 执行消息队列
var p = new Promise(resolve=>{
  console.log(4)
  resolve(5)
})
function func1(){
  console.log(1)
}
function func2(){
  setTimeout(()=>{
    console.log(2)
  },0)
  func1()
  console.log(3)
  p.then(resolve=>{
    console.log(resolve)
  })
}
func2()
```

![image-20211017222613450](2021前端面试秋招.assets/image-20211017222613450.png)

## 09_单例模式

### 理解

- 定义: 
  - 1 只有一个实例 
  - 2 可以全局的访问
- 主要解决： 一个全局使用的类 频繁的创建和销毁
- 何时使用：当你想控制实例的数目 节省系统化资源的时候
- 如何实现：判断系统是否已经有这个单例 如果有则返回 没有则创建 
- 单例模式优点：内存中只要一个实例 减少了内存的开销 尤其是频繁的创建和销毁实例（比如说是首页页面的缓存）
- 使用场景：1 全局的缓存 2 弹窗 

### es5 实现单例模式 

- 需求：全局的弹窗展示

1. 第一种解决方案是在页面加载完成的时候便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏状态的，当用户点击登录按钮的时候，它才开始显示

```html
  <button id="loginBtn">登录</button>
  <script>
    var loginLayer = (function () {
      var div = document.createElement('div')
      div.innerHTML = '我是登录的浮窗'
      div.style.display = 'none'
      document.body.appendChild(div)
      return div
    })()

    document.getElementById('loginBtn').onclick = function () {
      loginLayer.style.display = 'block'
    }
  </script>
```

  - 缺点
    也许我们进入 WebQQ 只是玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些 DOM 节点。

2. 当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div

```html
  <button id="loginBtn">登录</button>
  <script>
    var createLoginLayer = function () {
      var div = document.createElement('div')
      div.innerHTML = '我是登录的浮窗'
      div.style.display = 'none'
      document.body.appendChild(div)
      return div
    }

    document.getElementById('loginBtn').onclick = function () {
      var loginLayer = createLoginLayer()
      loginLayer.style.display = 'block'
    }
  </script>
```

 - 缺点
   虽然现在达到了惰性的目的，但失去了单例的效果。当我们每次点击登录按钮的时候，都会 创建一个新的登录浮窗 div。虽然我们可以在点击浮窗上的关闭按钮时（此处未实现）把这个浮窗从页面中删除掉，但这样频繁地创建和删除节点明显是不合理的，也是不必要的。
   继续改进：


3. **单例模式实现**

```html
 <button id="loginBtn">登录</button>
  <script>
    var createLoginLayer = (function () {
      var div
      return function () {
        if (!div) {
          div = document.createElement('div')
          div.innerHTML = '我是登录的浮窗'
          div.style.display = 'none'
          document.body.appendChild(div)
        }
        return div
      }
    })()

    document.getElementById('loginBtn').onclick = function () {
      var loginLayer = createLoginLayer()
      loginLayer.style.display = 'block'
    }
  </script>
```

  - 缺点
    - 违背单一职责
      违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 
    - 单一职责要求分离出来

4. **优化后的单例模式**

```html
  <button id="loginBtn">登录</button>
  <script>
    var getSingle = function (fn) {
      var result
      return function () {
        // return result || (result = fn.apply(this, arguments))
        return result || (result = fn(...arguments))
      }
    }
    var createLoginLayer = function () {
      var div = document.createElement('div')
      div.innerHTML = '我是登录的浮窗'
      div.style.display = 'none'
      document.body.appendChild(div)
      return div
    }
    
    // 这个变量保存 getSingle 返回的函数非常重要
    var createSingleLoginLayer = getSingle(createLoginLayer)
    document.getElementById('loginBtn').onclick = function () {
      // 因为你如果在这里写成 var loginLayer = getSingle(createLoginLayer)()
      // 每次都会返回一个新的函数，这样就实现不了单例效果了
      // 总结：单例的实现离不开标记变量，我们要保证每次创建实例的时候对标记位做一个判断
      var loginLayer = createSingleLoginLayer()
      loginLayer.style.display = 'block'
    }
  </script>
```


### es6 实现单例模式 

#### class类

- **是什么**
  es6提供的一种新的生成实例对象的方法class可以看作只是一个语法糖
  es5 构造函数的另外一种写法
- **作用**
  更接近传统语言的写法新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法

- es5以前生成对象

```js
function Person(name, sex) {
    this.name = name;
    this.sex = sex
}
Person.prototype.say = function () {
  console.log('学前端很幸福')
};
let person1 = new Person('张三','男')
console.log(person1.name);
person1.say()
```

- es6实现

```js
class Person {
    constructor(name,sex){
        this.name = name
        this.sex = sex
    }
    say(){
        console.log('学前端很幸福');
    }
}
let person1 = new Person('张三','男')

console.log(person1.name); // 张三
person1.say() // 我会说话

```

- **constructor 方法** 
  constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。

- **静态属性**
  静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。

```js
class Person {
    static age = 18
    name = '张三'
}
let person = new Person();
console.log(person.age); // undefined

```

- **静态方法**
  类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

```js
class Foo {
  static classMethod() {
    return 'hello';
  }}

Foo.classMethod() // 'hello'
foo.classMethod()

```

#### ES6 中的单例模式

- 下面我们来使用ES6的语法实例化LingYuan公司

```js
class LingYuan {
  constructor(name, creator, products) {
    this.name = name;
    this.creator = creator;
    this.products = products;
  }
}

let lyCompany = new LingYuan('零远教育', '裴广斌', ['es6', 'vue', 'react', 'node']);
let lyCopyCompany = new LingYuan('苹果公司', 'walker', ['es7', 'vue', 'react', 'node']);
```

- ES6中创建单例模式
  零远公司明显有且只有一个, 就是裴老师创建的那个, 哪能容别人进行复制？所以LingYuan应该是一个单例, 现在我们使用ES6的语法将constructor改写为单例模式的构造器。

- ES6的静态方法优化代码

ES6中提供了为class提供了static关键字定义静态方法， 我们可以将constructor中判断是否实例化的逻辑放入一个静态方法getInstance中，调用该静态方法获取实例， constructor中只包需含实例化所需的代码，这样能增强代码的可读性、结构更加优化。

```js
  class SingletonLy {
      constructor(name, creator, products) {
        this.name = name;
        this.creator = creator;
        this.products = products;
      }
      //静态方法
      static getInstance(name, creator, products) {
        if (!this.instance) {
          this.instance = new SingletonLy(name, creator, products);
        }
        return this.instance;
      }
    }
    let lyCompany = SingletonLy.getInstance('零远思维', '裴广斌', ['vue', 'react', 'node', 'js']);
    let lyCopyCompany = SingletonLy.getInstance('零远copy', 'walker', ['vue', 'react', 'node', 'js'])
    console.log(lyCompany === lyCopyCompany);
```

## BFC 的理解

要理解 BFC 我觉得可以从一个现象说起，比如说有两个 div 他们两个是父子关系，然后子 div 设置了浮动，这时父 div 如果没有设置高度， 它无法撑起自身，就是因为这个盒子没有形成 BFC，就可以通过...方法解决，另外 BFC 还可以...

![image-20211031180501744](2021前端面试秋招.assets/image-20211031180501744.png)

![image-20211031180228882](2021前端面试秋招.assets/image-20211031180228882.png)

tips：可以解决 margin 塌陷

![image-20211031180414149](2021前端面试秋招.assets/image-20211031180414149.png)

tips：可以阻止被浮动元素覆盖

## 10_vue面试题

### vuex工作流程

![image-20220213150758234](2021前端面试秋招.assets/image-20220213150758234.png)

tips：什么时候需要用到 getters？当c1、c2、c3获取state的某个值需要根据不同条件进行筛选的时候，我们可以将这个方法封装在getter里，不要写成store.state.xxx.filter（条件）写成gtter（条件）

### vue的路由钩子函数

- 全局钩子函数：beforeEach、afterEach

![image-20220213151241369](2021前端面试秋招.assets/image-20220213151241369.png)

![ ](2021前端面试秋招.assets/image-20220213151319972.png)

![image-20220213151444183](2021前端面试秋招.assets/image-20220213151444183.png)

如 /path跳到 /path/subPath 时才会触发

### 自定义vue指令实现图片的懒加载

```js
<img
  v-for="(item,index) in arrSrc"
  :key="index"
  :src="moren"
  v-lazy="item"
  alt="x"
/>

  Vue.directive("lazy", {
      	// 被绑定匀速插入父节点时调用。在这里可以进行一次性的初始化设置。
        inserted(el, binding) {
          //定义一个观察器，entries为状态改变（出现在视图中）元素的数组
          let observer = new IntersectionObserver((entries) => {
            // 遍历
            for (let i of entries) {
              // 如果改元素处于可视区
              if (i.isIntersecting > 0) {
                // 获取该元素
                let img = i.target;
                // 重新设置src值，binding为绑定的值item
                img.src = binding.value;
                //取消对该元素的观察
                observer.unobserve(img);
              }
            }
          });
          // 为 img 标签添加一个观察
          observer.observe(el);
        },
      });
```

## 11 大厂经典面试题

### 一

![image-20220213160331215](2021前端面试秋招.assets/image-20220213160331215.png)

后面的两个b.say 一个输出222 一个输出333
